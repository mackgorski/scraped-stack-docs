[
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on",
    "markdown": "# Configure SAML Identity Provider-Initiated Single Sign-On\n\nMany instructions for setting up a SAML federation begin with Single Sign-on (SSO) initiated by the service provider. The service provider redirects the user to the identity provider (IdP) for the purposes of authentication. This process is commonly used for consumer-facing scenarios.\n\nHowever, in enterprise scenarios, it is sometimes common to begin with the IdP initiating SSO instead of the service provider. For example, an enterprise might set up a portal to ensure that users navigate to the correct application after they sign on to the portal.\n\n## Risks and considerations\n\nIdP-Initiated flows carry a security risk and are therefore not recommended. The recommendation is to use SP-Initiated flows whenever possible.\n\nMake sure you understand the risks before enabling IdP-Initiated SSO. In this scenario, Auth0 receives the unsolicited response from the IdP and the application receives the unsolicited response from Auth0. Neither entity can verify that the user started the flow. Because of this, enabling this flow opens the possibility of an [Login CSRF attack](https://support.detectify.com/support/solutions/articles/48001048951-login-csrf), where an attacker can trick a legitimate user into unknowingly logging into the application with the identity of the attacker.\n\n### OpenID Connect IdP-initiated flow\n\nOpenID Connect (OIDC) does not support the concept of an IdP-Initiated flow. So while Auth0 offers the possibility of translating a SAML IdP-Initiated flow (from a SAML connection) into an OIDC response for an application, any application that properly implements the OIDC/OAuth2 protocol will reject an unrequested response.\n\nWhen using OIDC applications, the best option is to have your application create a login endpoint. This endpoint’s sole purpose is to initiate the redirect back to the IdP (your Auth0 tenant).\n\nIf you use multiple IdPs, be sure that the login endpoint is either specific to the identity provider or can accept a parameter to identify which IdP initiates the workflow.\n\nAn alternative approach is to have users start the login flow at the application.\n\n### Post-back URL\n\nWhen using IdP-Initiated SSO, make sure to include the connection parameter in the post-back URL:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}\n```\n\nIf you are using the [Organizations](https://auth0.com/docs/manage-users/organizations) feature, you can optionally include an organization parameter containing the organization ID of the desired organization:\n\n```\nhttps://{yourDomain}/login/callback?connection={yourConnectionName}&organization={yourCustomersOrganizationId}\n```\n\n### Lock/Auth0.js\n\nIf your application is a single-page application that uses Lock or Auth0.js to process the authentication results, you must explicitly indicate that you want to allow IdP-Initiated flows and thus open the application to possible Login CSRF attacks.\n\nIf you are using Auth0.js, you must update the `webAuth.parseHash` of the library and set the flag `__enableIdPInitiatedLogin` to `true`.\n\n```\nvar data = webAuth.parseHash(\n      {\n        ...\n        __enableIdPInitiatedLogin: true\n        ...\n      }\n```\n\nIf you're using Lock, you can include the flag using the options parameter sent to the constructor.\n\n`const lock = new Auth0Lock(clientID, domain, options)`\n\nHere's the flag itself:\n\n`var options = { _enableIdPInitiatedLogin: true };`\n\nNote that the `enableIdPInitiatedLogin` flag is preceded by one underscore when used with Lock and two underscores when used with the auth0.js library.\n\n## Set up IDP-initiated SSO\n\n1.  Go to the [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and choose **SAMLP Identity Provider**.\n    \n2.  Under **Settings** you can see the configuration for IdP-Initiated SSO.\n    \n    ![Protocols IdP-initiated SSO Configuration Screen](https://images.ctfassets.net/cdy7uua7fh8z/1HORCAp4fZQg0BOoIopvoS/084dcac9f133b98526e8bda222a6e37c/conn-enterprise-saml-idp-initiated-sso.png)\n\n*   **IdP-initiated SSO Behavior**: This option allows you to enable IdP-initiated logins for the SAML connection. Select **Accept Requests** and complete all the required fields.\n    \n*   **Default Application:** When the IdP initiated login succeeds this is the application where users are routed. This setting shows available applications enabled for this connection. Select the application from the dropdown that you want the users to login with IdP initiated. Only one application can be selected for an IdP-initiated login per SAML connection.\n    \n*   **Response Protocol:** This is the protocol used to connect your selected **Default Application**. Most commonly, applications are configured with the OpenID Connect protocol (see above). However, if you have configured a SAML2 Web App addon for your application and want to route the SAML assertion you will need to select SAML. Once a valid SAML Assertion has been passed to the postback URL, Auth0 sends a login response to the configured default application’s first allowed callback URL using the chosen response protocol, which can be modified using the query string field to specify a `redirect_uri` if you use OIDC.\n    \n*   **Query String:** Query string options help to customize the behavior when the OpenID Connect protocol is used. You can set multiple options similar to setting parameters with a [query string](https://en.wikipedia.org/wiki/Query_string). You can set:\n    \n    | Setting | Description |\n    | --- | --- |\n    | `redirect_uri` | When the IdP-initiated login has completed the request is then redirected to the first URL listed in the **Allowed Callback URLs** for the application. However, if you set a `redirect_uri`, the IdP will redirect to this URL. This adds flexibility for cases such as when you have a set subdomain scheme with a wildcard and you only want to redirect to one specific subdomain. |\n    | `scope` | Define scopes for the ID token sent. You can set multiple scopes. |\n    | `response_type` | Set the token for the Implicit Grant Flow for SPAs. You can set code for the Authorization Code Grant Flow for regular web apps. |\n    \n    Example Query String: `redirect_uri=https://jwt.io&scope=openid email&response_type=token`\n\n## Application drop-down list limited to 100\n\nIf you want to select an application as the **Default Application** in IdP-initiated SSO, and the application isn't in the first 100 applications listed in the drop-down list for your tenant, you must use the Management API to select that application. You must run a patch:\n\n```\n{\n\"options\": {\n\"signInEndpoint\": \"yourIdpSignInUrl\",\n\"idpinitiated\": {\n\"client_id\": \"yourClientId\",\n\"client_protocol\": \"saml\",\n\"client_authorizequery\": \"\"\n},\n\"signingCert\": \"[copied-from-GET]\"\n}\n}\n```\n\n## Learn more\n\n*   [Work with Certificates and Keys as Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings)",
    "title": "Configure SAML Identity Provider-Initiated Single Sign-On",
    "description": "Describes how to configure SAML Identity Provider-initiated Single Sign-on (SSO).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-idp-initiated-saml-sign-on-to-oidc-apps",
    "markdown": "# Configure IdP-Initiated SAML Sign-on to OIDC Apps\n\nAuth0 provides a method to translate an Identity Provider\\-initiated (IdP) SAML response into an OpenID Connect (OIDC) response for an application.\n\nThe OIDC protocol does not support IdP-initiated authentication flows, but this method allows you to simulate an IdP-initiated authentication flow using the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\nIf you’d like to implement this method, you must:\n\n*   Add a custom login route handler to your application.\n    \n*   Update your SAML connection to:\n    \n    1.  Accept incoming IdP-initiated SAML responses.\n        \n    2.  Redirect to a default application that sends a Service Provider-initiated authentication request.\n        \n\n## How it works\n\n![Identity Provider-initiated SAML sign-in to OIDC applications flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/5vinAB4pSSwaKDgliTkAhh/0c5822149426b986bbcc851d07666187/idp-provider-init-saml-sign-in0.png)\n\n1.  User navigates to the SAML IdP’s login endpoint.\n    \n2.  SAML IdP returns the login page.\n    \n3.  User submits credentials to the SAML IdP.\n    \n4.  SAML IdP creates a session for the user and then returns an HTML page with Form Post and the SAML response.\n    \n5.  Page automatically sends the SAML response to the Auth0 tenant through an HTTP `POST` call.\n    \n6.  Auth0 tenant redirects the user’s browser to the OIDC application’s custom login route handler with the ID token as a URL fragment.\n    \n7.  Browser calls the custom login route handler of the OIDC application with the `connection` parameter and the ID token.\n    \n8.  OIDC application ignores the ID token, parses the `connection` parameter, creates a `state` parameter for the session, and then redirects the user’s browser to the Auth0 tenant’s `/authorize` endpoint.\n    \n9.  Browser calls the Auth0 tenant’s `/authorize` endpoint with the provided `connection` and `state` parameters.\n    \n10.  Auth0 tenant generates a SAML login request and then redirects the user’s browser to SAML IdP’s login endpoint.\n    \n11.  Browser sends the SAML login request to the SAML IdP’s login endpoint.\n    \n12.  SAML IdP finds the user’s session and then returns an HTML page with Form Post and the SAML response.\n    \n13.  Page automatically sends the SAML response to the Auth0 tenant through an HTTP `POST` call.\n    \n14.  Auth0 tenant redirects the user’s browser to the application’s login route handler.\n    \n15.  Browser calls the application’s login route handler with the provided `state` parameter and ID token.\n    \n16.  OIDC application verifies the `state` parameter, parses the ID token and creates an application session for the user.\n    \n\n## Create the custom login route handler\n\nThe custom login route handler calls your application’s login method. The handler must accept the `connection` parameter and include it in the authentication request sent to your Auth0 tenant.\n\nWe recommend that you associate the custom login route handler with a different endpoint than the one associated with your standard login route handler. For example, if your standard login route handler is associated with the `/login` endpoint, you could associate the custom login route handler with the `/startlogin` endpoint.\n\n### Example\n\nIf you are using the [Auth0 Single Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk), you can add a custom login route handler and update the login method to support the connection parameter like so:\n\n```\nconst router = {\n  \"/\": () => showContent(\"content-home\"),\n  \"/profile\": () =>\n    requireAuth(() => showContent(\"content-profile\"), \"/profile\"),\n  \"/login\": () => login(),\n  \"/startlogin\": () => startlogin()\n};\n\n//new method to start login from idp-initiated callback\nconst startlogin = async () => {\n  console.log(window.location.href)\n  let myURL = new URL(window.location.href);\n  let conn = myURL.searchParams.get(\"connection\");\n  return  login(null, conn);\n}\n\n/**\n * Starts the authentication flow\n */\nconst login = async (targetUrl, connection) => {\n  try {\n    console.log(\"Logging in\", targetUrl);\n\n    const options = {\n      redirect_uri: window.location.origin,\n    };\n\n    if (connection) {\n      options.connection = connection;\n    }\n\n    if (targetUrl) {\n      options.appState = { targetUrl };\n    }\n\n    await auth0.loginWithRedirect(options);\n  } catch (err) {\n    console.log(\"Log in failed\", err);\n  }\n};\n```\n\n## Create the query string\n\nThe query string contains the `redirect_uri` parameter. The parameter’s value must be URL encoded and is composed of:\n\n1.  The application endpoint associated with the custom login route handler.\n    \n2.  The `connection` parameter with the value of your SAML connection name.\n    \n\n### Example\n\nIf your application endpoint is `https://exampleco.com/startlogin` and your SAML connection name is `my-saml-connection`, the query string would be `redirect_uri=https%3A%2F%2Fexampleco.com%2Fstartlogin%3Fconnection%3Dmy-saml-connection`.\n\n## Configure the application\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Create a new Application to represent the OIDC application in Auth0.\n    \n3.  Update **Allowed Callback URLs** to include the application endpoint associated with your custom login route handler.\n    \n\n## Configure the connection\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Create a new SAML connection.\n    \n3.  Switch to the **IdP-Initiated SSO** view.\n    \n4.  Select **Accept Requests.**\n    \n5.  For **Default Application**, select the application you previously created.\n    \n6.  For **Response Protocol**, select **OpenID Connect**.\n    \n7.  For **Query String**, enter the query string you previously created.\n    \n\n## Learn more\n\n*   [Connect Your App to SAML Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml)\n*   [Configure SAML Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
    "title": "Configure IdP-Initiated SAML Sign-on to OIDC Apps",
    "description": "Learn how to configure an Auth0 SAML connection to support Identity Provider-initiated sign-on to a SAML Identity Provider for OIDC applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku",
    "markdown": "# Configure Heroku as SAML Service Provider\n\nUse the following SAML configuration for Heroku.\n\n## Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to the **ACS URL** for your organization from the Settings page in the Single Sign-On section in Heroku.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":\"THE-HEROKU-ENTITY-ID\",\n         \"mappings\": {\n           \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         },\n         \"createUpnClaim\": false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\": false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         ]\n        }\n    ```\n    \n    The `audience` parameter is the **Heroku Entity ID** from the Settings page in Heroku. It will be formatted like this: `https://sso.heroku.com/saml/{yourHerokuOrg}.`\n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Heroku.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO in Heroku\n\nIn Heroku, on the Settings page in the Single Sign-On section, click **Upload Metadata** and select the file containing the **Identity Provider Metadata** you downloaded in the previous step.",
    "title": "Configure Heroku as SAML Service Provider",
    "description": "Learn how to configure the Auth0 as an identity provider using the SAML2 Web App Addon for Heroku.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua",
    "markdown": "# Configure Oracle Eloqua Marketing Cloud as SAML Service Provider\n\nUse the following SAML configuration for Oracle Eloqua Marketing Cloud.\n\n## Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of the application you want to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://login.eloqua.com/auth/saml2/acs`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n        \"audience\": \"<Service Provider Entity Url from within Eloqua>\",\n         \"recipient\": \"https://login.eloqua.com/auth/saml2/acs\",\n           \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n           },\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n        ],\n         \"destination\": \"https://login.eloqua.com/auth/saml2/acs\"\n          }\n    ```\n    \n    Note that the `audience` is set to `http://foo`. This will be changed when the identity provider settings are completed on the Eloqua side.\n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate the **Identity Provider Metadata** and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Eloqua.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO in Oracle Eloqua\n\n1.  Login as Admin on Eloqua and click on **Settings > Users > Single Sign-On > Identity Provider Settings**.\n    \n2.  Click **Upload Identity Provider from Metadata**. Upload the **Identity Provider metadata** you downloaded from the **Usage** tab in the Auth0 Dashboard.\n    \n3.  Browse to find the downloaded metadata file.\n    \n4.  Edit the newly added identity provider and complete the following steps:\n    \n    1.  Set the **User Identity Mapping** to `Assertion contains the Email Address from the User object` and click **Save**.\n        \n    2.  From the **Identity Provider Details** copy the **Service Provider Entity URL**.\n        \n    3.  Within ELOQUA IdP settings, if this is the default IdP, mark this IdP as default.\n        \n\n## Update Audience Restriction in Auth0\n\nUse the **Service Provider Entity URL** copied from the identity provider settings in Eloqua to set the `audience` restriction in the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of the application you want to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, update the `audience` to the value you copied from Eloqua.\n    \n\n## Test configuration\n\n**Login to Eloqua with Auth0** should be enabled now. You can sign in to Eloqua with both IdP-initiated login and SP-initiated login.\n\n*   For SP-initiated login, go to [https://login.eloqua.com/auth/saml2](https://login.eloqua.com/auth/saml2) and enter your company name and start the SAML login process with Auth0.\n    \n*   For IdP-Initiated login use the **Identity Provider Login URL** defined here: **Dashboard > Applications > Applications** on the **Addons** tab, **SAML 2 Web App**, **Usage** tab.",
    "title": "Configure Oracle Eloqua Marketing Cloud as SAML Service Provider",
    "description": "Learn how to configure the Auth0 as the identity provider using the SAML2 Web App addon for Oracle Eloqua.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud",
    "markdown": "# Configure GitHub Enterprise Cloud as SAML Service Provider\n\nYou can configure Auth0 to serve as an identity provider for [GitHub Enterprise Cloud](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on) (github.com). GitHub requires an enterprise-level subscription to enable using an external SAML IdP.\n\n*   To learn about SSO on GitHub, read [About authentication with SAML single sign-on](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on) on [https://docs.github.com](https://docs.github.com/).\n    \n*   To learn how to configure Auth0 as the identity provider for GitHub Enterprise Server (private instance), read [Configure Auth0 as Identity Provider for GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server).\n    \n\n## Configure SAML SSO on Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Give it a meaningful name like **GitHub**. You can choose any application type, but the **Regular Web App** type is recommended.\n    \n2.  Go to the [Addons](https://manage.auth0.com/#/applications/{yourClientId}/addons) tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://github.com/orgs/{YOUR_GITHUB_ORG_NAME}/saml/consume`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://github.com/orgs/{yourGitHubOrgName}\",\n          \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"emails\",\n        \"name\": \"full_name\"\n          },\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n          ]\n        }\n    ```\n    \n    1.  Replace `{YOUR_GITHUB_ORG_NAME}` with the GitHub organization name that corresponds to your subscription. The mapping will send the `user_id` as the **Name Identifier** to GitHub. This is a good option if you enable more than one connection for the GitHub application, as it will ensure uniqueness (every user will have a different ID).\n        \n    2.  If you are using a single connection, you might want to use the `nickname` or another unique identifier as a friendlier **Name Identifier** (but make sure that the property you choose is unique). As an example, if you want `nickname` as the **Name Identifier**, the `mappings` section above will look like this:\n        \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata** and click **Download** to download the metadata file. You will need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO on GitHub\n\n1.  Follow the instructions in GitHub for [Enabling and testing SAML Single Sign-on (SSO) for your organization](https://help.github.com/en/articles/enabling-and-testing-saml-single-sign-on-for-your-organization) to complete the configuration on GitHub Enterprise Cloud.\n    \n2.  You will need the following information:\n    \n    | **Field** | **Entry** |\n    | --- | --- |\n    | **Sign On URL** | `https://{yourDomain}/samlp/{CLIENT_ID}`  <br>`{CLIENT_ID}` will be the `client_id` for the GitHub application you just created in Auth0. |\n    | **Issuer** | `urn:auth0:{yourTenant}` |\n    | **Public Certificate** | Download it from `https://{yourDomain}/pem`. Open the downloaded file with a text editor, copy the contents and paste it in the text area on GitHub. |\n    | **Signature method** | `RSA256-SHA256` |\n    | **Digest method** | `SHA256` |\n    \n3.  As recommended in GitHub's documentation, before enabling SAML SSO for your organization, click **Test SAML configuration** to ensure that the information you've entered is correct.\n    \n\nWhen setting up SAML single sign-on (SSO) for your organization, you can test your implementation without affecting your organization members by leaving **Require SAML SSO authentication** **for all members of the organization** unchecked.",
    "title": "Configure GitHub Enterprise Cloud as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for a GitHub Enterprise Cloud (github.com) organization.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws",
    "markdown": "# Configure Amazon Web Services as SAML Service Provider\n\nConfigure the SAML2 Web App addon for Amazon Web Services (AWS) for an application.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://signin.aws.amazon.com/saml`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**. Be sure to replace the `AWS_SSO_ISSUER_URL` and `AWS_SSO_ACS_URL` placeholders with values you copied from AWS.\n    \n    ```\n    {\n      \"audience\": \"AWS_SSO_ISSUER_URL\",\n      \"destination\": \"AWS_SSO_ACS_URL\",\n      \"mappings\": {\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n      },\n      \"createUpnClaim\": false,\n      \"passthroughClaimsWithNoMapping\": false,\n      \"mapUnknownClaimsAsIs\": false,\n      \"mapIdentities\": false,\n      \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n      \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n      ]\n    }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\nTo learn how to configure AWS for SSO, read [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso).\n\n## Learn more\n\n*   [Use Amazon Web Services Session Tags for Role-Based Access Control](https://auth0.com/docs/customize/integrations/aws/session-tags)\n*   [Configure Amazon Web Services for Single Sign-On](https://auth0.com/docs/customize/integrations/aws/configure-amazon-web-services-for-sso)",
    "title": "Configure Amazon Web Services as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Amazon Web Services (AWS).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings",
    "markdown": "# Work with Certificates and Keys as Strings\n\nYou can use the following command in a UNIX shell to concatenate a PEM-formatted certificate with `\\n` (escaped new-line):\n\n```\nawk 'NF {sub(/\\r/, \"\"); printf \"%s\\\\n\",$0;}' certificate.pem | pbcopy\n```\n\nThis copies the value into to your clipboard buffer so you can paste it where needed.\n\n### More information\n\nWhen working with certificates or keys in rules or Management API v2 requests, you will most likely require a string representation of the file.\n\nIf you open a certificate file (`cer`, `pem`) with a text editor, you'll see something like this:\n\n```\n-----BEGIN CERTIFICATE-----\nMIICzDCCAbQCCQDH8GvxPIeH+DANBgkqhkiG9w0BAQsFADAoMQswCQYDVQQGEwJh\ncjEZMBcGA1UEAwwQaHR0cHM6Ly9uaWNvLmNvbTAeFw0xOTA0MDgxODA3NTVaFw0y\n//\n// more lines of base64-encoded information\n//\nnSWyabd+LiBGtLTMB+ZLbOIi3EioWPGw/nHOI8jzPrqhiCLuZCSQmiqrLQYNsc1W\n-----END CERTIFICATE-----\n```\n\nThe lines between the `-----BEGIN CERTIFICATE-----` header and `-----END CERTIFICATE-----` footer contain base64-encoded binary information. Public keys and private keys (.key files) will look similar, with just a different header/footer.\n\nFor a string representation of a certificate/key file, you will need to concatenate everything in one line, with a `\\n` (escaped new-line) sequence replacing the actual new lines in the file. So from the above sample you'd obtain something like this:\n\n```\n\"-----BEGIN CERTIFICATE-----\n\\nMIICzDCCAbQCCQDH8GvxPIeH+DANBgkqhkiG9w0BAQsFADAoMQswCQYDVQQGEwJh\\n\n[..all the other lines..]\n-----END CERTIFICATE-----\\n\"\n```\n\n## Learn more\n\n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)",
    "title": "Work with Certificates and Keys as Strings",
    "description": "Describes how to work with certificates or keys in rules or Management API requests to require a string representation of the file.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-16897",
    "markdown": "# CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library\n\n**Published**: December 22, 2017\n\n**CVE number**: CVE-2017-16897\n\n**Credit**: Alan Bishop\n\n## Overview\n\nA vulnerability has been discovered in the [passport-wsfed-saml2 library](https://github.com/auth0/passport-wsfed-saml2) affecting versions < `3.0.5`. **passport-wsfed-saml2** is a WS-Federation protocol and SAML2 tokens authentication provider for [Passport.js](http://passportjs.org/).\n\nThis vulnerability allows an attacker to impersonate another user and potentially elevate their privileges if the SAML identity provider does not sign the full SAML response, but instead only signs the assertion within the response.\n\nAn attacker who successfully exploits this vulnerability could use that response to craft a request with a different **NameIdentifier** in order to log in as a different user. A malicious actor could also perform a privilege escalation attack if authenticating as a specific user with administrative privileges. The attacker must have an existing account, or be able to intercept the encrypted traffic and modify the SAML response on the fly.\n\nThis update addresses the vulnerability by avoiding wrapping attacks for **Assertion** and **Response** elements, as well as providing some defensive changes in XPath expressions. An update has also been implemented to improve the method of logging information about the signing of the SAML response.\n\nPatching this vulnerability requires a library upgrade.\n\n## Am I affected?\n\nThis vulnerability affected cloud tenants utilizing the **SAMLP Identity Provider Connection** wherein the identity provider either:\n\n*   signed SAML response and signed assertion\n    \n*   did not sign SAML response and signed assertion\n    \n\nNo action is required for Auth0 cloud tenants.\n\nThe vulnerability scope also extended to those using the [passport-wsfed-saml2 strategy with passport.js](https://github.com/auth0/passport-wsfed-saml2), which requires a library upgrade (see the next section).\n\n## How to fix that?\n\nDevelopers using the **passport-wsfed-saml2** library need to upgrade to the latest version: `3.0.5`.\n\nUpdated packages are available on npm. To ensure delivery of additional bug fixes moving forward, please make sure your `package.json` file is updated to take patch and minor level updates of our libraries.\n\n```\n{\n  \"dependencies\": {\n    \"passport-wsfed-saml2\": \"^3.0.5\"\n  }\n}\n```\n\n### Will this update impact my users?\n\nNo. This fix patches the library that your application runs, but will not impact your users, their current state, or any existing sessions.",
    "title": "CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library",
    "description": "CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport strategy library",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server",
    "markdown": "# Configure GitHub Enterprise Server as SAML Service Provider\n\nYou can configure Auth0 as the identity provider using the SAML2 Web App addon for [GitHub Enterprise Server](https://help.github.com/en/enterprise/2.16/admin/user-management/using-saml) (i.e. your private GitHub appliance). If you are looking for instructions to set up Auth0 as the identity provider for GitHub Enterprise Cloud (github.com), read [Configure Auth0 as Identity Provider for GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud) instead.\n\n## Configure SAML SSO on Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and create a new application. Give it a meaningful name like **GitHub**. You can choose any application type, but the **Regular Web App** type is recommended.\n    \n2.  Go to the [Addons](https://manage.auth0.com/#/applications/{yourClientId}/addons) tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to : `https://github.com/orgs/{yourGitHubOrgName}/saml/consume`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"{yourGitHubServerUrl}\",\n          \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"email\": \"emails\",\n        \"name\": \"full_name\"\n          },\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n          ]\n        }\n    ```\n    \n    Replace `{yourGitHubOrgName}` with the GitHub organization name that corresponds to your GitHub subscription. For example `https://github.yourname.com`.\n    1.  The above mapping will send the `user_id` as the **Name Identifier** to GitHub. Use this option if you enable more than one connection for the GitHub application, as it will ensure uniqueness (every user will have a different ID).\n        \n    2.  If you are using a single connection, you might prefer to use the `nickname` or another unique identifier as a friendlier **Name Identifier**, but make sure that the property you choose is unique.\n        \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Configure SAML SSO on GitHub\n\nFollow the instructions in [Using SAML on Enterprise Server- GitHub Help](https://help.github.com/en/enterprise/admin/user-management/using-saml#configuring-saml-settings) to complete the configuration on GitHub Enterprise Cloud. You will need the following information:\n\n| **Field** | **Entry** |\n| --- | --- |\n| **Sign On URL** | `https://{yourDomain}/samlp/{CLIENT_ID}`  <br>`{CLIENT_ID}` will be the `client_id` for the GitHub application you just created in Auth0. |\n| **Issuer** | `urn:auth0:{yourTenant}` |\n| **Verification Certificate** | Download it from `https://{yourDomain}/pem`. Open the downloaded file with a text editor, copy the contents and paste it in the text area on GitHub. |\n| **User Attributes** | Leave the defaults here, as the mapping that we configured in the SAML Web App addon uses the default attribute names proposed by GitHub. |\n| **Signature method** | `RSA256-SHA256` |\n| **Digest method** | `SHA256` |",
    "title": "Configure GitHub Enterprise Server as SAML Service Provider",
    "description": "Learn how to configure Auth0 as the identity provider using the SAML2 Web App addon for a GitHub Enterprise Server private instance.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login",
    "markdown": "# Configure Universal Login with Passwordless\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nUniversal Login is Auth0's implementation of the authentication flow, which is the key feature of an Authorization Server. Each time a user needs to prove their identity, your applications redirect to Universal Login and Auth0 guarantees the user's identity. You can choose to enable Passwordless authentication when you configure Universal Login in the Auth0 Dashboard.\n\nFirst, determine if you want users to use SMS, email, or WebAuthn for device biometrics as the Passwordless authentication method. It is not currently possible to support all three authentication methods in a single login flow.\n\n## Passwordless with email or SMS\n\nYou can configure Auth0 so users can authenticate with a magic link or one-time password (OTP) sent to their email, or an OTP sent to their phone number. To learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## Passwordless with WebAuthn with device biometrics\n\nWhen using WebAuthn with Device Biometrics, users will be able to authenticate with their password, or with any of their devices that support WebAuthn with Device Biometrics.\n\nEach time they login from a new device, Auth0 will offer them the option to use biometrics instead of a password. To learn more, read [Passwordless with WebAuthn with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n\n![Example of setting up a Face ID login for specific domain using WebAuthn](https://images.ctfassets.net/cdy7uua7fh8z/1JfsIYEo3O7xmTAxLRwNSs/2f2ba478ff32b0aa86f4f01cd6c0cf3b/2023-01-31_16-34-09.png)\n\n## Learn more\n\n*   [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms)\n*   [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)",
    "title": "Configure Universal Login with Passwordless",
    "description": "Learn how to configure your login page to use passwordless authentication using the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests",
    "markdown": "# Sign and Encrypt SAML Requests\n\nTo increase the security of your transactions, you can sign or encrypt both your requests and your responses in the SAML protocol. In this article, you'll find configurations for specific scenarios, separated under two use cases:\n\n*   Auth0 as the SAML service provider (for example, a SAML connection)\n    \n*   Auth0 as the SAML identity provider (for example, an application configured with the SAML Web App addon)\n    \n\n## Auth0 as the SAML service provider\n\nThese scenarios apply when Auth0 is the SAML Service Provider, which means that Auth0 connects to a SAML identity provider by creating a SAML connection.\n\n### Sign the SAML authentication request\n\nIf Auth0 is the SAML **service provider**, you can sign the authentication request Auth0 sends to the IdP as follows:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select **SAML**.\n    \n2.  Select the name of the connection to view.\n    \n3.  Locate **Sign Request**, and enable its switch.\n    \n4.  Download the certificate beneath the **Sign Request** switch, and provide it to the IdP so that it can validate the signature.\n    \n\n#### Enable/disable deflate encoding\n\nBy default, SAML authentication requests are sent via HTTP-Redirect and use deflate encoding, which puts the signature in a query parameter.\n\nTo turn off deflate encoding, you can make a [PATCH call to the Management API's Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) and set the `deflate` option to `false`.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"deflate\": false\n\t}\n}\n```\n\n### Use a custom key to sign requests\n\nBy default, Auth0 uses the tenant private key to sign SAML requests (when the **Sign Request** toggle is enabled). You can also provide your own private/public key pair to sign requests coming from a specific connection.\n\nYou can generate your own certificate and private key using this command:\n\n```\nopenssl req -x509 -nodes -sha256 -days 3650 -newkey rsa:2048 -keyout private_key.key -out certificate.crt\n```\n\nChanging the key used to sign requests in the connection can't be done on the Dashboard UI, so you will have to use the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) from the Management API v2, and add a `signing_key` property to the `options` object, as shown in the payload example below.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"signing_key\": {\n\t\t\t\t\"key\":\"-----BEGIN PRIVATE KEY-----\\n...{your private key here}...\\n-----END PRIVATE KEY-----\",\n\t\t\t\t\"cert\":\"-----BEGIN CERTIFICATE-----\\n...{your public key cert here}...\\n-----END CERTIFICATE-----\"\n\t\t\t}\n    }\n\t}\n}\n```\n\nTo learn how to get the private key and certificate formatted as a JSON string to use in the payload, see [Work with Certificates and Keys and Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings).\n\n### Receive signed SAML authentication responses\n\nIf Auth0 is the SAML **service provider**, all SAML responses from your identity provider should be signed to indicate it hasn't been tampered with by an unauthorized third-party.\n\nYou will need to configure Auth0 to validate the responses' signatures by obtaining a signing certificate form the identity provider and loading the certificate from the identity provider into your Auth0 Connection:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select **SAML**.\n    \n2.  Select the name of the connection to view.\n    \n3.  Locate **X509 Signing Certificate**, and upload the certificate.\n    \n4.  Select **Save Changes**.\n    \n\nAuth0 can accept a signed response for the assertion, the response, or both.\n\n### Receive encrypted SAML authentication assertions\n\nIf Auth0 is the SAML service provider, it may need to receive encrypted assertions from an identity provider. To do this, you must provide the tenant's public key certificate to the IdP. The IdP encrypts the SAML assertion using the public key and sends it to Auth0, which decrypts it using the tenant's private key.\n\nUse the following links to obtain the public key in different formats:\n\n*   [CER](https://your_auth0_domain/cer?cert=connection)\n    \n*   [PEM](https://your_auth0_domain/pem?cert=connection)\n    \n*   [raw PEM](https://your_auth0_domain/rawpem?cert=connection)\n    \n*   [PKCS#7](https://your_auth0_domain/pb7?cert=connection)\n    \n*   [Fingerprint](https://your_auth0_domain/fingerprint?cert=connection)\n    \n\nDownload the certificate in the format requested by the IdP.\n\n### Use your key pair to decrypt encrypted responses\n\nAs noted above, Auth0 will by default use your tenant's private/public key pair to handle encryption. You can also provide your own public/private key pair if an advanced scenario requires so.\n\nChanging the key pair used to encrypt and decrypt requests in the connection can't be done on the Dashboard UI, so you will have to use the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) from the Management API v2, and add a `decryptionKey` property to the `options` object, as shown in the payload example below.\n\nUpdating the `options` object for a connection overrides the whole `options` object. To keep previous connection options, get the existing `options` object and add new key/values to it.\n\nEndpoint: `https://{yourDomain}/api/v2/connections/{yourConnectionId}`\n\nPayload:\n\n```\n{\n\t{ \n\t\t\"options\" : {\n\t\t\t[...], // all the other connection options\n\t\t  \"decryptionKey\": {\n\t\t\t\t\"key\":\"-----BEGIN PRIVATE KEY-----\\n...{your private key here}...\\n-----END PRIVATE KEY-----\",\n\t\t\t\t\"cert\":\"-----BEGIN CERTIFICATE-----\\n...{your public key cert here}...\\n-----END CERTIFICATE-----\"\n\t\t\t}\n\t}\n}\n```\n\nThe SAML metadata available for the connection will be updated with the provided certificate so that the identity provider can pick it up to sign the SAML response.\n\n## Auth0 as the SAML identity provider\n\nThis scenario applies when Auth0 is the SAML identity provider for an application. This is represented in the Dashboard by an **Application** that has the SAML Web App Addon enabled.\n\n### Sign the SAML responses/assertions\n\nIf Auth0 is the SAML identity provider, it will sign SAML assertions with the tenant's private key and provide the service provider with the public key/certificate necessary to validate the signature.\n\nTo sign the SAML assertions:\n\n1.  Go to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n2.  Scroll to the bottom of the **Settings** page, select **Show Advanced Settings**, and select the **Certificates** view.\n    \n3.  Select **Download Certificate**, and select the format in which you'd like to receive your signing certificate.\n    \n4.  Send your certificate to the service provider.\n    \n\nBy default, Auth0 signs the SAML **assertion** within the response. To sign the SAML **response** instead:\n\n1.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n2.  Select the **Addons** view.\n    \n3.  Select **SAML2 Web App** to view its settings, and locate the **Settings** code block.\n    \n4.  Locate the **\"****`signResponse\"`** key. Uncomment it (or add it, if required), then set its value to `true` (the default value is `false`). The configuration should look like this:\n    \n    ```\n    {\n      [...], // other settings\n      \"signResponse\": true\n    }\n    ```\n    \n\n#### Change the signing key for SAML responses\n\nBy default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own key pair. You can do so with a rule like this:\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n\n    // replace with the ID of the application that has the SAML Web App Addon enabled\n      // for which you want to change the signing key pair.\n      const samlIdpClientId = 'YOUR_SAML_APP_CLIENT_ID';\n\n    // only do this for the specific client ID.  If you have multiple IdPs that require \n    // custom certificates, you will have an \"if\" statement for each one.  \n    if (event.client.client_id === samlIdpClientId) {\n\n    // provide your own private key and certificate here  \n    // see https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings \n    // for formatting instructions basically you start with a PEM format certificate and\n    // replace the line enedings with \"\\n\"\n    const signingCert = \"-----BEGIN CERTIFICATE-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV[..all the other lines..]-----END CERTIFICATE-----\\n\";\n    const signingKey = \"-----BEGIN PRIVATE KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV[..all the other lines..]-----END PRIVATE KEY-----\\n\";\n\n    api.samlResponse.setCert(signingCert)    \n    api.samlResponse.setKey(signingKey);\n\n  }\n  };\n```\n\nTo learn how to turn the private key and certificate files into strings that you can use in a rule, see [Work with Certificates and Keys and Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings).\n\n### Receive signed SAML authentication requests\n\nIf Auth0 is the SAML identity provider, it can receive requests signed with the service provider's private key. Auth0 uses the public key/certificate to validate the signature.\n\nTo configure signature validation:\n\n1.  Download the service provider's certificate with the public key.\n    \n2.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n3.  Select the **Addons** view.\n    \n4.  Select **SAML2 Web App** to view its settings, and locate the **Settings** code block.\n    \n5.  Locate the **\"****`signingCert\"`** key. Uncomment it (or add it, if required), then set its value to the certificate you downloaded from the service provider. The configuration should look like this:\n    \n    ```\n    {\n      [...], // other settings\n      \"signingCert\": \"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"\n    }\n    ```\n    \n\n### Send encrypted SAML authentication assertions\n\nIf Auth0 is the SAML identity provider, you can use rules to encrypt the SAML assertions it sends.\n\nYou must obtain the certificate and the public key from the service provider. If you only got the certificate, you can derive the public key using `openssl`. Assuming that the certificate file is named `certificate.pem`, you can run:\n\n`openssl x509 -in certificate.pem -pubkey -noout > public_key.pem`\n\nOnce you get the certificate and public key files, you must [turn them into strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings) to use them in a rule. The rule will look like this:\n\n```\nfunction (user, context, callback) {\n  // this rule sets a specific public key to encrypt the SAML assertion generated from Auth0 \n  if (context.clientID === 'THE_CLIENT_ID_OF_THE_APP_WITH_THE_SAML_APP_ADDON') {\n\t  context.samlConfiguration = (context.samlConfiguration || {});\n    context.samlConfiguration.encryptionPublicKey = \"-----BEGIN PUBLIC KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END PUBLIC KEY-----\\n\";\n    context.samlConfiguration.encryptionCert = \"-----BEGIN CERTIFICATE-----\\nnnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\";\n\t}\n  callback(null, user, context);\n}\n```\n\nThe following algorithms are used:\n\n*   [AES256](http://www.w3.org/2001/04/xmlenc#aes256-cbc) for assertion encryption\n    \n*   [RSA-OAEP](http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p) (including MGF1 and SHA1) for key transport\n    \n\n## Learn more\n\n*   [Work with Certificates and Keys as Strings](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/work-with-certificates-and-keys-as-strings)",
    "title": "Sign and Encrypt SAML Requests",
    "description": "Describes the special configuration scenario to sign and encrypt SAML requests",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/prompts/patch-prompts",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages",
    "markdown": "# Default Auth0 Error Page\n\nIf your callback URL is valid, when an authorization error occurs, the Authorization Server returns the appropriate error and state parameters to your callback URL. In cases where your callback URL is invalid, your application will display the default generic Auth0 error page. Alternatively, you can customize the error pages. To learn more, read [](https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages)[Custom Error Pages](https://auth0.com/docs/customize/login-pages/custom-error-pages).\n\nTo find the default page name for the generic error page, see [Use Version Control to Manage Your Universal Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/version-control).\n\n## Display\n\nThe generic error page displays the following information if you have configured the associated fields in your [Tenant Settings](https://manage.auth0.com/#/tenant/).\n\n| Field | Description |\n| --- | --- |\n| Friendly Name | Name of your company |\n| Logo URL | URL of your company logo |\n| Support Email | Email address of your company's support team |\n| Support URL | URL of your company's support page |\n\n## Parameters\n\nThe Authorization Server returns parameters appended to the URL as a query string.\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `client_id` | Identifier of the Auth0 application. |\n| `connection` | Connection used at the time of error. |\n| `lang` | Language set for use at the time of error. |\n| `error` | Error code of the error. |\n| `error_description` | Description of the error. |\n| `tracking` | Identifier used by Auth0 to find errors in internal logs. |\n\nParameters presented vary depending on the error type and are specific to the request. For example, if the request did not contain a `client_id` and resulted in an error, no client ID will be returned by the error page.\n\n## Learn more\n\n*   [Customize Error Pages](https://auth0.com/docs/customize/login-pages/custom-error-pages)\n*   [Brand: Emails and Error Pages](https://auth0.com/docs/videos/get-started-series/brand-emails-and-error-pages)",
    "title": "Default Auth0 Error Page",
    "description": "Describes the default Auth0 error page display information and parameters used for authorization error events.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens",
    "markdown": "# Validate JSON Web Tokens\n\nAuth0 uses JSON Web Token (JWT) for secure data transmission, authentication, and authorization. Tokens should be parsed and validated in regular web, native, and single-page applications to make sure the token isn’t compromised and the signature is authentic. Tokens should be verified to decrease security risks if the token has been, for example, tampered with, misused, or has expired. JWT validation checks the structure, claims, and signature to assure the least amount of risk.\n\nThe JWT token signature is generated using a Signing Algorithm. While tokens can use multiple signing algorithms, Auth0 supports RS256, RSA encryption with SHA-256 hash function or HS256, HMAC message authentication code (MAC) with SHA-256. To learn more about Auth0’s recommended algorithm, read [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\nWhen validating a JWT, generally, the current hash value and the original hash value are parsed, or decoded, then compared to verify the token signature is authentic. All of our [backend API quickstarts](https://auth0.com/docs/quickstart/backend) use SDKs that perform JWT validation and parsing for you.\n\n## Parse and validate\n\nIf you are not using one of our SDKs that perform JWT validation and parsing for you, you can parse and validate a JWT by:\n\n*   Using any existing middleware for your web framework.\n    \n*   Choosing a third-party library from JWT.io.\n    \n*   Manually implementing the checks described in [specification RFC 7519 > 7.2 Validating a JWT](https://tools.ietf.org/html/rfc7519#section-7.2).\n    \n\nWe strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.\n\n## Middleware\n\nMany web frameworks, such as [ASP.NET Core](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi), include JWT middleware that handles JWT validation. Typically, this is the best route to take because the middleware integrates well with the framework's overall authentication mechanisms.\n\n## Third-party libraries\n\nIf you choose a third-party library, choose a library that supports the signing algorithm you selected when you registered your application or API with Auth0. Also, be aware that not all libraries validate all JWT claims. At JWT.io, you can see which validations each library supports (look for the green check marks).\n\nMost third-party libraries implement one method to verify a JWT and build in various arguments to allow you to customize the verification. For example, if you are using Node.js and the [node-jsonwebtoken library](https://github.com/auth0/node-jsonwebtoken), then you would call the [jwt.verify()](https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback) method. This method supports an `algorithms` argument to allow you to customize your allowed algorithms (make sure you disallow `none`), a `secretOrPublicKey` argument that you populate with either the secret or the RSA public key (depending on selected signing algorithm), and other input arguments that allow you to customize claim validation. If parsing fails, then the library returns a [JsonWebTokenError error](https://github.com/auth0/node-jsonwebtoken#jsonwebtokenerror) with the message `jwt malformed`, after which you **must** reject the associated request.\n\nGeneral recommendations for using third-party libraries: \n\n*   For obtaining claims from JWT, use the `verify()` method to validate the claims and the signature. Avoid using the `decode()` method to validate a token, especially if it's coming from a public client.\n    \n*   Carefully follow all instructions on how to use the chosen library. The library could rely on default values or settings that could create security risks.\n    \n\n## Manually implement checks\n\nWe discourage doing manual JWT validation since it might be easy to improperly implement and miss some important details that will lead to serious security vulnerabilities. Most JWT libraries take care of JWT validation for you. Visit JWT.io to find a JWT library for your platform and programming language.\n\nFor instructions on how to manually validate a JWT, see [RFC 7519](https://tools.ietf.org/html/rfc7519#section-7.2). All Auth0-issued JWTs have a JSON Web Signature (JWS), meaning they are signed rather than encrypted.\n\n## Verify RS256-signed tokens\n\nTo visually verify RS256-signed tokens:\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Go to the **Settings** view, and open **Advanced Settings**.\n    \n3.  Go to the **Certificates** view, locate the **Signed Certificate** field, and copy the **Public Key**.\n    \n4.  Navigate to the [JWT.io](https://jwt.io/) website, locate the **Algorithm** dropdown, and select **RS256**.\n    \n5.  Locate the **Verify Signature** section, and paste the Public Key you previously copied in place of the content in the field that begins with `-----BEGIN PUBLIC KEY-----`.\n    \n\nTo verify the signature of a token from one of your applications:\n\nWe recommend that you get the Public Key from your tenant's JWKS here: `https://{yourDomain}/.well-known/jwks.json`\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Validate JSON Web Tokens",
    "description": "Describes how to parse and validate a JSON web token (JWT).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets",
    "markdown": "# JSON Web Key Sets\n\nThe JSON Web Key Set (JWKS) is a set of keys containing the public keys used to verify any JSON Web Token (JWT) issued by the Authorization Server and signed using the RS256 [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\nWhen creating applications and APIs in Auth0, two algorithms are supported for signing JWTs: **RS256** and **HS256**. RS256 generates an asymmetric signature, which means a private key must be used to sign the JWT and a different public key must be used to verify the signature.\n\nAuth0 uses the [JSON Web Key (JWK) specification](https://tools.ietf.org/html/rfc7517) to represent the cryptographic keys used for signing RS256 tokens. This specification defines two high-level data structures: **JSON Web Key (JWK)** and **JSON Web Key Set (JWKS)**. Here are the definitions from the specification:\n\n| Item | Description |\n| --- | --- |\n| **JSON Web Key (JWK)** | A JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. |\n| **JSON Web Key Set (JWKS)** | A JSON object that represents a set of JWKs. The JSON object MUST have a `keys` member, which is an array of JWKs. |\n\nAuth0 exposes a JWKS endpoint for each tenant, which is found at `https://{yourDomain}/.well-known/jwks.json`. This endpoint will contain the JWK used to verify all Auth0-issued JWTs for this tenant.\n\n## Learn more\n\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [View Signing Certificates](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates)",
    "title": "JSON Web Key Sets",
    "description": "A JSON Web Key set is a JSON object which represents a set of JSON Web Keys (a JSON object that represents a cryptographic key).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties",
    "markdown": "# JSON Web Key Set Properties\n\nHere is an example of the JSON Web Key Set (JWKS) used by a sample tenant, containing a single JSON Web Key (JWK):\n\n```\n{\n\"keys\": [\n  {\n    \"alg\": \"RS256\",\n    \"kty\": \"RSA\",\n    \"use\": \"sig\",\n    \"x5c\": [\n      \"MIIC+DCCAeCgAwIBAgIJBIGjYW6hFpn2MA0GCSqGSIb3DQEBBQUAMCMxITAfBgNVBAMTGGN1c3RvbWVyLWRlbW9zLmF1dGgwLmNvbTAeFw0xNjExMjIyMjIyMDVaFw0zMDA4MDEyMjIyMDVaMCMxITAfBgNVBAMTGGN1c3RvbWVyLWRlbW9zLmF1dGgwLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMnjZc5bm/eGIHq09N9HKHahM7Y31P0ul+A2wwP4lSpIwFrWHzxw88/7Dwk9QMc+orGXX95R6av4GF+Es/nG3uK45ooMVMa/hYCh0Mtx3gnSuoTavQEkLzCvSwTqVwzZ+5noukWVqJuMKNwjL77GNcPLY7Xy2/skMCT5bR8UoWaufooQvYq6SyPcRAU4BtdquZRiBT4U5f+4pwNTxSvey7ki50yc1tG49Per/0zA4O6Tlpv8x7Red6m1bCNHt7+Z5nSl3RX/QYyAEUX1a28VcYmR41Osy+o2OUCXYdUAphDaHo4/8rbKTJhlu8jEcc1KoMXAKjgaVZtG/v5ltx6AXY0CAwEAAaMvMC0wDAYDVR0TBAUwAwEB/zAdBgNVHQ4EFgQUQxFG602h1cG+pnyvJoy9pGJJoCswDQYJKoZIhvcNAQEFBQADggEBAGvtCbzGNBUJPLICth3mLsX0Z4z8T8iu4tyoiuAshP/Ry/ZBnFnXmhD8vwgMZ2lTgUWwlrvlgN+fAtYKnwFO2G3BOCFw96Nm8So9sjTda9CCZ3dhoH57F/hVMBB0K6xhklAc0b5ZxUpCIN92v/w+xZoz1XQBHe8ZbRHaP1HpRM4M7DJk2G5cgUCyu3UBvYS41sHvzrxQ3z7vIePRA4WF4bEkfX12gvny0RsPkrbVMXX1Rj9t6V7QXrbPYBAO+43JvDGYawxYVvLhz+BJ45x50GFQmHszfY3BR9TPK8xmMmQwtIvLu1PMttNCs7niCYkSiUv2sc2mlq1i3IashGkkgmo=\"\n    ],\n    \"n\": \"yeNlzlub94YgerT030codqEztjfU_S6X4DbDA_iVKkjAWtYfPHDzz_sPCT1Axz6isZdf3lHpq_gYX4Sz-cbe4rjmigxUxr-FgKHQy3HeCdK6hNq9ASQvMK9LBOpXDNn7mei6RZWom4wo3CMvvsY1w8tjtfLb-yQwJPltHxShZq5-ihC9irpLI9xEBTgG12q5lGIFPhTl_7inA1PFK97LuSLnTJzW0bj096v_TMDg7pOWm_zHtF53qbVsI0e3v5nmdKXdFf9BjIARRfVrbxVxiZHjU6zL6jY5QJdh1QCmENoejj_ytspMmGW7yMRxzUqgxcAqOBpVm0b-_mW3HoBdjQ\",\n    \"e\": \"AQAB\",\n    \"kid\": \"NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg\",\n    \"x5t\": \"NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg\"\n  }\n]}\n```\n\nEach property in the key is defined by the JWK specification [RFC 7517 Section 4](https://tools.ietf.org/html/rfc7517#section-4) or, for algorithm-specific properties, in [RFC 7518](https://tools.ietf.org/html/rfc7518)\\].\n\n| Property name | Description |\n| --- | --- |\n| `alg` | The specific cryptographic algorithm used with the key. This is an optional parameter. By default, Auth0 includes the signing algorithm defined at the tenant level in the JSON Web Key Set (JWKS), which is then published. To allow for keys to be used with multiple algorithms rather than a single algorithm i.e. RS256, toggle off **Include Signing Algorithms in JSON Web Key Set** under Advanced Tenant settings in Dashboard. This removes the `alg` parameter and requires consumers of the JWKS to interpret the signing algorithms as needed. |\n| `kty` | The family of cryptographic algorithms used with the key. |\n| `use` | How the key was meant to be used; `sig` represents the signature. |\n| `x5c` | The x.509 certificate chain. The first entry in the array is the certificate to use for token verification; the other certificates can be used to verify this first certificate. |\n| `n` | The modulus for the [RSA public key](https://tools.ietf.org/html/rfc7518#page-30). |\n| `e` | The exponent for the [RSA public key](https://tools.ietf.org/html/rfc7518#page-30). |\n| `kid` | The unique identifier for the key. |\n| `x5t` | The thumbprint of the x.509 cert (SHA-1 thumbprint). |\n\nFor an example that uses JWKS to verify a JWT's signature, see [Navigating RS256 and JWKS](https://auth0.com/blog/navigating-rs256-and-jwks/) (uses Node.js), or check out our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend).\n\n## Learn more\n\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)",
    "title": "JSON Web Key Set Properties",
    "description": "Describes the properties available in a JSON Web Key Set (JWKS).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members",
    "markdown": "# Invite Organization Members\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you would like to assign a member to an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), but the user does not yet exist in your data store (or the user exists in your data store but is not yet a member of your organization), you can invite them to the organization. In this case, the user will receive an email containing a link that will allow them to create an account or log in and join the organization, optionally with predefined roles, and be redirected to your application so that they can immediately start using it.\n\nTo configure the invitation flow:\n\n1.  [Integrate the membership invitation flow into your application](#integrate-the-membership-invitation-flow-into-your-application)\n    \n2.  [Customize the user invitation flow](#customize-the-user-invitation-flow)\n    \n3.  [Send membership invitations](#send-membership-invitations)\n    \n\n## Integrate the membership invitation flow into your application\n\nFor user invitations to work, you must set up a route in your application as part of the invitation acceptance flow and [configure an associated default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) for your tenant or application. A link to the configured URI will be included in the email invitation that is sent to users.\n\n### Configure the URI\n\nIf the URI should be shared across all of your applications, you can set the **Tenant Login URL** at [Auth0 Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Otherwise, you can set the URI on a per-application basis by using **Application Login URI** in your application's settings, which you can reach from [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n\n### Specify route behavior\n\nThe route in your application must accept the `invitation` and `organization` parameters in the query string, and then call the Auth0 Authentication API [Authorization](https://auth0.com/docs/api/authentication#authorize-application) endpoint with both parameters.\n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link in the email invitation sent to the end user would be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\n## Customize the user invitation flow\n\nTo customize the user invitation prompt and email that the user receives, modify the Universal Login prompt and email templates. To learn more, read these pages:\n\n*   [Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates)\n    \n*   [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization)\n    \n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n    \n\n### Localization\n\nSince the locale of the invited user is not known ahead of time, you can send an optional `user_metadata` parameter to the invitation endpoint using the Management API. When localizing the user invitation flow, you can access this parameter through the **User Invitation** email template and [use the same logic as you would with other multilingual email templates](https://auth0.com/docs/customize/email/email-templates).\n\nFor the invited user to see the invitation in the appropriate language, your application will need to send the `ui_locales` parameter or the invited user's browser must send the appropriate `Accept-Language` header. To learn more, read [Customize Email Templates: Multilingual Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n## Send membership invitations\n\nYou can [send organization membership invitations](https://auth0.com/docs/manage-users/organizations/configure-organizations/send-membership-invitations) to users using either the Auth0 Dashboard or the Management API. If you prefer to send the invitation using your own email service, you can choose to only generate an invitation URL. Otherwise, the user will receive an email containing the link, which will allow them to log in to the organization using a configured connection.",
    "title": "Invite Organization Members",
    "description": "Learn how to invite members to organizations via email.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets",
    "markdown": "# Locate JSON Web Key Sets\n\nUse this Discovery endpoint to configure your application or API to automatically locate the [JSON Web Key Set (JWKS)](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) endpoint (`jwks_uri`), which contains the JWKS used to sign all Auth0-issued JSON Web Tokens (JWTs) signed with the RS256 signing algorithm. The endpoint exists at:\n\n`https://{yourDomain}/.well-known/openid-configuration`.\n\nWhen [validating a JWT](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) using a JWKS, you will need to:\n\n1.  Retrieve the JWKS from the Auth0 Discovery endpoint, and filter for potential signing keys (e.g., any keys missing a public key or with a `kid` property).\n    \n2.  Grab the `kid` property from the Header of the decoded JWT.\n    \n3.  Search your filtered JWKS for the key with the matching `kid` property.\n    \n4.  Build a certificate using the corresponding `x5c` property in your JWKS.\n    \n5.  Use the certificate to verify the JWT's signature.\n    \n\nFor an example that uses JWKS to verify a JWT's signature, see [Navigating RS256 and JWKS](https://auth0.com/blog/navigating-rs256-and-jwks/) (uses Node.js), or check out our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend).\n\nFor more info about the structure of a JWT, see [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n\nIt's good practice to assume that multiple signing keys could be present in your JWKS. This may seem unnecessary since the Auth0 JWKS endpoint typically contains a single signing key; however, multiple keys can be found in the JWKS when rotating signing certificates.\n\nWe recommend that you cache your signing keys to improve application performance and avoid running into [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy), but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.\n\n## Learn more\n\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Locate JSON Web Key Sets",
    "description": "Describes how to use the JSON Web Keys (JWKs) discovered using the JSON Web Key Set (JWKS) endpoint to verify a JWT signature.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/email-templates/use-liquid-syntax-in-email-templates",
    "markdown": "# Use Liquid Syntax in Email Templates\n\nWhen using the [Email Templates](https://manage.auth0.com/#/branding/email_templates) available on the Auth0 dashboard, you have the option of using the Liquid template language to select the appropriate data and formatting your emails. Liquid is an open-source templating language that extends the functionality of HTML that you can use to dynamically generate your emails to contain varying information. To learn more, read [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) on Github.\n\nUsing Liquid, you can structure the `Subject` of your emails to display the appropriate application name, rather than hardcoding a particular value:\n\n`We are {{application.name}}!`\n\nHTML with Liquid syntax is supported in every field (except `URL Lifetime`) on the Verification, Change Password Confirmation, and Blocked Account email templates. For more information on supported output attributes and their usage, see [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nThere are two types of markup in Liquid: output and tag.\n\n### Output markup\n\n**Output** markup resolves to text and is surrounded by two pairs of matching curly braces:\n\n`Hello {{ name }}!`\n\nYou can further customize the appearance of the output by using filters, which are simple methods. For example, the `upcase` filter will convert the text which is passed to the filter to uppercase:\n\n`Hello {{ name | upcase }}!`\n\nMultiple filters are separated by `|` and are processed from left to right, applying the subsequent filter to the result of the previous one. The template will render the final result.\n\nThe following filters are supported:\n\n| Filter | Description | Example |\n| --- | --- | --- |\n| `append` | Append a string | `{{ 'foo' \\| append:'bar' }} #=> 'foobar'` |\n| `capitalize` | Capitalize words in the input sentence | `{{ \"my great title\" \\| capitalize }} #=> My great title` |\n| `date` | Reformat a date ([syntax reference](http://docs.shopify.com/themes/liquid-documentation/filters/additional-filters#date)) |     |\n| `default` | Returns the given variable unless it is null or the empty string, when it will return the given value | `{{ undefined_variable \\| default: \"Default value\" }} #=> \"Default value\"` |\n| `divided_by` | Integer division | `{{ 10 \\| divided_by:3 }} #=> 3` |\n| `downcase` | Convert an input string to lowercase, | `{{ \"Parker Moore\" \\| downcase }} #=> parker moore` |\n| `escape` | HTML escape a string | `{{ \"Have you read 'James & the Giant Peach'?\" \\| escape }} #=> Have you read &#39;James &amp; the Giant Peach&#39;?` |\n| `escape_once` | Returns an escaped version of HTML without affecting existing escaped entities | `{{ \"1 < 2 &amp; 3\" \\| escape_once }} #=> 1 &lt; 2 &amp; 3` |\n| `first` | Get the first element of the passed in array |     |\n| `join` | Join elements of the array with certain character between them |     |\n| `last` | Get the last element of the passed in array |     |\n| `map` | Map/collect an array on a given property |     |\n| `minus` | Subtraction | `{{ 4 \\| minus:2 }} #=> 2` |\n| `modulo` | Remainder | `{{ 3 \\| modulo:2 }} #=> 1` |\n| `newline_to_br` | Replace each newline (\\\\n) with HTML break |     |\n| `plus` | Addition | `{{ '1' \\| plus:'1' }} #=> 2`, `{{ 1 \\| plus:1 }} #=> 2` |\n| `prepend` | Prepend a string | `{{ 'bar' \\| prepend:'foo' }} #=> 'foobar'` |\n| `remove` | Remove each occurrence | `{{ 'foobarfoobar' \\| remove:'foo' }} #=> 'barbar'` |\n| `remove_first` | Remove the first occurrence | `{{ 'barbar' \\| remove_first:'bar' }} #=> 'bar'` |\n| `replace` | Replace each occurrence | `{{ 'foofoo' \\| replace:'foo','bar' }} #=> 'barbar'` |\n| `replace_first` | Replace the first occurrence | `{{ 'barbar' \\| replace_first:'bar','foo' }} #=> 'foobar'` |\n| `round` | Rounds input to the nearest integer or specified number of decimals | `{{ 4.5612 \\| round: 2 }} #=> 4.56` |\n| `size` | Return the size of an array or string | `{{ \"Ground control to Major Tom.\" \\| size }} #=> 28` |\n| `sort` | Sort elements of the array |     |\n| `split` | Split a string on a matching pattern | `{{ \"a~b\" \\| split:\"~\" }} #=> ['a','b']` |\n| `strip_html` | Strip HTML from string | `{{ \"How <em>are</em> you?\" \\| strip_html }} #=> How are you?` |\n| `strip_newlines` | Strip all newlines (\\\\n) from string |     |\n| `times` | Multiplication | `{{ 5 \\| times:4 }} #=> 20` |\n| `truncate` | Truncate a string down to x characters. It also accepts a second parameter that will append to the string | `{{ 'foobarfoobar' \\| truncate: 5, '.' }} #=> 'foob.'` |\n| `truncatewords` | Truncate a string down to x words |     |\n| `upcase` | Convert an input string to uppercase | `{{ \"Parker Moore\" \\| upcase }} #=> PARKER MOORE` |\n\n### Tag markup\n\n**Tag** markup does not resolve to text and is surrounded by a pair of matched curly braces and percent signs:\n\n`{% this does not resolve to text %}`\n\nTags are typically used to apply logic to your template. Using the Liquid [supported tags](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers#tags), you can have one template meet several needs.\n\nYou could use tags to execute `if / else` statements to have a single template send out emails in multiple languages.\n\nFor example:\n\n`{% if user.user_metadata.lang == 'en' %} [email body in English] {% elsif user.user_metadata.lang == 'de' %} [email body in German] {% endif %}`\n\nIf you need to use additional conditions, consider using a case statement. To learn more about case statements, see [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers#case-statement) on Github.\n\nAny content between `{% comment %}` and `{% endcomment %}` tags will not be rendered.\n\n`This will be seen. {% comment %} This will not be seen. {% endcomment %}`\n\n#### Tag raw\n\nTo temporarily disable processing of Liquid markup, use `{% raw %}` and `{% endraw %}`. This is useful if you are using syntax that conflicts with Liquid.\n\nFor example, you can escape the following `Mustache.js` line as follows:\n\n`{% raw %} var clients = \"Clients:<ul>{{#client}}<li>{{fn}} {{ln}}\" + {{phone}}</li>{{/client}}</ul>\"; {% endraw %}`\n\n## Debug variables\n\nTo assist your template development, we've added a custom `{% debug %}` liquid tag, which outputs a summary of the template variables available to your template when it was rendered. Remember to remove this tag from any \"live\" templates.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Email Template Descriptions](https://auth0.com/docs/customize/email/email-templates/email-template-descriptions)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
    "title": "Use Liquid Syntax in Email Templates",
    "description": "Describes how to use Liquid syntax in your email templates.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens",
    "markdown": "# Get ID Tokens\n\nTo get an ID token, you need to request them when authenticating users. Auth0 makes it easy for your app to authenticate users using:\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts): The easiest way to implement authentication, which can show you how to use [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), the Lock widget, and Auth0's language and framework-specific SDKs. Our [Lock documentation](https://auth0.com/docs/libraries/lock) and [Auth0.js documentation](https://auth0.com/docs/libraries/auth0js) provide specifics about retrieving an ID token after authentication.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to roll your own, you can call our API directly. First, you need to know [which flow to use](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) before following the appropriate flow tutorial.\n    \n\n## Control ID token contents\n\nYou control which claims about the authenticated user are included in the ID token consumed by your application by including specific [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) in the `scope` parameter when you request tokens while authenticating users.\n\nYou can also create [custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims), which are claims that you define, control, and add to a token using a rule. As with other JWTs, you should [validate an ID token](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens) before assuming that its contents can be trusted.\n\n## Renew ID tokens\n\nBy default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can [shorten the time period before the token expires](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime), but remember that one of the purposes of this token is to improve performance by caching user information.\n\nAfter an ID token has expired, you may want to renew your ID token. To renew the ID token, you can either re-authenticate the user using Auth0, or use a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Learn more\n\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Get ID Tokens",
    "description": "Describes how to request an ID token when authenticating users that includes claims about the user by including OIDC scopes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime",
    "markdown": "# Update ID Token Lifetime\n\nYou can change the ID token lifetime using the Auth0 Dashboard. By default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can shorten the time period before the token expires, keeping in mind that one of the purposes of the token is to improve user experience by caching user information.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of the application to view.\n    \n2.  Scroll to **ID Token** and locate the **ID Token Expiration** field. Enter the appropriate ID token lifetime (in seconds) for the application.\n    \n    ![Dashboard Applications Applications Settings Tab ID Token](https://images.ctfassets.net/cdy7uua7fh8z/26uUwvRKsPoVQVkztB3pyf/b8bb8aa28f4df0054ee7c69d3ae8da4e/dashboard-applications-applications-settings-id-token.png)\n3.  Click **Save Changes**.\n    \n\n## Learn more\n\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
    "title": "Update ID Token Lifetime",
    "description": "Describes how to update the ID token lifetime for an application using the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/email-templates/email-template-descriptions",
    "markdown": "# Email Template Descriptions\n\n## Verification emails\n\nIf you turn on the **Verification Email**, users who sign up on a database connection will receive a message asking to confirm their email address by clicking on a URL included in the message.\n\nIn addition to the common variables available for all email templates, the **Verification Email** provides the `url` variable that refers to the URL that the user will have to click. You will use it in the **Message** field to create a link that the user can follow.\n\n### Redirect To results for verification email template\n\nYou can configure a **Redirect To** URL to send the users to after the email verification action was attempted. By default, Auth0 includes the following parameters:\n\n*   `success` with value `true` or `false` indicating whether the email verification was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `Your email was verified. You can continue using the application.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n    *   `User account does not exist or verification code is invalid.` (with `success=false`)\n        \n    *   `This account is already verified.` or `Your email address could not be verified.`(with `success=false`)\n        \n\nYou can prevent sending the email addresses on the redirect links by updating the email templates using the Management API. For example:\n\n`PATCH /api/v2/email-templates/reset_email { \"includeEmailInRedirect\": false }` or,\n\n`PATCH /api/v2/email-templates/verify_email { \"includeEmailInRedirect\": false }`\n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Welcome emails\n\nOnce a user verifies their email address, they will receive a **Welcome Email**. If you turn off the **Verification Email** feature, the **Welcome Email** will be sent to the user when they sign-up (or log in for the first time).\n\nIn addition to the common variables available for all email templates, the following are available to the **Welcome** template:\n\n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n## Change password emails\n\nIf a user requests a password change, they will receive a **Change Password** email that contains a URL link. When the user clicks on the link, a [Password Reset page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page) will be presented to enter the new password.\n\nIn addition to the common variables available for all email templates, the following are available to the **User Invitation** template:\n\n*   `url`: URL that the user will select to change their password. You can use it in the **Message** field to create a link that the user can follow, as in this example: `<a href=\"/docs/{{ url }}\">Click here to change your password</a>`\n    \n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n### Redirect To results for change password template\n\nYou can configure a **Redirect To** URL to send the users to after the password change action was attempted. By default, Auth0 includes the following parameters:\n\n*   `success` with value `true` or `false` indicating whether the password change was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `You can now login to the application with the new password.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n    *   `The operation cannot be completed. Please try again.` (with `success=false`)\n        \n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Blocked account emails\n\nIf a user attempts to log in ten or more times unsuccessfully from the same IP address, the user account will be locked and they will receive a **Blocked Account** email. Once the user receives this email, they will not be able to login from that IP address again until they click on the link contained in the email.\n\nIf the user successfully logs in before they exhaust their ten allowed attempts, the counter is reset.\n\nIn addition to the common variables available for all email templates, the following ones are available in the **Blocked Account Email** template:\n\n*   `user.source_ip`\n    \n*   `user.city`\n    \n*   `user.country`\n    \n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\nThis template also provides the `url` variable that should be used to create the link that the user needs to follow. For example:\n\n`<a href=\"/docs/{{ url }}\">Click here to unblock your account</a>`\n\n### Redirect To results for blocked account email templates\n\nYou can configure a **Redirect To** URL to send the users to after the account unblocking action was attempted. When redirecting, Auth0 will include the following parameters:\n\n*   `email` indicating the email of the user\n    \n*   `success` with value `true` or `false` indicating whether the account unblocking was successful\n    \n*   `message` with an additional description of the outcome. Some possible values are:\n    \n    *   `Your account has been unblocked.` (with `success=true`)\n        \n    *   `This URL can be used only once` (with `success=false`)\n        \n    *   `Access expired.` (with `success=false`)\n        \n\nThe target URL handler should be prepared to gracefully handle other possible messages as well.\n\n## Breached password alert emails\n\nThis email type is sent whenever Auth0 detects that the user is trying to access the application using a password that has been leaked by a third party. These emails are only set after enabling **Breached Password Detection** in the [Attack Protection](https://manage.auth0.com/#/security/attack-protection) section of the dashboard. To learn more, see [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection).\n\nIn addition to the common variables available for all email templates, the following ones are available for the **Breached Password Alert** emails:\n\n*   If the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview):\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\n## Enrollment emails for MFA\n\nThis email will be generated when an MFA enrollment invitation is sent. The message will contain a link that, when visited, will show the MFA enrollment experience.\n\nIn addition to the common variables available for all email templates, the `link` variable is available in this email type, containing the URL that you will use to construct the link for this action, as in this example:\n\n`<a href=\"/docs/{{ link }}\">Enroll your MFA device</a>`\n\nUnlike other email templates, the correct variable name is `link` and not `url`. Also, the `connection.name` variable is not available on this email template type.\n\n## Verification code emails for MFA\n\nThis email will be generated when you use email as an MFA method and request a verification code to be sent. In addition to the common variables available, the template provides a `code` variable to render the code used for MFA verification. For example:\n\n`<div>Your code is: {{ code }}</div>`\n\n## User invitation emails\n\nIf a user is invited to become a member of an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), they will receive a **User Invitation** email that contains a URL link. When the user clicks on the link, they will be redirected to your default login route. To learn more, see [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes).\n\nIn addition to the common variables available for all email templates, the following are available to the **User Invitation** template:\n\n*   User invitation information (all information derived from the user invitation ticket):\n    \n    *   `inviter.name`\n        \n    *   `app_metadata`\n        \n    *   `user_metadata`\n        \n    *   `roles.id`\n        \n    *   `roles.name`\n        \n    *   `roles.description`\n        \n*   Organization information:\n    \n    *   `organization.id`\n        \n    *   `organization.display_name`\n        \n    *   `organization.name`\n        \n    *   `organization.metadata`\n        \n    *   `organization.branding.logo_url`\n        \n    *   `organization.branding.colors.primary`\n        \n    *   `organization.branding.colors.page_background`\n        \n\nTo localize emails, you can set the `locale` to be sent in `user_metadata` when creating an invitation. To learn more, see [Customize Email Templates: Multilingual Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n### Redirect results for user invitation email templates\n\nYou must [configure a default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes), to which users will be sent after selecting the link to accept the invitation. When redirecting, Auth0 will include the following parameters:\n\n*   `invitation`: ID of the invitation ticket\n    \n*   `organization`: ID of the organization to which the user is being invited\n    \n*   `organization_name`: Name of the organization to which the user is being invited\n    \n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link sent in the email invitation that an end-user receives will be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\nThe target login route should initiate a transaction to `/authorize` that contains the provided `invitation` and `organization` key-value pairs. It should also be prepared to gracefully handle other possible messages.\n\n## Passwordless emails\n\nUnlike the previous email templates types, this email template is not configured from the Email Templates section. Instead, it's part of the [settings for the Email Passwordless Connection](https://manage.auth0.com/#/connections/passwordless).\n\nThe Passwordless Email is sent when a passwordless access is requested, either by code (the user receives a code that types in the application) or by a link (the user clicks on a link and is taken directly to the application).\n\nYou can use all the common variables available in all templates, plus the following variables defined specifically for the **Passwordless Email** template:\n\n*   `send`, which will contain a value of `link`, `link_ios`, `link_android` or `code` depending on the type of passwordless email requested.\n    \n*   `code` with the one-time-use code to access the application\n    \n*   `link` with the link that can be clicked by the user to gain access to the application (only for link-type passwordless emails)\n    \n*   `request_language` will have the language code of the user request, if available\n    \n*   `operation`, which will be `change_email` if this is a passwordless email change operation.\n    \n\nThe default template uses the above variables to do something like this:\n\n```\n<!-- Email change content -->\n{% if operation == 'change_email' %}\n  <p>Your email address has been updated.</p>\n{% else %}\n  <!-- Signup email content -->\n  {% if send == 'link' or send == 'link_ios' or send == 'link_android' %}\n    <p>Click and confirm that you want to sign in to {{ application.name }}. This link will expire in five minutes.</p>\n    <a href=\"/docs/{{ link }}\">Sign in to {{ application.name }}</a>\n    {% elsif send == 'code' %}\n    <p>Your verification code is: <b>{{ code }}</b></p>\n  {% endif %}\n{% endif %}\n```\n\nIn the Passwordless Email template only the `email` property of the `user` object is available.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
    "title": "Email Template Descriptions",
    "description": "Describes the email templates used in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/use-org-name-authentication-api",
    "markdown": "# Use Organization Names in Authentication API\n\nBy default, the [Authentication API](https://auth0.com/docs/api/authentication) uses organization IDs to identify specific organizations. If needed, you can configure your tenant to also use organization names as an identifier. However, there are usability and security implications to consider before enabling this feature. To better understand the potential impact, review the [Considerations and recommendations](#considerations-and-recommendations) section.\n\n## How it works\n\nConfiguring your tenant to support organization names in the Authentication API results in the following:\n\n*   The `organization` parameter in the [/authorize](https://auth0.com/docs/api/authentication#authorize-application) and [SAML](https://auth0.com/docs/api/authentication#saml) endpoints can accept both organization names and IDs.\n    \n*   Access and ID tokens automatically include both `org_name` and `org_id` claims.\n    \n\nYou can enable this feature through your Auth0 Dashboard or the Management API:\n\n*   **Auth0 Dashboard**: Select [Settings](https://auth0.com/docs/get-started/tenant-settings) from the left-side menu and choose the **Advanced** tab. In the **Settings** section, enable the **Allow Organization Names in Authentication API** toggle.\n    \n*   **Management API**: Use the `PATCH /api/v2/tenants/settings` endpoint to set `allow_organization_name_in_authentication_api` to `true`. For more information, review the [Management API](https://auth0.com/docs/api/management/v2) documentation.\n    \n\n### Example flow\n\nThe following example demonstrates an authorization code flow that uses organization names.\n\n1\\. Call the `/authorize` endpoint passing your organization name for the `organization` parameter:\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope={scope}&\n    state={state}&\n    organization={yourOrganizationName}\n```\n\n2\\. After obtaining the authorization code, call the `POST /oauth/token` endpoint to retrieve access and ID tokens:\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code=yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n3\\. The decoded tokens returned contain both the `org_id` and `org_name` claims:\n\n```\n{\n    \"sub\": \"google-oauth2|10...17\",\n    \"aud\": [\n        \"https://yourApp\"\n    ],\n    \"iat\": 1686840988,\n    \"exp\": 1686927388,\n    \"azp\": \"Suo...qTd\",\n    \"scope\": \"openid profile\",\n    \"org_id\": \"{yourOrganizationId}\",\n    \"org_name\": \"{yourOrganizationName}\"\n}\n```\n\n## Considerations and recommendations\n\nBefore using organization names in the Authentication API, it is important to understand the primary differences between organization names and IDs.\n\nUnlike organization IDs (which remain static), you can change the name of an organization at any time after initial creation. Additionally, you can reuse organization names within a single tenant as long as it's only assigned to **exactly one** organization at a time. In practice, this means you can change the name of one of your organizations and reuse its original name for another organization in your tenant. Organization names are only unique within a single tenant; the same name may be used for two or more organizations across multiple tenants.\n\nIn general, using organization IDs is recommended when validating tokens. However, if using organization names is more appropriate for your use case, consider the implications below when implementing the feature.\n\n### Usability and security considerations\n\nConsider the potential impacts below when using organization names to request and validate tokens:\n\n*   **Organization names can be reused**: Long-lived tokens do not expire when an organization changes its name, and the org\\_name claims in those tokens retain their original value. If the original name is later reused by a different organization, such tokens may grant users unauthorized access to data and resources managed by the new organization.\n    \n*   **Organization names are only unique within a single tenant**: If your API does not verify `iss` (issuer) claims in tokens, an organization with the same name in a different tenant could generate tokens that are incorrectly accepted by your API.\n    \n*   **Organization names can be changed**: If you change the name of an organization, your applications must provide the new organization name in Authentication API requests. As tokens can be long-lived, the `org_name` claim in a token may no longer match the current organization name, which could prevent applications from granting access to the appropriate organization.\n    \n\n### Recommended best practices\n\nDue to the possible security and usability impacts, using IDs instead of names to validate tokens is recommended when working with organizations. If you choose to use organization names, follow the best practices below for an optimal experience:\n\n*   Always validate the `iss` claim to ensure a token was issued by your Auth0 tenant.\n    \n*   Avoid reusing organization names that previously existed in your tenant. To prevent reuse and ensure previously issued tokens cannot be used to access different organizations, maintain an accurate and up-to-date record of historic organization names.\n    \n*   Avoid renaming organizations once they are in use unless absolutely necessary. If you choose to rename an organization, be aware that existing access and ID tokens do not automatically contain the new organization name. After renaming an organization, ensure you prompt users to log in again.",
    "title": "Use Organization Names in Authentication API",
    "description": "Setup, security considerations, and best practices for using organization names in the Authentication API. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance/data-security/denylist",
    "markdown": "# Add User Attributes to Deny List\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \\\n  --header 'authorization: Bearer YOUR_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\": {\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")\n  .header(\"authorization\", \"Bearer YOUR_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID',\n  headers: {authorization: 'Bearer YOUR_TOKEN', 'content-type': 'application/json'},\n  data: {options: {non_persistent_attrs: ['ethnicity', 'gender']}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"non_persistent_attrs\": @[ @\"ethnicity\", @\"gender\" ] } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\"\n\nheaders = {\n    'authorization': \"Bearer YOUR_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\": {\\\"non_persistent_attrs\\\": [\\\"ethnicity\\\", \\\"gender\\\"]}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer YOUR_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\"non_persistent_attrs\": [\"ethnicity\", \"gender\"]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Add User Attributes to Deny List",
    "description": "Describes how to identify user attributes that you do not want to save in Auth0 databases.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa",
    "markdown": "# Configure Email Notifications for MFA\n\nUse email as a multi-factor authentication (MFA) factor to provide users a way to perform MFA when they don't have their primary factor available (e.g. they don't have their device to receive an SMS or push notification).\n\n#### Availability varies by login implementation\n\nThe login implementation you use affects whether this feature is available. To learn more, read [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\nEmail is not true MFA because it does not represent a different factor than the password. It does not represent **something I have** or **something I am**, but rather just **something I know** (the email password). It is also weaker than other factors in that it's only as secure as the email itself (for example, encrypted end-to-end).\n\nUsers do not need to explicitly enroll with email MFA. They will get be able to use it when they have a verified email. This happens when they:\n\n*   Complete the email verification flow which updates the `email_verified` field using the Management API.\n    \n*   Log in with a connection that provides verified emails (such as Google).\n    \n\nYou can only enable email as an MFA factor if there is already another factor enabled.\n\nOnce Email MFA is enabled, users will be prompted to complete MFA with another enabled factor. If they select **Try another method**, and then pick **Email**, they will be sent an email with a 6-digit code that they will need to enter to complete the authentication flow.\n\n## Configure email notifications\n\nYou can explicitly enroll email for MFA using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators). If users have a verified email and one or more explicitly enrolled emails, they can choose to select which email they want to use to complete MFA when logging-in using Universal Login.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/multifactor-auth) and enable the **Email** toggle. You will only be able to enable it if there is another factor enabled.\n    \n2.  Auth0 provides a test email provider but it only allows a limited amount of emails, so you should configure your own email provider. To learn more, read [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers).\n    \n\n## Learn more\n\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Customize Emails](https://auth0.com/docs/customize/email)\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
    "title": "Configure Email Notifications for MFA",
    "description": "Describes how to configure email as an MFA factor for users who don't have their primary factor available.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing",
    "markdown": "# Get Management API Access Tokens for Testing\n\nThe first time you get a test token for the Management API is when you complete the configuration in the Auth0 Dashboard. You won't have to do this again unless you create a new tenant. We recommend that you create a test token exclusively for authorizing access to the Management API instead of reusing another one you might have.\n\n## Prerequisites\n\n*   [Create Machine-to-Machine Applications for Testing](https://auth0.com/docs/get-started/apis/create-m2m-app-test)\n    \n\n## Get Access Tokens Manually\n\n1.  On your Auth0 Dashboard, navigate to **Applications > APIs >** [Auth0 Management API](https://manage.auth0.com/#/apis/management/explorer). Select the **API Explorer** tab and locate an auto-generated token in the **Token** section.\n    \n2.  Select the **Copy** icon to the right of the token. You can now make authorized calls to the [Management API](https://auth0.com/docs/api/management/v2) using this token.\n    \n    ![APIs - Management API access tokens - Testing - Copy token](https://images.ctfassets.net/cdy7uua7fh8z/3Y4I9YJR77j73FCYDiegnC/44f32f76d27357bc39aad9ee7c4d5561/management-api-access-token.png)\n3.  Optionally set the expiration time. By default, the token has an expiration time of 86400 seconds, which is 24 hours. After that period, the token expires and can no longer be used. To change the expiration time, update **Token Expiration (Seconds)** and click **Update & Regenerate Token**.\n    \n\n## Use Access Tokens for Testing\n\nYou can use the Access Token you just created for testing purposes to manually call an endpoint through the [Management API Explorer](https://auth0.com/docs/api/management/v2).\n\n1.  Visit the [Management API Explorer](https://auth0.com/docs/api/management/v2#!), and select the **Set API Token** button.\n    \n2.  Complete the **API Token** field. Additional information then displays on the popup, such as the scopes granted to the application.\n    \n3.  Select **Set Token** to save your token and close the popup. Notice that the Set API Token button now displays as **Authorized**.\n    \n4.  To begin testing, navigate to an endpoint you wish to call and enter any required or optional parameters in the fields to the right. Then, select **Test Endpoint**.\n    \n    ![APIs - Management API access tokens - Testing - Set token](https://images.ctfassets.net/cdy7uua7fh8z/4GWcJnm3NcxK7ngamrorZB/6ac652093de36117c034353be38657c9/Management_API_Explorer.png)\n\n## Learn more\n\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)",
    "title": "Get Management API Access Tokens for Testing",
    "description": "Learn how to get an Access Token manually for testing purposes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage",
    "markdown": "# User Data Storage\n\nAuth0 stores user information for your tenant in a hosted cloud database, or you can choose to store user data in your own custom external database.\n\nTo store user data beyond the basic information Auth0 uses for authentication, you can use the Auth0 data store or a custom database. However, if you use the additional data for authentication purposes, we recommend that you use the Auth0 data store, as this allows you to manage your user data through the [Auth0 Management Dashboard](https://manage.auth0.com/#).\n\n## External database vs. Auth0 data store\n\nThe Auth0 data store is customized for authentication data. Storing anything beyond the default user information should be done only in limited cases. Here's why:\n\n*   **Scalability**: The Auth0 data store is limited in scalability, and your Application's data may exceed the appropriate limits. By using an external database, you keep your Auth0 data store simple, while the more efficient external database contains the extra data;\n    \n*   **Performance**: Your authentication data is likely accessed at lower frequencies than your other data. The Auth0 data store isn't optimized for high-frequency use, so you should store data that needs to be retrieved more often elsewhere;\n    \n*   **Flexibility**: Because the Auth0 data store was built to accommodate only user profiles and their associated metadata, you are limited in terms of the actions you can perform on the database. By using separate databases for your other data, you can manage your data as appropriate.\n    \n\nWhen outsourcing user authentication, there is usually no need to maintain your own users/passwords table. Even so, you may still want to associate application data with authenticated users.\n\n*   For example, you could have a Users table that lists each user authenticated by Auth0. Every time a user logs in, you could search the table for that user. If the user does not exist, you would create a new record. If they do exist, you would update all fields, essentially keeping a local copy of all user data.\n    \n*   Alternatively, you could store the user identifier in each table/collection that has user-associated data. This is a simpler implementation suited to smaller applications.\n    \n\n## User data storage example scenario\n\nAuth0 provides a sample app, a mobile music application, that reflects the end-to-end user experience when using Auth0 with a custom external database. The sample app is an iOS app created using the [Auth0 iOS seed project](https://auth0.com/docs/quickstart/native/ios-swift). The backend uses the [Node.js API](https://auth0.com/docs/quickstart/backend/nodejs).\n\nFor a visualization of the application's overall structure, see the [Mobile + API architecture scenario](https://auth0.com/docs/architecture-scenarios/application/mobile-api).\n\n### Metadata\n\n#### App metadata\n\nThe following data points from our mobile music application are appropriate to store in `app_metadata`:\n\n*   User's subscription plan\n    \n*   User's right (or lack thereof) to edit featured playlists\n    \n\nThese two data points should be stored in `app_metadata` instead of `user_metadata` because they should not be directly changeable by the user.\n\n#### User metadata\n\nThe following data points from our mobile music application are appropriate to store in `user_metadata`:\n\n*   Application preferences\n    \n*   Details chosen by the user to alter their experience of the app upon login.\n    \n\nNote that, unlike the data points for `app_metadata`, the user can easily and readily change those stored in `user_metadata`.\n\nWe can let the user change their `displayName`, which is the name the user sees upon logging in and is displayed to other users of the app.\n\nTo display the user's chosen identifier whenever they log in, we use a rule to get the `user.user_metadata` value.\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  user.user_metadata.displayName = user.user_metadata.displayName || \"user\";\n\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nHere's a look at the screen the user would use to change their `displayName`:\n\n![iOS app settings screen with option to update display name.](https://images.ctfassets.net/cdy7uua7fh8z/33YxGQKYztHY3OM6mxJ4jN/0a06103e6b6455c2e1962a1f738b663a/4-settings.png)\n\nTo save the changes to the database, the application makes a call to the [Get a User](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) endpoint of the Management API to identify the appropriate user:\n\n*   [cURL](#bb915eba4e70433faf76ce8aa6ad8836_shell)\n*   [C#](#bb915eba4e70433faf76ce8aa6ad8836_csharp)\n*   [Go](#bb915eba4e70433faf76ce8aa6ad8836_go)\n*   [Java](#bb915eba4e70433faf76ce8aa6ad8836_java)\n*   [Node.JS](#bb915eba4e70433faf76ce8aa6ad8836_node)\n*   [Obj-C](#bb915eba4e70433faf76ce8aa6ad8836_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id \\\n  --header 'authorization: Bearer {yourIdToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourIdToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourIdToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer {yourIdToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id',\n  headers: {authorization: 'Bearer {yourIdToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourIdToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourIdToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourIdToken}\" }\n\nconn.request(\"GET\", \"%7ByourAccount%7D.auth0.com/api/v2/users/user_id\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourIdToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourIdToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourAccount%7D.auth0.com/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis is followed by a call to the [Update a User](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint to update the `user_metadata` field:\n\n*   [cURL](#116a53b25cee4458bf8845747b966675_shell)\n*   [C#](#116a53b25cee4458bf8845747b966675_csharp)\n*   [Go](#116a53b25cee4458bf8845747b966675_go)\n*   [Java](#116a53b25cee4458bf8845747b966675_java)\n*   [Node.JS](#116a53b25cee4458bf8845747b966675_node)\n*   [Obj-C](#116a53b25cee4458bf8845747b966675_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer {yourAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"displayName\": \"J-vald3z\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {authorization: 'Bearer {yourAccessToken}', 'content-type': 'application/json'},\n  data: '{\"user_metadata\": {\"displayName\": \"J-vald3z\"}'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{\"user_metadata\": {\"displayName\": \"J-vald3z\"}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\"\n\nheaders = {\n    'authorization': \"Bearer {yourAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"displayName\\\": \\\"J-vald3z\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet postData = NSData(data: \"{\"user_metadata\": {\"displayName\": \"J-vald3z\"}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou must replace `{yourAccessToken}` with a [Management API Access Token](https://auth0.com/docs/api/management/v2/concepts/tokens).\n\n### User data permission rules\n\nUse [rules](https://auth0.com/docs/customize/rules) to implement permissions on whether a user can edit featured playlists or not.\n\n#### Assign Playlist Editor role\n\nThe first rule sends a request to our Node API, which then queries the database connected to Heroku to check how many plays the user’s playlist has. If the number is 100 or greater, we assign `playlist_editor` as a value in the `roles` array in `app_metadata`.\n\n```\nfunction (user, context, callback) {\n\n  var request = require('request');\n\n  user.app_metadata = user.app_metadata || {};\n  user.app_metadata.roles = user.roles || [];\n\n  var CLIENT_SECRET = configuration.AUTH0_CLIENT_SECRET;\n  var CLIENT_ID = configuration.AUTH0_CLIENT_ID;\n\n  var scope = {\n    user_id: user.user_id,\n    email: user.email,\n    name: user.name\n  };\n\n  var options = {\n    subject: user.user_id,\n    expiresInMinutes: 600,\n    audience: CLIENT_ID,\n    issuer: 'https://example.auth0.com'\n  };\n\n  var id_token = jwt.sign(scope, CLIENT_SECRET, options);\n\n  var auth = 'Bearer ' + id_token;\n\n  request.get({\n    url: 'https://example.com/playlists/getPlays',\n    headers: {\n       'Authorization': auth,\n      'Content-Type': 'text/html'\n    },\n    timeout: 15000\n  }, function(err, response, body){\n    if (err)\n      return callback(new Error(err));\n    var plays = parseInt(body, 10);\n\n    if (plays >= 100 && user.roles.indexOf('playlist_editor') < 0){\n      user.app_metadata.roles.push('playlist_editor');\n      auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n        .then(function(){\n          callback(null, user, context);\n        })\n        .catch(callback);\n    }\n\n    else if (plays < 100 && user.roles.indexOf('playlist_editor') >= 0){\n      user.app_metadata.roles = [];\n      auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n        .then(function(){\n          callback(null, user, context);\n        })\n        .catch(callback);\n    }\n    else{\n      callback(null, user, context);\n    }\n\n  });\n\n}\n```\n\n#### Scope parameter specifies role\n\nThe second rule gets the `app_metadata` field and assigns the `roles` array to a field in the user object so it can be accessed without calling `app_metadata` on the application. The `scope` parameter can then specify `roles` upon the user logging in without including everything in `app_metadata` in the user object:\n\n```\nfunction(user, context, callback) {\n   if (user.app_metadata) {\n      user.roles = user.app_metadata.roles;\n   }\n   user.roles = user.roles || [];\n   callback(null, user, context);\n}\n```\n\nAfter we've implemented these two rules, the app recognizes whether the user is a playlist editor or not and changes the welcome screen accordingly. If `playlist_editor` is in the `roles` array stored in the user's `app_metadata`, the user will be welcomed as an **EDITOR** after signing in:\n\n![Example of user profile page with editor role.](https://images.ctfassets.net/cdy7uua7fh8z/1WEKC4eWvm8GPK2BlodGFk/3eb36843f22518ace800fc1507bd5816/3-home.png)\n\n#### Associate a user's music with the user\n\nWe need to associate a user's music with that user, but this information is not required for authentication. Here's how to store this information in a separate database that is integrated with the backend of the application.\n\nThe user's unique identifier is the `user_id`. Here is a sample row from the `songs` table in our database:\n\n| song\\_id | songname | user\\_id |\n| --- | --- | --- |\n| 1   | Number One Hit | google-oauth2 |\n\nThe Node.js backend authenticates requests to the URI associated with getting the user’s personal data from the database by validating a JSON Web Token.\n\n[Learn about token-based authentication and how to implement JWT in your Applications.](https://auth0.com/docs/tokens/concepts/jwts)\n\nHere is the code implementing JWT validation from the Node.js seed project:\n\n```\nvar genres = require('./routes/genres');\nvar songs = require('./routes/songs');\nvar playlists = require('./routes/playlists');\nvar displayName = require('./routes/displayName');\n\nvar authenticate = jwt({\n  secret: process.env.AUTH0_CLIENT_SECRET,\n  audience: process.env.AUTH0_CLIENT_ID\n});\n\napp.use('/genres', authenticate, genres);\napp.use('/songs', authenticate, songs);\napp.use('/playlists', authenticate, playlists);\napp.use('/displayName', authenticate, displayName);\n```\n\nWe can add functionality to handle different data requests from our Application. For example, if we receive a `GET` request to `/secured/getFavGenre`, the API calls the `queryGenre()` function, which queries the database for and responds with the user’s favorite genre.\n\n```\n@IBAction func getGenre(sender: AnyObject) {\n        let request = buildAPIRequest(\"/genres/getFav\", type:\"GET\")\n        let task = NSURLSession.sharedSession().dataTaskWithRequest(request) {[unowned self](data, response, error) in\n            let genre = NSString(data: data!, encoding: NSUTF8StringEncoding)\n            dispatch_async(dispatch_get_main_queue(), {\n                self.favGenre.text = \"Favorite Genre:  \\(genre!)\"\n            })\n        }\n        task.resume()\n    }\n```\n\nThe function `buildAPIRequest()` takes the path and HTTP method of the request as parameters and builds a request using the base URL of our Node.js API that's hosted on Heroku.\n\nIn the Application, the `getGenre()` function makes a request to the API and changes the app's interface to display the request response to `/genres/getFav`. The backend retrieves the required data for this action using the `queryGenre()` function and returns the results to the Application:\n\n```\nfunction queryGenre(user_id, res){\n\n  db.connect(process.env.DATABASE_URL, function(err, client) {\n  if (err) throw err;\n\n  client\n    .query('SELECT fav_genre as value FROM user_data WHERE user_id = $1', [user_id], function(err, result) {\n\n      if(err) {\n        return console.error('error running query', err);\n      }\n      res.send(result.rows[0].value);\n    });\n  });\n\n};\n```\n\n## Learn more\n\n*   [Normalized User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles)\n*   [Normalized User Profile Schema](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema)\n*   [Sample User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles)",
    "title": "User Data Storage",
    "description": "Learn the differences between using the Auth0 data store and an external database to store user data.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/changes-in-auth0-management-apiv2-tokens",
    "markdown": "# Changes in Auth0 Management APIv2 Tokens\n\nSome time ago, we changed the process of getting a Management APIv2 Token. This article explains what changed, why this was done, and how you can work around it (not recommended).\n\n## What changed and why\n\n### The user experience\n\nUntil recently, you could generate a Management APIv2 Token directly from the Management API Explorer. You selected the scopes, according to the endpoint you wanted to invoke, and got a token from that same page.\n\nThat way was very easy, but it was also very insecure. So we changed it.\n\nThe new way uses the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow). To learn how to use the new process, see [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n#### Why this changed\n\nTo generate the token, the Management API required access to your Global Client Secret (used to sign the token). This is information that should not be exposed to web browsers.\n\nFurthermore, the API Explorer has no way to do authorization. This means that if a user could log in and access the API Explorer, they could generate a token with any scope, even if they were not allowed to have that scope.\n\nThe new implementation does not pose such risks. Once you perform the initial configuration, you can get a token either by visiting the Auth0 Dashboard, or by making a simple `POST` request to the [`/oauth/token` endpoint of our Authentication API](https://auth0.com/docs/api/authentication#client-credentials).\n\nHowever, with regards to the manual process, we do understand that changing screens is not always the best user experience, so we are looking into ways to make the new flow more intuitive.\n\n### The validity period\n\nWith the previous flow, tokens never expired. With the new flow, all Management APIv2 tokens expire by default after 24 hours.\n\n#### Why this changed\n\nHaving a token that never expires can be very risky, in case an attacker gets hold of it. If the token expires within a few hours, the attacker has only a small window of time in which to access your protected resources.\n\nTo get a token, you should follow only the process described in [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).",
    "title": "Changes in Auth0 Management APIv2 Tokens",
    "description": "Learn what changed in the flow for generating Auth0 Management APIv2 tokens and why.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications",
    "markdown": "# Get Management API Access Tokens for Single-Page Applications\n\nIn certain cases, you may want to use Auth0's [Management API](https://auth0.com/docs/api/management/v2#!) to manage your applications and APIs rather than the Auth0 Management Dashboard.\n\nTo call any Management API endpoints, you must authenticate using a specialized [Access Token](https://auth0.com/docs/secure/tokens/access-tokens) called the Management API Token. Management API Tokens are [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) that contain specific granted permissions (also known as scopes) for the Management API endpoints you want to call.\n\n## Limitations\n\nSince single-page applications (SPAs) are public clients and cannot securely store sensitive information (such as a **Client Secret**), they must retrieve Management API Tokens from the frontend, unlike other [application types](https://auth0.com/docs/get-started/applications). This means that Management API Tokens for SPAs have certain limitations. Specifically, they are issued in the context of the user who is currently signed in to Auth0 which limits updates to only the logged-in user's data. Although this restricts use of the Management API, it can still be used to perform actions related to updating the logged-in user's user profile.\n\n## Available scopes and endpoints\n\nWith a Management API Token issued for a SPA, you can access the following scopes (and hence endpoints).\n\n## Use Management API token to call Management API from a SPA\n\nYou can retrieve a Management API Token from a SPA (using the Management API’s audience to generate it) and use the token to call the Management API to retrieve the full user profile of the currently logged-in user.\n\n1.  [Retrieve a Management API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).\n    \n    1.  Authenticate the user by redirecting them to the Authorization endpoint, which is where users are directed upon login or sign-up.\n        \n    2.  When you receive the Management API Token, it will be in [JSON Web Token format](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n        \n    3.  Decode it and review its contents.\n        \n2.  Call the Management API to retrieve the logged-in user's user profile from the [Get User by ID](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) endpoint.\n    \n    1.  To call the endpoint, include the encoded Management API token you retrieved in the `Authorization` header of the request.\n        \n    2.  Be sure to replace the `USER_ID` and `MGMT_API_ACCESS_TOKEN` placeholder values with the logged-in user's user ID (`sub` value from the decoded Management API token) and the Management API access token, respectively.\n        \n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)",
    "title": "Get Management API Access Tokens for Single-Page Applications",
    "description": "Learn about available scopes and endpoints for Management API tokens for Single-page Applications (SPAs).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/connections/get-connections-by-id",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa",
    "markdown": "# Configure WebAuthn with Security Keys for MFA\n\nFor an introduction to WebAuthn and how Auth0 implements it for both [](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)Security Keys and [Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa), check out [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn).\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Use the Dashboard\n\n1.  Enable **WebAuthn with Security Keys** by going to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n2.  Configure how you want to handle User Verification. For security keys, the typical user verification prompts users to enter a PIN to complete the WebAuthn challenge.\n    \n    1.  Never: Users will never be prompted to enter a PIN. This is the default value, and it's usually good enough when using security keys for MFA. Users already entered their password, so already provided some verification.\n        \n    2.  If supported: Users will be prompted to enter a PIN if they already configured one in the key.\n        \n    3.  Required: Users will be asked to set a PIN if it's not already set, and they'll be asked to enter it each time. This is the option that offers the highest security. Some browsers don't implement this properly (for example, [Brave](https://brave.com/) on iOS) so the authentication will fail and Auth0 will ask users to use another browser.\n        \n\nNote that only FIDO-2 compliant security keys support user verification. FIDO-1 keys can be used for WebAuthn, but are not usable if you set User Verification to Required.\n\n## Configure Relying Party\n\nWebAuthn makes phishing impossible by binding the credentials with the browser's origin. Users can't use WebAuthn for a site they did not register too.\n\nBinding credentials to the origin means if you configure a custom domain or change it, users enrolled before the change will not be able to authenticate.\n\nWebAuthn defines a [Relying Party ID attribute](https://www.w3.org/TR/webauthn-2/#relying-party-identifier), which lets you specify the domain used to authenticate users. You can set it to any registrable domain suffix of the browser origin. For example, if the custom domain is accounts.acme.com, you can configure the Relying Party ID to acme.com. This lets users authenticate to any acme.com domain with their WebAuthn credentials.\n\nAuth0 lets you specify the Relying Party ID only if you have a custom domain configured. If the custom domain changes, you must update the Relying Party ID.\n\n## Device support\n\nTo use security keys, a browser needs to have JavaScript enabled and support WebAuthn. If those conditions are not met, Auth0 will not offer the option of enrolling or authenticating with security keys. Auth0 will challenge with another factor or with a recovery code (if they don't have another factor enrolled).\n\nThe latest versions of popular browsers and operating systems provide support for WebAuthn with Security Keys. For more details, read the the [browser support section in webauthn.me](https://webauthn.me/browser-support).\n\n## Limitations\n\n*   When using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) you can list and remove WebAuthn enrollments, but you cannot enroll them.\n    \n\n## Learn more\n\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)",
    "title": "Configure WebAuthn with Security Keys for MFA",
    "description": "Describes how to configure WebAuthn with Security Keys for MFA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa",
    "markdown": "# Configure OTP Notifications for MFA\n\nTo use one time passwords (OTPs) as an authentication factor, users need an Authenticator app such as:\n\n*   Authy ([Google Play](https://play.google.com/store/apps/details?id=com.authy.authy) / [App Store](https://itunes.apple.com/us/app/authy/id494168017)).\n    \n*   Google Authenticator ([Google Play](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2) / [App Store](https://itunes.apple.com/us/app/google-authenticator/id388497605)).\n    \n*   Auth0 Guardian ([Google Play](https://play.google.com/store/apps/details?id=com.auth0.guardian) / [App Store](https://itunes.apple.com/us/app/auth0-guardian/id1093447833)).\n    \n*   Microsoft Authenticator ([Google Play](https://play.google.com/store/apps/details?id=com.azure.authenticator) / [App Store](https://itunes.apple.com/us/app/microsoft-authenticator/id983156458))\n    \n\n![Auth0 Guardian OTP QR code setup example](https://images.ctfassets.net/cdy7uua7fh8z/2J6vWaonPbCvpuBUu9b8q1/50be3671f7524b0e84628763a38a3b8b/mfa-otp-setup.png)\n\nUpon signup, they can scan a code and set up the app, upon which it will begin generating one-time codes. Afterward, when logging in to the app, the user can simply check the authenticator app for the current one-time code:\n\n![Auth0 Guardian OTP Code Google example](https://images.ctfassets.net/cdy7uua7fh8z/1vVY2NLQwsOwdHIPU4Qj3B/026255e1549c3ec5bdc790280590d210/google-auth-screenshot.png)\n\nYour user enters the code at the prompt:\n\n![Auth0 Guardian OTP Login Prompt Example](https://images.ctfassets.net/cdy7uua7fh8z/4dntQCYqgx5QyLZKW7quxR/f8c5af166c1387442285da52e99dfd67/mfa-login.png)\n\nYour users will need to have an OTP Authenticator app installed on their mobile devices.\n\n## Learn more\n\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)",
    "title": "Configure OTP Notifications for MFA",
    "description": "Describes how to configure time-based one time passwords (OTP) notifications for MFA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa",
    "markdown": "# Configure Push Notifications for MFA\n\nThe [Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) SDKs for [iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk) and [Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk) allow you to use a custom-built app for vendor-specific push notification services. You can configure push notifications for the AWS Simple Notification Service (SNS) platform or use Direct to Vendor services to add Firebase Cloud Messaging (FCM) and Apple Push Notification (APN) credentials directly in Auth0.\n\n## AWS SNS Configuration\n\nBefore you configure push notifications, follow the prerequisites below:\n\n1.  [Create an SNS Platform Application](https://console.aws.amazon.com/sns/v3/home?region=us-east-1#/mobile/push-notifications/platform-applications) using AWS Management console and note it’s ARN.\n    \n2.  Create an AWS Access Key ID authorized to create Platform Application endpoints. Guardian automatically creates a Platform Application endpoint with an appropriate device token as part of a successful enrollment.\n    \n\n### Configure push notifications with AWS SNS\n\nTo receive push notifications from Guardian, you first need to override Guardian's default SNS settings. Then, you can configure push notifications for Android and iOS.\n\n1.  On the Auth0 Dashboard, navigate to [Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and select **Push via Auth0 Guardian**. If the method is inactive, select the toggle at the top right to enable it.\n    \n    ![Auth0 Dashboard > Security > Multi-factor Auth > Guardian](https://images.ctfassets.net/cdy7uua7fh8z/6IH2tJOYtzYLhu7txyOAYv/ab682c51e57f0ef3621884c594616d18/Push_Notifications_with_Guardian.png)\n2.  Select **Custom** to reveal additional settings.\n    \n3.  In the Push Notification Service section, choose **Amazon SNS.**\n    \n\n![Auth0 Dashboard > Security > Multi-factor Auth > Guardian > Custom > Amazon SNS](https://images.ctfassets.net/cdy7uua7fh8z/6PKSyH99GJ2CalJoG38sfZ/fbe7229dcc6f7d303a582520001b3dc1/Amazon_SNS.png)\n\n1.  In the Amazon SNS Configuration section, complete the following fields:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | AWS Access Key ID | Your AWS Access Key ID. |\n    | AWS Secret Access Key | Your AWS Secret Access Key. |\n    | AWS Region | Your AWS application's region. |\n    \n2.  Select **Save** to complete your changes.\n    \n\n## Configure push notifications for Android using FCM\n\nTo configure Android push notifications on your Auth0 Dashboard, first retrieve your FCM server credentials. For full details, review Google's [Firebase documentation](https://firebase.google.com/docs/admin/setup#initialize-sdk).\n\n1.  Navigate to the Firebase Console and select your applicable project.\n    \n2.  Open the **Settings** menu and choose **Service Accounts**.\n    \n3.  Select **Generate New Private Key** to download your credential file.\n    \n\nAfter you retrieve your credentials, you can configure push notifications on your Auth0 Dashboard.\n\n## Configure push notifications for iOS using APNs\n\nTo configure iOS push notifications on your Auth0 Dashboard, first retrieve your APN certificate.\n\n1.  Generate a [new APN certificate](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/establishing_a_certificate-based_connection_to_apns#2947597) from your Apple developer account.\n    \n2.  Install the certificate locally.\n    \n3.  Find the **Apple Sandbox Push Services: {AppId}** certificate in your Keychain Access.\n    \n4.  Export the certificate and the associated private key to a P12 file without a password (default name: `Certificates.p12`).\n    \n5.  To generate a P12 file using Triple DES instead of RC2, run\n    \n    ```\n    openssl pkcs12 -in Certificates.p12 -legacy -nocerts -nodes -out pk.pem -passin pass:\"\" &&\n    openssl pkcs12 -in Certificates.p12 -legacy -nokeys -out cert.crt -passin pass:\"\" &&\n    openssl pkcs12 -export -inkey pk.pem -in cert.crt -descert -out Certificate_3des.p12 -passout pass:\"\" &&\n    rm pk.pem cert.crt\n    ```\n    \n6.  Delete `Certificates.p12` and use `Certificate_3des.p12` as the APN certificate in the Auth0 Dashboard.\n    \n\nAfter you retrieve your credentials, you can configure push notifications on your Auth0 Dashboard.\n\n## Learn more\n\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Create Custom Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)",
    "title": "Configure Push Notifications for MFA",
    "description": "Describes how to configure push notifications for MFA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa",
    "markdown": "# Configure WebAuthn with Device Biometrics for MFA\n\nFor an introduction to WebAuthn and how Auth0 implements it for both [Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) and Device Biometrics, check out [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn).\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Use the Dashboard\n\nEnable **WebAuthn with Device Biometrics** by going to [Dashboard > Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa). You'll need to enable an additional factor, as it cannot be the only factor enabled.\n\n## Configure Relying Party\n\nWebAuthn makes phishing impossible by binding the credentials with the browser's origin. Users can't use WebAuthn for a site they did not register too.\n\nBinding credentials to the origin means if you configure a custom domain or change it, users enrolled before the change will not be able to authenticate.\n\nWebAuthn defines a [Relying Party ID attribute](https://www.w3.org/TR/webauthn-2/#relying-party-identifier), which lets you specify the domain used to authenticate users. You can set it to any registrable domain suffix of the browser origin. For example, if the custom domain is accounts.acme.com, you can configure the Relying Party ID to acme.com. This lets users authenticate to any acme.com domain with their WebAuthn credentials.\n\nAuth0 lets you specify the Relying Party ID only if you have a custom domain configured. If the custom domain changes, you must update the Relying Party ID.\n\n## Device recognition\n\nWhen you enable WebAuthn with Device Biometrics, Auth0 will try to progressively enroll all of an end-user's WebAuthn-capable devices. Browsers with Javascript disabled or without WebAuthn platform authenticator support, won’t get the option to enroll or authenticate with Device Biometrics.\n\nSince there's no deterministic way to know if a specific device was enrolled or not without challenging the user for WebAuthn, Auth0 relies on the user agent to decide what to do. The behavior depends on the operating system.\n\n### Windows and iOS 14.5+\n\nOn Windows and iOS 14.5+, the WebAuthn platform authenticator is registered at the **operating system level.** Users can enroll with one browser and login with any browser. If Auth0 detects that users have a device enrolled, they will get the option to authenticate with Face ID / Touch ID / Windows Hello. If they enrolled with that same device they'll be able to authenticate. If not, it will fail, and they'll need to use another authentication method.\n\n### macOS \n\nOn Mac, the WebAuthn platform authenticator is registered at the **browser** system level. Users will be asked to enroll with WebAuthn in each browser they use. If Auth0 detects that the user has enrolled from Chrome on a Mac, they will get the option to authenticate with Touch ID when they login from Chrome on a Mac. If they enrolled from the same Mac, they’ll be able to authenticate.  If no, it will fail, and they'll need to use another authentication method. If they try to enroll from Safari in the same Mac, they will be asked to complete MFA with the other authentication method, and then **prompted to enroll** with Touch ID.\n\n### Android\n\nOn Android, **only Chrome** supports WebAuthn platform authenticators. If Auth0 detects that users have an Android device enrolled, they will get the option to authenticate with Android’s Fingerprint/Face Recognition. If they enrolled with that same Android device they'll be able to authenticate. If not, it will fail, and they'll need to use another authentication method.\n\n## Device support\n\nThe user must have another MFA enrollment activated before using device biometrics.\n\nTo use device biometrics keys, a browser needs to have JavaScript enabled and support WebAuthn Platform Authenticators. If those conditions are not met, Auth0 will not offer the option of enrolling or authenticating with the device. Auth0 will challenge the user with another factor.\n\nThe latest versions of popular browsers and operating systems provide support for WebAuthn with Security Keys. For more details, check out the [browser support section in webauthn.me](https://webauthn.me/browser-support).\n\n## Limitations\n\n*   There isn't a a way to enroll with WebAuthn device biometrics beyond the Progressive Enrollment prompt.\n    \n*   When using the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) you can list and remove WebAuthn enrollments, but you cannot enroll them.\n    \n*   Users can only enroll one device per type using WebAuthn with Device Biometrics (one phone, one tablet, one laptop/desktop). If a user wants to enroll another device of the same type, the first device must be unenrolled.\n    \n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
    "title": "Configure WebAuthn with Device Biometrics for MFA",
    "description": "Describes how to configure WebAuthn with Device Biometrics",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets",
    "markdown": "# Create Custom Enrollment Tickets\n\nYou can manage users' enrollments by creating enrollment tickets via the MFA API [`/Guardian/post_ticket`](https://auth0.com/docs/api/management/v2#!/Guardian/post_ticket) endpoint. This API will return an enrollment ticket containing a `ticket_id` and a `ticket_url`, which can be used to enroll a user. The `ticket_url` can be delivered to the user (for example, via email) and used to kick off the enrollment process. Tickets expire after 5 days. A user who receives a ticket will only be able to enroll once. Further enrollments must be made via the MFA API.\n\nIf you are using the Classic Universal Login experience and you need to customize how the page looks when the user navigates to the `ticket_url`, you can edit the MFA page. Go to the [Dashboard > Branding > Universal Login > Multi-factor Authentication](https://manage.auth0.com/#/mfa_page) tab, and modify the `ticket` variable. Here is an example:\n\n```\n{% if ticket %}\n<h4 class=\"message\">Welcome, {{ userData.email }}, enroll your device below</h4>\n{% else %}\n<h4 class=\"message\">Welcome back, {{ userData.email }}, authenticate below</h4>\n{% endif %}\n```\n\n## Learn more\n\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)",
    "title": "Create Custom Enrollment Tickets",
    "description": "Learn how to create an enrollment ticket from the Auth0 MFA API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk",
    "markdown": "# Install Guardian SDK\n\nThe Guardian SDK provides a UI-less client for Guardian.\n\n`npm install auth0-guardian-js`\n\n## Source files\n\n*   [Full SDK Version](https://cdn.auth0.com/js/guardian-js/1.3/guardian-js.js)\n    \n*   [Minified SDK Version](https://cdn.auth0.com/js/guardian-js/1.3/guardian-js.min.js)\n    \n*   [Full Guardian API](https://github.com/auth0/auth0-guardian.js#full-api)\n    \n\n## Configure Guardian\n\n```\nvar auth0GuardianJS = require('auth0-guardian-js')({\n\t// For US tenants: https://{name}.guardian.auth0.com\n \t// For AU tenants: https://{name}.guardian.au.auth0.com\n \t// For EU tenants: https://{name}.guardian.eu.auth0.com\n  // For JP tenants: https://{name}.guardian.jp.auth0.com\n\tserviceUrl: \"https://{{ userData.tenant }}.guardian.auth0.com\",\n\trequestToken: \"{{ requestToken }}\", // or ticket: \"{{ ticket }}\" - see below\n\n\tissuer: {\n\t\t// The issuer name to show in OTP Generator apps\n\t\tlabel: \"{{ userData.tenantFriendlyName }}\",\n\t\tname: \"{{ userData.tenant }}\",\n\t},\n\n\t// The account label to show in OTP Generator apps\n\taccountLabel: \"{{ userData.friendlyUserId }}\",\n\n\t// Optional, for debugging purpose only,\n\t// ID that allows to associate a group of requests\n\t// together as belonging to the same \"transaction\" (in a wide sense)\n\tglobalTrackingId: \"{{ globalTrackingId }}\"\n});\n```\n\nUse of `requestToken` or `ticket` depends on the authentication method. Ticket corresponds to a previously generated [enrollment ticket](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets).\n\n### Use a custom domain\n\nIf you have a custom domain configured for your Auth0 tenant, you'll need to update the `serviceUrl` property to point to the Guardian endpoint:\n\n```\nvar auth0GuardianJS = require('auth0-guardian-js')({\n    // For custom domains\n    serviceUrl: \"https://{yourCustomDomain}/guardian/\",\n    ...\n});\n```\n\n## Enroll devices\n\nEnrolling devices consists of the following steps:\n\n1.  Start the transaction.\n    \n2.  (optional) Check if the user is already enrolled. You cannot enroll twice.\n    \n3.  Send the information needed to enroll.\n    \n4.  Confirm enrollment.\n    \n5.  Show the recovery code.\n    \n\nSome steps can be omitted depending on the method. We provide the same interface for all methods so you can write uniform code. Some of the methods complete the authentication, whereas others need an extra authentication step. You can determine that by listening to the `enrollment-complete` event.\n\n```\nfunction enroll(transaction, method) {\n\tif (transaction.isEnrolled()) {\n\t\tconsole.log('You are already enrolled');\n\t\treturn;\n\t}\n\n\tvar enrollData = {};\n\n\tif (method === 'sms') {\n\t\tenrollData.phoneNumber = prompt('Phone number'); // Collect phone number\n\t}\n\n\treturn transaction.enroll(method, enrollData, function (err, otpEnrollment) {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tvar uri = otpEnrollment.getUri();\n\t\tif (uri) {\n\t\t\tshowQR(uri);\n\t\t}\n\n\t\tvar confirmData = {};\n\t\tif (method === 'otp' || method === 'sms') {\n\t\t\tconfirmData.otpCode = prompt('Otp code'); // Collect verification otp\n\t\t}\n\n\t\totpEnrollment.confirm(confirmData);\n\t});\n}\n\nauth0GuardianJS.start(function(err, transaction) {\n\tif (err) {\n\t\tconsole.error(err);\n\t\treturn;\n\t}\n\n\ttransaction.on('error', function(error) {\n\t\tconsole.error(error);\n\t});\n\n\ttransaction.on('timeout', function() {\n\t\tconsole.log('Timeout');\n\t});\n\n\ttransaction.on('enrollment-complete', function(payload) {\n\t\tif (payload.recoveryCode) {\n\t\t\talert('Recovery code is ' + payload.recoveryCode);\n\t\t}\n\n\t\tif (payload.authRequired) {\n\t\t\tshowAuthenticationFor(transaction, payload.enrollment);\n\t\t\treturn;\n\t\t}\n\t});\n\n\ttransaction.on('auth-response', function(payload) {\n\t\tif (payload.recoveryCode) {\n\t\t\talert('The new recovery code is ' + payload.recoveryCode);\n\t\t}\n\n\t\tif (!payload.accepted) {\n\t\t\talert('Authentication has been rejected');\n\t\t\treturn;\n\t\t}\n\n\t\tauth0GuardianJS.formPostHelper('{{ postActionURL }}', { signature: payload.signature });\n\t});\n\n\tvar availableEnrollmentMethods = transaction.getAvailableEnrollmentMethods();\n\n\tmethod = prompt('What method do you want to use, select one of '\n\t\t+ availableEnrollmentMethods.join(', '));\n\n\tenroll(transaction, method) // For sms\n});\n```\n\n## Authenticate\n\nTo authenticate with a method you need to execute the following steps:\n\n1.  Start the transaction.\n    \n2.  (optional) Check if the user is already enrolled. You need to be enrolled to authenticate.\n    \n3.  Request the auth (the push notification or SMS). Request is a noop for OTP.\n    \n4.  Verify the OTP (`.verify` is a noop for push).\n    \n\nSome steps can be omitted depending on the method, we provide the same interface for all methods so you can write uniform code. After the factor is verified or the push accepted you will receive an `auth-response` event with the payload to send to the server, you can use the `auth0GuardianJS.formPostHelper('{{ postActionURL }}', payload)` to post back the message to the server.\n\nYou may also receive `auth-rejected` if the push notification was received.\n\n```\nfunction authenticate(method) {\n\tauth0GuardianJS.start(function (err, transaction) {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!transaction.isEnrolled()) {\n\t\t\tconsole.log('You are not enrolled');\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction.on('error', function(error) {\n\t\t\tconsole.error(error);\n\t\t});\n\n\t\ttransaction.on('timeout', function() {\n\t\t\tconsole.log('Timeout');\n\t\t});\n\n\t\ttransaction.on('auth-response', function(payload) {\n\t\t\tif (payload.recoveryCode) {\n\t\t\t\talert('The new recovery code is ' + payload.recoveryCode);\n\t\t\t}\n\n\t\t\tif (!payload.accepted) {\n\t\t\t\talert('Authentication has been rejected');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tauth0GuardianJS.formPostHelper('{{ postActionURL }}', { signature: payload.signature });\n\t\t});\n\n\t\tvar enrollment = transaction.getEnrollments()[0];\n\n\t\tif (enrollment.getAvailableAuthenticatorTypes().length === 0) {\n\t\t\talert('Somethings went wrong, seems that there is no authenticators');\n\t\t\treturn;\n\t\t}\n\n\t\ttransaction.requestAuth(enrollment, { method: method } function(err, auth) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar data = {};\n\t\t\tif (method === 'sms' || method === 'otp') {\n\t\t\t\tdata.otpCode = prompt('Otp code');\n\t\t\t} else if (method === 'recovery-code') {\n\t\t\t\tdata.recoveryCode = prompt('Recovery code');\n\t\t\t}\n\n\t\t\treturn auth.verify(data);\n\t\t});\n\t});\n}\n```\n\n## Learn more\n\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)",
    "title": "Install Guardian SDK",
    "description": "Describes how to install, configure options, and use the Guardian SDKs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login",
    "markdown": "# Customize MFA Selection for Universal Login\n\nAuth0 supports a variety of factors for securing user access with [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors). Using `post-login` Actions, you can customize your MFA flows to challenge users with a specific factor or sequence of factors. You can also use contextual information about users and their organizations to create more individualized experiences. For example, you can customize your flows to challenge users with specific factors based on their membership in certain Organizations or their assigned user roles.\n\n## How it works\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to customize your MFA flows. Specifically, you can modify the `post-login` trigger of the [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) with the following Authentication API methods:\n\n*   `challengeWith`: Specifies the factor or factors users must use to authenticate, such as a one-time password (OTP). This method presents a default challenge to users and can optionally provide access to a factor picker that allows them to choose a different authentication method.\n    \n*   `challengeWithAny`: Sets a group of factors users can choose from when authenticating, such as email and OTP. By default, this method presents a factor picker to users rather than a specific challenge, in accordance with the following conditions:\n    \n    *   If two or more factors are specified, a factor picker displays to the user.\n        \n    *   If the user has only enrolled in one of the specified factors (or only one factor is supplied), the factor picker is skipped.\n        \n    *   If the user has not enrolled in any of the specified factors, the command fails.\n        \n\nYou can use a combination of these methods to tailor your MFA flows as needed. You can also incorporate user metadata, such as roles or previously used factors, into these methods to create more tailored flows.\n\nWhen choosing MFA challenges for your commands, you can use the factors listed below or the `enrolledFactors` value. `enrolledFactors` represents the list of active factors associated with a user's account.\n\n*   `otp`\n    \n*   `email`\n    \n*   `push-notification`\n    \n    *   `otpFallback`\n        \n*   `phone`\n    \n    *   `preferredMethod: voice`\n        \n    *   `preferredMethod: sms`\n        \n    *   `preferredMethod: both`\n        \n*   `webauthn-platform`\n    \n*   `webauthn-roaming`\n    \n\nThe array `event.authentication.methods` includes a `type` field when the name of the method is set to `mfa`. type is a string that contains factor values matching those used by the `type` field from `enrolledFactors` (listed above). When an MFA challenge is performed, `methods` contains an object of `name:mfa` with `type` set to the factor used for that challenge. `methods` is only updated when an Action begins. To see the results of a challenge, `methods` must be accessed in the next Action in the flow.\n\nTo learn more, review the following resources:\n\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)\n    \n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n    \n\n### Sequenced and contextual flows\n\nWith the `challengeWith` or `challengeWithAny` commands, you can use contextual information to determine the best challenge or series of challenges to present to users. Specifically, you can leverage the following:\n\n*   **Sequenced flows**: Challenge users with a series of different factors in a specific order.\n    \n*   **Contextual flows**: Determine which factor to next challenge the user with based on previous challenges in the flow.\n    \n\nTo help illustrate these flows, consider the following example:\n\n```\n// ACTION 1 \n\nexports.onExecutePostLogin = async (event, api) => {\n\n   api.authentication.challengeWithAny([{ type: 'phone'}, { type: 'push-notification' }]);\n\n} \n\n// ============================================ \n\n// ACTION 2 \n\n// Decide based on what the user did in the previous action \n\nexports.onExecutePostLogin = async (event, api) => { \n\n    if(event.authentication.methods.find(m => m.type === 'phone') && event.authorization?.roles.includes('admin')) { \n\n        api.authentication.challengeWith({ type: 'push-notification' }); \n\n    }\n\n}\n```\n\nIn this scenario, a user is first challenged with SMS via the `challengeWithAny` command in Action 1. Then, Action 2 challenges the user with a push notification because they have the Admin user role and also completed the SMS challenge.\n\nIn this flow, you can make decisions about which factor to challenge the user with due to the following:\n\n1.  The flow pauses after executing Action 1.\n    \n2.  The user completes the MFA flow prompted by Action 1.\n    \n3.  `event.authentication.methods.type` in Action 2 populates with information from the previous MFA challenge.\n    \n4.  The flow resumes to execute Action 2 using contextual information from Action 1.\n    \n\nWhile this example presents a similar experience to using redirects in your Actions, commands using `challengeWith` and `challengeWithAny` offer the following unique benefits:\n\n*   Flows pause after each command, allowing you to accumulate user information that can be used in subsequent Actions. Comparatively, redirects only occur a single time as the final command in a flow.\n    \n*   MFA is triggered after each Action containing `challengeWith` or `challengeWithAny` commands is executed. With redirects, MFA runs as the final Action in the pipeline.\n    \n\n**Note**: This method of executing Actions only applies to those containing `challengeWith` or `challengeWithAny` commands. Actions serving other purposes are not affected.\n\n## Before you begin\n\nBefore you can customize your MFA flows, you must first enable MFA in your tenant and prompt your users to enroll in the appropriate factors.\n\n### Prepare your tenant\n\nTo get started, set up MFA in your tenant and enable the Customize MFA Factors using Actions setting. You can set up one or more factors and define your MFA policies on the Auth0 Dashboard under [Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa).\n\n*   To learn more about the setup process, review [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n*   For information about configuring specific factors, review [Multi-factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n\nTo customize your flows, you **must enable** the Customize MFA Factors using Actions toggle in the Additional Settings section. Your customized flows will not work properly if this setting is not enabled.\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Additional Settings](https://images.ctfassets.net/cdy7uua7fh8z/2hv0ELTkkka3t230SXfxw/46def5395652b2451cfc9e0ad01a371a/MFA_actions.png)\n\n### Enroll users in factors\n\nOnce MFA is configured, ensure your users enroll in one or more of the factors you enabled. Users must enroll in authenticators before they can be challenged by `post-login` Action commands.\n\nAfter a user signs up or is created in your tenant, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint, or you can manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n\n## Customize your MFA flows\n\nOnce your tenant is ready, you can create `post-login` Actions to customize your MFA flows. Steps and example use cases are provided below.\n\n### Create your post-login Action\n\n1.  On your Auth0 Dashboard, navigate to [Actions > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**.\n    \n2.  Under Add Action, select **Custom** and choose **Create Action**.\n    \n3.  On the Create Action popup:\n    \n    *   Enter a name for your Action.\n        \n    *   Select **Login / Post-Login** as the trigger.\n        \n    *   Use **Node 18 (Recommended)** for the runtime.\n        \n4.  Review the popup to ensure accuracy. Then, select **Create**.\n    \n5.  After creation, the code editor displays the `onPostExecute` command. Add your custom code or code sample to the command.\n    \n6.  When your command is ready, select **Deploy**.\n    \n7.  Select **Add to Flow** on the successful deployment notification.\n    \n    *   **Note**: If the notification has closed, choose **Back to Flow** above the code editor.\n        \n8.  Drag and drop your new command from the Add Action panel into your Login flow. Then, select **Apply**.\n    \n\nTo make additional updates to your Action, navigate to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your command. You can then update and redeploy your code as needed.\n\n### Test your post-login Action\n\nTo ensure your commands function appropriately, you can test your Action through the Auth0 Dashboard:\n\n*   Navigate to [Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n*   Select **Try** to open a sample login prompt in a new tab.\n    \n*   Enter your credentials and test your new MFA flow.\n    \n\nIf the flow is successful, a confirmation screen displays. If you encounter any issues, you can update your code by navigating to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) on your Auth0 Dashboard.\n\n## Example use cases\n\nThe examples below outline common use cases for customizing MFA flows.\n\n### Use current enrollments to determine challenge method\n\nThe following sample challenges a user with MFA if they are enrolled with the following factors:\n\n*   One-time password (OTP)\n    \n*   Phone\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n api.authentication.challengeWithAny([{type: 'otp'}, {type: 'phone'}]);\n\n}\n```\n\n### Use roles to determine challenge method\n\nThe following sample challenges all users with OTP. If a user has the Admin role and requires a higher level of access to your application, they are challenged with an additional factor as a form of [step-up authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication).\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    api.authentication.challengeWith({type: 'otp'});\n\n    const isAdmin = event.authorization?.roles.includes('admin');\n    if(isAdmin) {\n        api.authentication.challengeWith({type: 'phone'});\n    }\n}\n```\n\n### Use metadata to determine challenge method\n\nIn this example, MFA factors are enabled at the [Organization](https://auth0.com/docs/manage-users/organizations) level. This sample uses different categories of metadata to determine the right challenge for individual users:\n\n*   **Organization metadata**: Organization-level data, such as the specific factors enabled for an Organization.\n    \n*   **User metadata**: User-level data, such as whether a user has a phone number associated with their profile.\n    \n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const orgFactors = event.organization.metadata.factors ?? [];\n\n  // Get the intersection of factors available for the user and factors enabled for the org\n  const availableFactors = orgFactors.filter(f => event.user.enrolledFactors.some(ef => ef.type === f));\n\n  // Prefer push if available\n  if(availableFactors.includes('push-notification')) {\n    api.authentication.challengeWith({ type: 'push-notification' });\n    return;\n  }\n\n  // If the user has a verified phone number and the organization\n  // allows for SMS and email, prefer SMS and allow email as a fallback\n  // if available\n  if(event.user.phone_number && \n     event.user.phone_verified && \n     availableFactors.includes('phone')) {\n    if(availableFactors.includes('email') {\n      api.authentication.challengeWith({ type: 'phone' }, {\n        additionalFactors: [{\n          type: 'email'\n        }]\n      });\n    } else {\n      api.authentication.challengeWith({ type: 'phone' });\n    }\n\n    return;\n  }\n\n  // If push-notifications and/or phone couldn't be prioritized, fallback to email if\n  // enabled for the org, otherwise fail.\n  if(availableFactors.includes('email') {\n    api.authentication.challengeWith({ type: \"email\" });\n    return;\n  }\n\n  api.access.deny(\"No MFA factors available for this org + user\");\n};\n```\n\n### Allow users to select an alternate method of authentication\n\nFor a more flexible experience, you can present users with a **Try Another Method** link as part of their MFA challenge. This link allows users to select a different method of authentication than the default challenge.\n\nTo achieve this, include the `additionalFactors` parameter in your Actions code. You can set this parameter to a specific factor for all users or use `enrolledFactors` to let users choose their preferred factor.\n\n**Specific Factor**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with email instead.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: [{type: 'email'}] })\n};\n```\n\n**Enrolled Factors**\n\nThe following sample challenges users with OTP by default. If desired, users can access the Try Another Method link to authenticate with one of their other enrolled factors.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n\n  api.authentication.challengeWith({ type: 'otp' }, \n    { additionalFactors: enrolledFactors })\n};\n```\n\n### Use Adaptive MFA to determine when to challenge users\n\nThe following example uses [Adaptive MFA](https://auth0.com/docs/get-started/auth0-teams/tenant-management) to determine if users should be challenged.\n\nAdaptive MFA is a flexible MFA policy that protects your tenant from bad actors by assessing potential risk during login transactions and prompting users for additional verification when appropriate.\n\nIn this case, users are prompted with MFA if they log in from an unrecognized device and their overall confidence score is low or medium.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication?.riskAssessment?.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.enrolledFactors?.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      const enrolledFactors = event.user.enrolledFactors.map((f) => ({type: f.type}));\n      api.authentication.challengeWithAny(enrolledFactors);\n    }\n\n  }\n\n};\n```\n\n### Use Actions to challenge users\n\nYou can use Actions to customize MFA flows by modifying the `post-login` trigger of the Login Flow. This example uses the `phone` method of authentication and `preferredMethod: 'both'`, referring to the active MFA factors associated with a user's account. For more information, refer to [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n```\napi.authentication.challengeWith({ \n  type: 'phone', \n  options: { preferredMethod: 'both'} \n});\n```\n\n## Troubleshooting\n\nIn the event that you experience errors or unexpected results from your customized MFA flows, you can use the information below to help identify and resolve these issues.\n\n### Tenant logs\n\nYou can monitor your customized MFA flows through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nTenant logs are available on the Auth0 Dashboard under [Monitoring > Logs](https://manage.auth0.com/#/logs). Alternatively, you can retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/introduction).\n\nIf you or your users experience unexpected behavior, review tenant logs for the following event codes for more information:\n\n| Scenario | Event Code | Descriptive Error |\n| --- | --- | --- |\n| A user is prompted with multi-factor authentication, but none of the requested factors can be used as a challenge. In this case, the user cannot complete MFA. | mfar | This scenario results in the following error message:<br><br>An MFA challenge is used in a PostLogin action but the requested factors are not properly set up. To perform MFA, enable the requested factors and ensure the user is enrolled with them. |\n| A user is prompted with multi-factor authentication, but one of the requested factors cannot be used as a challenge. In this case, the user can complete MFA using a different requested factor. | w   | This scenario results in the following warning message:<br><br>An MFA challenge is used in a PostLogin action, but the requested factor {factor name} is not properly set up. Enable the requested factor and ensure the user is enrolled with it. |\n\n### Troubleshooting checklist\n\nThe following checklist provides additional suggestions for identifying and resolving common issues with customized MFA flows.\n\n1.  The **Customize MFA factors with Actions** toggle must be enabled.\n    \n    *   Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure the toggle in the Additional Settings section is enabled.\n        \n2.  Factors referenced in your Actions must be enabled in your tenant.\n    \n    *   **Review your code**: Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and review your Actions code. Ensure all factors referenced are applicable to your use cases.\n        \n    *   **Review your factors**: Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure all factors referenced in your Actions are enabled.\n        \n3.  Users must be enrolled in the factors referenced in your Actions.\n    \n    *   If an individual receives an error, review their user details to ensure they are enrolled in the proper factors. Navigate to [**Auth0 Dashboard > User Management > Users**](https://manage.auth0.com/#/users) and select their name from the list.\n        \n        *   Review the Multi-factor Authentication section on the **Detail tab** to verify their enrollments. If the user is not enrolled, you can use the **Send an enrollment invitation** link available in this section.\n            \n        *   Alternatively, verify the user's enrollments through the **Raw JSON tab**. This information can also be retrieved using the [Management API](https://auth0.com/docs/api/management/v2/users/get-authentication-methods). However, it is important to note that the API does not list auto-enrolled authenticators, such as Email factors set up via an email verification link.\n            \n    *   If users are not enrolled in the appropriate factors, you can create enrollments with the Management API [authentication-methods](https://auth0.com/docs/api/management/v2/users/post-authentication-methods) endpoint. You can also manage users' enrollments directly through their profile pages in the Auth0 Dashboard.\n        \n4.  Ensure your Actions have been deployed and saved in your Pipeline.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library). Locate your Action in the list and ensure its status is **Deployed**. If a different status is listed, access your Action, review your code, and click **Deploy** to the top right.\n        \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**. Ensure your Action is listed in the flow. If not, access the **Custom tab** of the Add Action panel and drag and drop your Action into your Login flow. Then, select **Apply**.\n        \n5.  Ensure you've upgraded to the latest version of `post-login` Actions.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. If your Action is out-of-date, you will see a yellow banner prompting you to update the Action. If the banner displays, select **Update**.\n        \n    *   You can also specify the latest version of `post-login` Actions for deployment when using the Deploy CLI. For more information, review [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
    "title": "Customize MFA Selection for Universal Login",
    "description": "Customize MFA flows using post-login Actions to challenge users with specific factors or sequences of factors. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa",
    "markdown": "# Enable Adaptive MFA\n\n#### Before you start\n\n*   Subscribe to an Enterprise Plan with the Adaptive MFA addon. Refer to [Auth0 Pricing](https://auth0.com/pricing/) for details.\n    \n*   Configure and enable a Database or Active Directory connection.\n    \n*   Configure and enable at least one MFA factor.\n    \n\nUse Adaptive MFA to trigger MFA when Auth0 determines that an attempted login is risky and to record risk assessments for all login transactions in your tenant logs.\n\n## Enable Adaptive MFA\n\nYou can enable Adaptive MFA in the Auth0 Dashboard or with the Auth0 Management API.\n\n1\\. Go to [**Dashboard > Security > Multi-factor Auth**](https://manage.auth0.com/#/security/mfa).\n\n![Auth0 Dashboard Security Multi-factor Auth Adaptive MFA Policy](https://images.ctfassets.net/cdy7uua7fh8z/4IlQi0LXOPJdYjOuo09xtE/3fb8f8eeb850dde8c9c875074ea2ebfb/Screen_Shot_2021-07-06_at_12.57.04_PM.png)\n\n2\\. In the **Factors** section, enable and configure at least one MFA Factor. To learn more, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\n3\\. In the **Define policies** section, locate **Require Multi-factor Auth**, and then select **Use Adaptive MFA**. Risk assessment will automatically be enabled and recorded in your tenant logs.\n\n4\\. Click **Save**.\n\n## Enable Adaptive MFA Risk Assessment\n\nIf you aren't ready to enable Adaptive MFA, but want to start training it to analyze login behavior, you can enable Adaptive MFA Risk Assessment independently.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n2.  Locate the **Define policies** section.\n    \n3.  In **MFA Risk Assessors**, select **Enable Adaptive MFA Risk Assessment**.\n    \n4.  Select **Save**.\n    \n\n## Customize Adaptive MFA\n\nYou can customize the behavior of Adaptive MFA to provide the best experience for your users while ensuring security. To learn more, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa).\n\n## Limitations\n\nAssessment information in tenant logs is only available for interactive flows. Auth0 does not support recording assessment information for Resource Owner Password Grant (ROPG) flows without adaptive MFA enabled. For more information about authentication flow limitations, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n## Learn more\n\n*   [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)",
    "title": "Enable Adaptive MFA",
    "description": "Learn how to enable Adaptive MFA for low confidence logins based on Auth0's risk assessment and overall confidence scores. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api",
    "markdown": "# Manage Authentication Factors with Authentication API\n\nAuth0 provides several [API endpoints](https://auth0.com/docs/api/authentication#multi-factor-authentication) to help you manage the authenticators you're using with an application for multi-factor authentication (MFA). You can use these endpoints to build a complete user interface for letting users manage their authenticator factors.\n\n## Get MFA API access tokens\n\nTo call the MFA API to manage enrollments, you first need to obtain an access token for the MFA API.\n\nTo use the MFA API as part of an authentication flow, you can follow the steps detailed in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa). If you are building a user interface to manage authentication factors, you'll need to obtain a token you can use for the MFA API at any moment, not only during authentication.\n\n### Universal Login\n\nIf you are using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), redirect to the Authorize endpoint, specifying the `https://{yourDomain}/mfa/` audience, before using calling the MFA API.\n\n### Resource owner password grant\n\nIf you are using the Resource Owner Password Grant (ROPG), you have 3 options:\n\n*   Ask for the `https://{yourDomain}/mfa/` audience when logging-in, and use a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens) to refresh it later.\n    \n*   If you need to list and delete authenticators, ask the user to [authenticate again](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) with `/oauth/token`, specifying the `https://{yourDomain}/mfa/` audience. Users will need to complete MFA before being able to list and/or delete authentication factors.\n    \n*   If you only need to list authenticators, ask the user to [authenticate again](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) using `/oauth/token` with username/password. The endpoint will return an `mfa_required` error, and an `mfa_token` you can use to list authenticators. Users will need to provide their password to see their authenticators.\n    \n\n### Scopes\n\nWhen you request a token for the MFA audience, you can request the following scopes:\n\n| Scope | Description |\n| --- | --- |\n| `enroll` | To enroll a new authenticator. |\n| `read:authenticators` | To list existing authenticators. |\n| `remove:authenticators` | To delete an authenticator. |\n\n## List authenticators\n\nTo get a list of the authenticators for a user, you can call the MFA Authenticators endpoint:\n\n*   [cURL](#372b2f0fcacb45409052d6d1f05bdbfe_shell)\n*   [C#](#372b2f0fcacb45409052d6d1f05bdbfe_csharp)\n*   [Go](#372b2f0fcacb45409052d6d1f05bdbfe_go)\n*   [Java](#372b2f0fcacb45409052d6d1f05bdbfe_java)\n*   [Node.JS](#372b2f0fcacb45409052d6d1f05bdbfe_node)\n*   [Obj-C](#372b2f0fcacb45409052d6d1f05bdbfe_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MFA_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MFA_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou should receive information about the authenticator type(s) in the response:\n\n```\n[\n  {\n    \"authenticator_type\": \"recovery-code\",\n    \"id\": \"recovery-code|dev_IsBj5j3H12VAdOIj\",\n    \"active\": true\n  },\n  {\n    \"authenticator_type\": \"otp\",\n    \"id\": \"totp|dev_nELLU4PFUiTW6iWs\",\n    \"active\": true,\n  },\n  {\n    \"authenticator_type\": \"oob\",\n    \"oob_channel\": \"sms\",\n    \"id\": \"sms|dev_sEe99pcpN0xp0yOO\",\n    \"name\": \"+1123XXXXX\",\n    \"active\": true\n  }\n]\n```\n\nFor the purposes of building a user interface for end users to manage their factors, you should ignore authenticators that have `active` as `false`. Those authenticators are not confirmed by users, so they can't be used to challenge for MFA.\n\nThe MFA API will list the following enrollments depending on the authenticator type:\n\n| Authenticator | Actions |\n| --- | --- |\n| **Push and OTP** | If push is enabled, Auth0 also creates an OTP enrollment. You will see both when listing enrollments. |\n| **SMS and Voice** | If both SMS and voice are enabled, when a user enrolls with either SMS or voice, Auth0 automatically creates two authenticators for the phone number, one for SMS and another for voice. |\n| **Email** | All verified emails will be listed as authenticators. |\n\n## Enroll authenticators\n\nSee the following links for details on how to enroll authenticators for different factors:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\nYou can also use the [Universal Login flow](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) for enrolling users at any time.\n\n## Delete authenticators\n\nTo delete an associated authenticator, send a `DELETE` request to the MFA Authenticators endpoint replacing the `AUTHENTICATOR_ID` with the relevant authenticator ID. You can get the ID when you list authenticators.\n\nIf an `mfa_token` was used to list authenticators, users will need to [complete MFA to obtain an access token](https://auth0.com/docs/api/authentication#verify-with-one-time-password-otp-) with an audience of `https://{yourDomain}/mfa/` in order to delete an authenticator.\n\n*   [cURL](#1a7e49cf80394260b5ab2e77dacf0b9d_shell)\n*   [C#](#1a7e49cf80394260b5ab2e77dacf0b9d_csharp)\n*   [Go](#1a7e49cf80394260b5ab2e77dacf0b9d_go)\n*   [Java](#1a7e49cf80394260b5ab2e77dacf0b9d_java)\n*   [Node.JS](#1a7e49cf80394260b5ab2e77dacf0b9d_node)\n*   [Obj-C](#1a7e49cf80394260b5ab2e77dacf0b9d_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \\\n  --header 'authorization: Bearer ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',\n  headers: {authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the authenticator was deleted, a 204 response is returned.\n\nWhen you delete an authenticator, the following actions take place depending on the authenticator type:\n\n| Authenticator | Action |\n| --- | --- |\n| **Push and OTP** | When a user enrolls a push authenticator, Auth0 also enrolls OTP. If you delete either of them, the other one will also be deleted. |\n| **SMS and Voice** | When a user enrolls in either SMS or Voice,. Auth0 creates two authenticators, SMS and voice. If you delete either of them, the other will will also be deleted. |\n| **Email** | All verified emails listed as authenticators, but you can't delete them. You can only delete email authenticators that are enrolled explicitly. |\n\n## Regenerate recovery codes\n\nTo delete a recovery code and generate a new one, get an Auth0 [Management API access token](https://auth0.com/docs/api/management/v2/tokens) and use the Management API [Recovery Code Regeneration endpoint](https://auth0.com/docs/api/management/v2/#!/Users/post_recovery_code_regeneration).\n\n*   [cURL](#9bfe8a485a2a467ba5165623251ad014_shell)\n*   [C#](#9bfe8a485a2a467ba5165623251ad014_csharp)\n*   [Go](#9bfe8a485a2a467ba5165623251ad014_go)\n*   [Java](#9bfe8a485a2a467ba5165623251ad014_java)\n*   [Node.JS](#9bfe8a485a2a467ba5165623251ad014_node)\n*   [Obj-C](#9bfe8a485a2a467ba5165623251ad014_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration' \\\n  --header 'authorization: Bearer MANAGEMENT_API_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")\n  .header(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration',\n  headers: {authorization: 'Bearer MANAGEMENT_API_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MANAGEMENT_API_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MANAGEMENT_API_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MANAGEMENT_API_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MANAGEMENT_API_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MANAGEMENT_API_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a new recovery code that the end user will need to capture, for example:\n\n```\n{  \n   \"recovery_code\": \"FA45S1Z87MYARX9RG6EVMAPE\"\n}\n```\n\n## Learn more\n\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)",
    "title": "Manage Authentication Factors with Authentication API",
    "description": "Describes how to manage MFA authenticator factor enrollments for applications using the Auth0 MFA API. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-rules",
    "markdown": "# Customize Adaptive MFA\n\nYou can customize Adaptive MFA for a variety of scenarios with [Auth0 Actions](https://auth0.com/docs/customize/actions).\n\n## When to customize Adaptive MFA\n\nIf your users are not enrolled in MFA, you should use the default policy for Adaptive MFA. If a user is not enrolled in MFA and your Action assesses a high risk, you have limited options to stop a bad actor.\n\nBefore you begin to customize Adaptive MFA, ask yourself a few questions:\n\n*   At what confidence level do you want to trigger MFA?\n    \n*   How do you want to measure risk?\n    \n*   Do you want Auth0 to measure confidence or do you want a custom measurement?\n    \n*   How will you handle users who are not enrolled in MFA?\n    \n\n## Evaluate confidence\n\nAdaptive MFA calculates an overall confidence score based on the analysis of three assessments. Each assessment has its own confidence score. To learn more, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n### Confidence scores\n\nConfidence scores and their associated actions are described below:\n\n| **Confidence score** | **Description** | **Action** |\n| --- | --- | --- |\n| `low` | Login transaction does not match patterns previously displayed by user. | Require MFA. |\n| `medium` | Login transaction somewhat matches patterns previously displayed by user. | Do not require MFA. |\n| `high` | Login transaction closely matches patterns previously displayed by user. | Do not require MFA. |\n| `neutral` | N/A. Reserved for future use. | N/A. Reserved for future use. |\n\n### Custom confidence scoring\n\nIf you want to implement your own method for evaluating the overall confidence score of different scenarios, you can use the data available in the [riskAssessment](#riskassessment-context-object) object.\n\nRead the examples below to learn how Adaptive MFA would score the confidence of different use cases.\n\n#### Examples of high-risk, low-confidence scenarios\n\nThe following table describes high-risk scenarios that result in a `low` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | Do not require MFA | N/A (user already enrolled) | Use an Action to bypass MFA |\n| Not enrolled in MFA | Require email verification | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | Require email verification | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n#### Examples of low-risk, high-confidence scenarios\n\nThe following table describes low-risk scenarios that result in a `high` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | No friction | N/A (user already enrolled) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n### riskAssessment object\n\nThe `riskAssessment` object contains the overall confidence score, versioning information, and details of the individual assessments.\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Overall confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `version` | Version identifier of risk assessment API. | string | `1` |\n| `assessments` | Object containing individual assessment details. | object | Read [assessments object](#assessments-object) |\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && event.authentication.riskAssessment) {\n    event.authentication.riskAssessment = {\n      confidence: 'low' | 'medium' | 'high' | 'neutral',\n      version: '1',\n      assessments: {\n        UntrustedIP: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'not_found_on_deny_list' | 'found_on_deny_list',\n          details: { // only if 'found_on_deny_list'\n            ip: '192.168.1.1',\n            matches: '192.168.0/64',\n            source: 'firehol',\n            category: 'abuse'\n          }\n        },\n        NewDevice: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'match' | 'partial_match' | 'no_match',\n          details: {\n            device: 'known' | 'unknown',\n            useragent: 'known' | 'unknown',\n          }\n        },\n        ImpossibleTravel: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'missing_geoip', | 'anonymous_proxy' | 'unknown_location' | 'initial_login' | 'location_history_not_found' | 'invalid_travel' | 'minimal_travel_from_last_login' | 'impossible_travel_from_last_login' | 'substantial_travel_from_last_login' | 'travel_from_last_login'\n        } \n      },\n       PhoneNumber: {\n          code: \"requires_verification | ok\",\n          confidence: \"low | medium | high | neutral\",\n          details: {\n\t        \tlineType: \"FIXED_LINE | MOBILE | FIXED_LINE_OR_MOBILE | TOLL_FREE | PREMIUM_RATE | SHARED_COST | VOIP | PERSONAL_NUMBER | PAGER | UAN | UNKNOWN\"\n\t            isValid: true | false,\n\t\t        countryCode: 1,\n\t\t        number: \"+12223334444\"\n        }\n      }\n    };\n  }\n}\n```\n\n### assessments object\n\nThe `assessments` object contains details of the three individual risk assessments:\n\n1.  [NewDevice assessment](#newdevice-assessment)\n    \n2.  [ImpossibleTravel assessment](#impossibletravel-assessment)\n    \n3.  [UntrustedIP assessment](#untrustedip-assessment)  \n    \n4.  [PhoneNumber assessment](#phonenumber-assessment)\n    \n\nEach assessment includes a [confidence score](#confidence-scores), a code that describes the evaluation result, and additional contextual information.\n\n#### NewDevice assessment\n\nThe `NewDevice` assessment determines if the user is logging in from a known device and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `match`, `partial_match`, `no_match`, `initial_login`, `unknown_device`, `no_device_history`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### NewDevice assessment code property\n\nThe `NewDevice` assessment `code` property equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `match` | The property values of the `details` object are equivalent. |\n| `partial_match` | The property values of the `details` object are similar. |\n| `no_match` | The property values of the `details` object are different. |\n| `initial_login` | The user logged in for the first time on the device. |\n| `unknown_device` | Auth0 was unable to attain metadata for the device. |\n| `no_device_history` | There is no login history associated with the device. |\n| `assessment_not_available` | Auth0 could not perform an assessment of the device. |\n\n##### NewDevice assessment details object\n\nIf the `code` property value equals `match`, `partial_match`, or `no_match`, the `NewDevice` assessment contains the `details` object with the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `device` | Device of the user. | string | `known`, `unknown` |\n| `useragent` | User agent of the user. | string | `known`, `unknown` |\n\n#### ImpossibleTravel assessment\n\nThe `ImpossibleTravel` assessment determines if the user is logging in from a location that would indicate impossible travel and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `minimal_travel_from_last_login`, `travel_from_last_login`, `substantial_travel_from_last_login`, `impossible_travel_from_last_login`, `invalid_travel`, `mission_geoip`, `anonymous_proxy`, `unknown_location`, `initial_login`, `location_history_not_found`, `assessment_not_available` |\n\n#### UntrustedIP assessment\n\nThe `UntrustedIP` assessment determines if the user’s IP address is present in Auth0’s repository of low-reputation IP addresses (“deny list”) and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `not_found_on_deny_list`, `found_on_deny_list`, `invalid_ip_address`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### UntrustedIP assessment details object\n\nIf the `UntrustedIP` assessment `code` property value equals `found_on_deny_list`, the `details` object is present and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `ip` | IP address of the device. | string | Any valid IPv4 or IPv6 address. |\n| `matches` | Subnet mask that IP address belongs to. | string | Any valid IPv4 or IPv6 subnet mask. |\n| `source` | Name of threat intelligence source for the deny list. | string | Any valid text. |\n| `category` | Category indicating why IP address is untrusted. | string | `abuse`, `anonymizer`, `datacenter`, `reputation`, `unroutable` |\n\n##### UntrustedIP assessment details object category property\n\nThe `UntrustedIP` assessment `details` object `category` property describes the general reason why Adaptive MFA considers a given IP address untrusted and equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `abuse` | IP address exhibited abusive behaviors or was found to be member of bot nets. |\n| `anonymizer` | IP address belongs to anonymizing services such as VPN providers, open proxies, and TOR exit nodes. |\n| `datacenter` | IP address belongs to cloud hosting providers and colocation datacenters. |\n| `reputation` | IP address has a poor reputation score based on activity. |\n| `unroutable` | IP address is not in any range allocated or delegated by any authorized Internet registry or allowed for public use. |\n\n#### PhoneNumber assessment\n\nThe `PhoneNumber` assessment assesses the risk of a phone number for an incoming transaction and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `code` | Describes the evaluation result. | string | `ok`, `requires_verification`, `phone_number_not_provided`, `assessment_not_available` |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### PhoneNumber assessment details object\n\nThe `PhoneNumber` assessment `details` object contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `lineType` | Type of phone line | string | `FIXED_LINE`, `MOBILE`, `FIXED_LINE_OR_MOBILE`, `TOLL_FREE`, `PREMIUM_RATE`, `SHARED_COST`, `VOIP`, `PERSONAL_NUMBER`, `PAGER`, `UAN`, `UNKNOWN` |\n| `isValid` | Returns the validity of the number | boolean | `true`, `false` |\n| `countryCode` | Country code of the phone origin | integer | `0-999` |\n| `number` | Phone number | string | Valid number including `countryCode` |\n\n## Action result outcomes\n\nIf any of your Actions trigger MFA based on confidence score, the default Adaptive MFA policy triggers MFA when the confidence score is `low`.\n\nThe following table shows the possible outcomes based on the combination of Actions and default Adaptive MFA policy actions.\n\n| **Action result** | **Adaptive MFA action** | **Outcome** |\n| --- | --- | --- |\n| Unauthorized | Trigger MFA | Unauthorized |\n| Unauthorized | No MFA Required | Unauthorized |\n| Trigger MFA | Trigger MFA | Trigger MFA |\n| Trigger MFA | No MFA Required | Trigger MFA |\n| No MFA Required | Trigger MFA | Trigger MFA |\n| No MFA Required | No MFA Required | No MFA Required |\n\n## Action templates\n\nAuth0 provides two Action templates based on Adaptive MFA for you to customize: [Adaptive MFA](#adaptive-mfa) and [Require MFA Enrollment](#require-mfa-enrollment).\n\n### Adaptive MFA template\n\nThis template provides an example and starting point for how to build a custom business flow using individual risk assessments.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && \n      event.authentication.riskAssessment && \n      event.authentication.riskAssessment.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.multifactor && event.user.multifactor.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      api.multifactor.enable('any', { allowRememberBrowser: true });\n    }\n  }\n};\n```\n\n### Require MFA Enrollment template\n\nThis template demonstrates how you could enforce MFA enrollment when using a standard or Adaptive MFA policy. It uses `event.user.multifactor` to check if the user is enrolled in MFA, and if they’re not, prompts for enrollment.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.user.multifactor || event.user.multifactor.length == 0) {\n    api.multifactor.enable('any', { allowRememberBrowser: true });\n  }\n};\n```\n\n## Action use cases\n\nHere are some suggestions for how to build custom Actions based on your use case.\n\n### Perform an action if overall confidence score is X\n\nAssess the `riskAssessment.confidence` property, and then compare it with the constants `high`, `medium`, or `low`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMedium = riskAssessment && riskAssessment.confidence === 'medium';\n\n  if (riskIsMedium) {\n    // ....\n  }\n}\n```\n\n### Perform an action if confidence score is above or below X\n\nConfidence scores are discrete values—not in a range—so you cannot use comparison operators (such as `<` or `>`) to evaluate multiple values in a single condition.\n\nUse multiple conditions to logically combine all the confidence scores you want to handle. For example, if you want to know when the confidence score is greater than `low`, check if it’s equal to `medium` or `high`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMediumOrHigh = riskAssessment && \n                                  (riskAssessment.confidence === 'high' || \n                                   riskAssessment.confidence === 'medium');\n\n  if (riskIsMediumOrHigh) {\n    // ...\n  }\n}\n```\n\n### Get additional details if overall confidence score is X\n\nThe `riskAssessment` object is saved in your tenant logs. You can view log entries to see the risk assessment score and the determining factors (reasons).\n\nYou can view the `riskAssessment` object and report the results elsewhere. For example, you can send an email or save a record in an external database.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsLow = riskAssessment && riskAssessment.confidence === 'low';\n\n  if (riskIsLow) {\n    // log(externalDatabase, riskAssessment);\n  }\n}\n```\n\n### Perform an action if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    // ...\n  }\n}\n```\n\n### Aggregate assessments for a custom overall confidence score.\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, and then use the `confidence` property, the `code` property, or both.\n\nTo learn more about custom confidence scoring, read [Custom confidence scoring](#custom-confidence-scoring).\n\n### Block current transaction and return error and message if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property.\n\nBlock the login transaction from completing by returning the callback function with an `UnauthorizedError` object as the [error parameter](https://auth0.com/docs/troubleshoot/error-handling-best-practices). The `UnauthorizedError` object always sets `error` to `unauthorized`, but you can customize the `error_message`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    return api.access.deny('Login blocked due to impossible travel detected.')\n  }\n}\n```\n\nThis redirects the user back to the application's callback URL with the `error` and `error_message` parameters included.\n\n### Safely handle when Auth0 fails to execute assessments\n\nAuth0 automatically assigns a `low` confidence score if there is any sort of failure performing the risk assessment.\n\nTo mitigate this scenario, use the [assessments](#assessments-object) object to inspect the `code` property for each individual assessment and check if the value is set to `assessment_not_available`.\n\n## Learn more\n\n*   [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)",
    "title": "Customize Adaptive MFA",
    "description": "Learn how to customize Adaptive Multi-Factor Authentication (MFA).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa",
    "markdown": "# Customize Adaptive MFA\n\nYou can customize Adaptive MFA for a variety of scenarios with [Auth0 Actions](https://auth0.com/docs/customize/actions).\n\n## When to customize Adaptive MFA\n\nIf your users are not enrolled in MFA, you should use the default policy for Adaptive MFA. If a user is not enrolled in MFA and your Action assesses a high risk, you have limited options to stop a bad actor.\n\nBefore you begin to customize Adaptive MFA, ask yourself a few questions:\n\n*   At what confidence level do you want to trigger MFA?\n    \n*   How do you want to measure risk?\n    \n*   Do you want Auth0 to measure confidence or do you want a custom measurement?\n    \n*   How will you handle users who are not enrolled in MFA?\n    \n\n## Evaluate confidence\n\nAdaptive MFA calculates an overall confidence score based on the analysis of three assessments. Each assessment has its own confidence score. To learn more, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n### Confidence scores\n\nConfidence scores and their associated actions are described below:\n\n| **Confidence score** | **Description** | **Action** |\n| --- | --- | --- |\n| `low` | Login transaction does not match patterns previously displayed by user. | Require MFA. |\n| `medium` | Login transaction somewhat matches patterns previously displayed by user. | Do not require MFA. |\n| `high` | Login transaction closely matches patterns previously displayed by user. | Do not require MFA. |\n| `neutral` | N/A. Reserved for future use. | N/A. Reserved for future use. |\n\n### Custom confidence scoring\n\nIf you want to implement your own method for evaluating the overall confidence score of different scenarios, you can use the data available in the [riskAssessment](#riskassessment-context-object) object.\n\nRead the examples below to learn how Adaptive MFA would score the confidence of different use cases.\n\n#### Examples of high-risk, low-confidence scenarios\n\nThe following table describes high-risk scenarios that result in a `low` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | Do not require MFA | N/A (user already enrolled) | Use an Action to bypass MFA |\n| Not enrolled in MFA | Require email verification | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | Require email verification | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n#### Examples of low-risk, high-confidence scenarios\n\nThe following table describes low-risk scenarios that result in a `high` confidence score:\n\n| **User State** | **Desired Login Friction** | **Desired Enrollment Policy** | **Implementation** |\n| --- | --- | --- | --- |\n| Enrolled in MFA | No friction | N/A (user already enrolled) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Skip enrollment (do not collect additional authenticators) | Default behavior (no MFA-related Action) |\n| Not enrolled in MFA | No friction | Require MFA enrollment (collect additional authenticator) | Use an Action to force MFA enrollment (template available) |\n\n### riskAssessment object\n\nThe `riskAssessment` object contains the overall confidence score, versioning information, and details of the individual assessments.\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Overall confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `version` | Version identifier of risk assessment API. | string | `1` |\n| `assessments` | Object containing individual assessment details. | object | Read [assessments object](#assessments-object) |\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && event.authentication.riskAssessment) {\n    event.authentication.riskAssessment = {\n      confidence: 'low' | 'medium' | 'high' | 'neutral',\n      version: '1',\n      assessments: {\n        UntrustedIP: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'not_found_on_deny_list' | 'found_on_deny_list',\n          details: { // only if 'found_on_deny_list'\n            ip: '192.168.1.1',\n            matches: '192.168.0/64',\n            source: 'firehol',\n            category: 'abuse'\n          }\n        },\n        NewDevice: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'match' | 'partial_match' | 'no_match',\n          details: {\n            device: 'known' | 'unknown',\n            useragent: 'known' | 'unknown',\n          }\n        },\n        ImpossibleTravel: {\n          confidence: 'low' | 'medium' | 'high' | 'neutral',\n          code: 'missing_geoip', | 'anonymous_proxy' | 'unknown_location' | 'initial_login' | 'location_history_not_found' | 'invalid_travel' | 'minimal_travel_from_last_login' | 'impossible_travel_from_last_login' | 'substantial_travel_from_last_login' | 'travel_from_last_login'\n        } \n      },\n       PhoneNumber: {\n          code: \"requires_verification | ok\",\n          confidence: \"low | medium | high | neutral\",\n          details: {\n\t        \tlineType: \"FIXED_LINE | MOBILE | FIXED_LINE_OR_MOBILE | TOLL_FREE | PREMIUM_RATE | SHARED_COST | VOIP | PERSONAL_NUMBER | PAGER | UAN | UNKNOWN\"\n\t            isValid: true | false,\n\t\t        countryCode: 1,\n\t\t        number: \"+12223334444\"\n        }\n      }\n    };\n  }\n}\n```\n\n### assessments object\n\nThe `assessments` object contains details of the three individual risk assessments:\n\n1.  [NewDevice assessment](#newdevice-assessment)\n    \n2.  [ImpossibleTravel assessment](#impossibletravel-assessment)\n    \n3.  [UntrustedIP assessment](#untrustedip-assessment)  \n    \n4.  [PhoneNumber assessment](#phonenumber-assessment)\n    \n\nEach assessment includes a [confidence score](#confidence-scores), a code that describes the evaluation result, and additional contextual information.\n\n#### NewDevice assessment\n\nThe `NewDevice` assessment determines if the user is logging in from a known device and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `match`, `partial_match`, `no_match`, `initial_login`, `unknown_device`, `no_device_history`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### NewDevice assessment code property\n\nThe `NewDevice` assessment `code` property equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `match` | The property values of the `details` object are equivalent. |\n| `partial_match` | The property values of the `details` object are similar. |\n| `no_match` | The property values of the `details` object are different. |\n| `initial_login` | The user logged in for the first time on the device. |\n| `unknown_device` | Auth0 was unable to attain metadata for the device. |\n| `no_device_history` | There is no login history associated with the device. |\n| `assessment_not_available` | Auth0 could not perform an assessment of the device. |\n\n##### NewDevice assessment details object\n\nIf the `code` property value equals `match`, `partial_match`, or `no_match`, the `NewDevice` assessment contains the `details` object with the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `device` | Device of the user. | string | `known`, `unknown` |\n| `useragent` | User agent of the user. | string | `known`, `unknown` |\n\n#### ImpossibleTravel assessment\n\nThe `ImpossibleTravel` assessment determines if the user is logging in from a location that would indicate impossible travel and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `minimal_travel_from_last_login`, `travel_from_last_login`, `substantial_travel_from_last_login`, `impossible_travel_from_last_login`, `invalid_travel`, `mission_geoip`, `anonymous_proxy`, `unknown_location`, `initial_login`, `location_history_not_found`, `assessment_not_available` |\n\n#### UntrustedIP assessment\n\nThe `UntrustedIP` assessment determines if the user’s IP address is present in Auth0’s repository of low-reputation IP addresses (“deny list”) and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `code` | Evaluation result of the assessment. | string | `not_found_on_deny_list`, `found_on_deny_list`, `invalid_ip_address`, `assessment_not_available` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### UntrustedIP assessment details object\n\nIf the `UntrustedIP` assessment `code` property value equals `found_on_deny_list`, the `details` object is present and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `ip` | IP address of the device. | string | Any valid IPv4 or IPv6 address. |\n| `matches` | Subnet mask that IP address belongs to. | string | Any valid IPv4 or IPv6 subnet mask. |\n| `source` | Name of threat intelligence source for the deny list. | string | Any valid text. |\n| `category` | Category indicating why IP address is untrusted. | string | `abuse`, `anonymizer`, `datacenter`, `reputation`, `unroutable` |\n\n##### UntrustedIP assessment details object category property\n\nThe `UntrustedIP` assessment `details` object `category` property describes the general reason why Adaptive MFA considers a given IP address untrusted and equals one of the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `abuse` | IP address exhibited abusive behaviors or was found to be member of bot nets. |\n| `anonymizer` | IP address belongs to anonymizing services such as VPN providers, open proxies, and TOR exit nodes. |\n| `datacenter` | IP address belongs to cloud hosting providers and colocation datacenters. |\n| `reputation` | IP address has a poor reputation score based on activity. |\n| `unroutable` | IP address is not in any range allocated or delegated by any authorized Internet registry or allowed for public use. |\n\n#### PhoneNumber assessment\n\nThe `PhoneNumber` assessment assesses the risk of a phone number for an incoming transaction and contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `code` | Describes the evaluation result. | string | `ok`, `requires_verification`, `phone_number_not_provided`, `assessment_not_available` |\n| `confidence` | Confidence score calculated by Adaptive MFA. | string | `low`, `medium`, `high`, `neutral` |\n| `details` | Additional contextual information. | object | Refer to table below. |\n\n##### PhoneNumber assessment details object\n\nThe `PhoneNumber` assessment `details` object contains the following properties:\n\n| **Property** | **Description** | **Type** | **Possible values** |\n| --- | --- | --- | --- |\n| `lineType` | Type of phone line | string | `FIXED_LINE`, `MOBILE`, `FIXED_LINE_OR_MOBILE`, `TOLL_FREE`, `PREMIUM_RATE`, `SHARED_COST`, `VOIP`, `PERSONAL_NUMBER`, `PAGER`, `UAN`, `UNKNOWN` |\n| `isValid` | Returns the validity of the number | boolean | `true`, `false` |\n| `countryCode` | Country code of the phone origin | integer | `0-999` |\n| `number` | Phone number | string | Valid number including `countryCode` |\n\n## Action result outcomes\n\nIf any of your Actions trigger MFA based on confidence score, the default Adaptive MFA policy triggers MFA when the confidence score is `low`.\n\nThe following table shows the possible outcomes based on the combination of Actions and default Adaptive MFA policy actions.\n\n| **Action result** | **Adaptive MFA action** | **Outcome** |\n| --- | --- | --- |\n| Unauthorized | Trigger MFA | Unauthorized |\n| Unauthorized | No MFA Required | Unauthorized |\n| Trigger MFA | Trigger MFA | Trigger MFA |\n| Trigger MFA | No MFA Required | Trigger MFA |\n| No MFA Required | Trigger MFA | Trigger MFA |\n| No MFA Required | No MFA Required | No MFA Required |\n\n## Action templates\n\nAuth0 provides two Action templates based on Adaptive MFA for you to customize: [Adaptive MFA](#adaptive-mfa) and [Require MFA Enrollment](#require-mfa-enrollment).\n\n### Adaptive MFA template\n\nThis template provides an example and starting point for how to build a custom business flow using individual risk assessments.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.authentication && \n      event.authentication.riskAssessment && \n      event.authentication.riskAssessment.assessments.NewDevice) {\n\n  // Example condition: prompt MFA only based on the NewDevice \n    // confidence level, this will prompt for MFA when a user is logging in \n    // from an unknown device.\n    let shouldPromptMfa;\n\n    switch (event.authentication.riskAssessment.assessments.NewDevice.confidence) {\n      case 'low':\n      case 'medium':\n        shouldPromptMfa = true;\n        break;\n      case 'high':\n        shouldPromptMfa = false;\n        break;\n      case 'neutral':\n        // When this assessor has no useful information about the confidence, \n        // do not prompt MFA.\n        shouldPromptMfa = false;\n        break;\n    }\n\n      // It only makes sense to prompt for MFA when the user has at least one \n      // enrolled MFA factor.\n    const canPromptMfa = event.user.multifactor && event.user.multifactor.length > 0;\n\n    if (shouldPromptMfa && canPromptMfa) {\n      api.multifactor.enable('any', { allowRememberBrowser: true });\n    }\n  }\n};\n```\n\n### Require MFA Enrollment template\n\nThis template demonstrates how you could enforce MFA enrollment when using a standard or Adaptive MFA policy. It uses `event.user.multifactor` to check if the user is enrolled in MFA, and if they’re not, prompts for enrollment.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.user.multifactor || event.user.multifactor.length == 0) {\n    api.multifactor.enable('any', { allowRememberBrowser: true });\n  }\n};\n```\n\n## Action use cases\n\nHere are some suggestions for how to build custom Actions based on your use case.\n\n### Perform an action if overall confidence score is X\n\nAssess the `riskAssessment.confidence` property, and then compare it with the constants `high`, `medium`, or `low`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMedium = riskAssessment && riskAssessment.confidence === 'medium';\n\n  if (riskIsMedium) {\n    // ....\n  }\n}\n```\n\n### Perform an action if confidence score is above or below X\n\nConfidence scores are discrete values—not in a range—so you cannot use comparison operators (such as `<` or `>`) to evaluate multiple values in a single condition.\n\nUse multiple conditions to logically combine all the confidence scores you want to handle. For example, if you want to know when the confidence score is greater than `low`, check if it’s equal to `medium` or `high`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsMediumOrHigh = riskAssessment && \n                                  (riskAssessment.confidence === 'high' || \n                                   riskAssessment.confidence === 'medium');\n\n  if (riskIsMediumOrHigh) {\n    // ...\n  }\n}\n```\n\n### Get additional details if overall confidence score is X\n\nThe `riskAssessment` object is saved in your tenant logs. You can view log entries to see the risk assessment score and the determining factors (reasons).\n\nYou can view the `riskAssessment` object and report the results elsewhere. For example, you can send an email or save a record in an external database.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const riskIsLow = riskAssessment && riskAssessment.confidence === 'low';\n\n  if (riskIsLow) {\n    // log(externalDatabase, riskAssessment);\n  }\n}\n```\n\n### Perform an action if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    // ...\n  }\n}\n```\n\n### Aggregate assessments for a custom overall confidence score.\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, and then use the `confidence` property, the `code` property, or both.\n\nTo learn more about custom confidence scoring, read [Custom confidence scoring](#custom-confidence-scoring).\n\n### Block current transaction and return error and message if a specific assessment has a specific result\n\nUse the [assessments](#assessments-object) object to access the details for individual assessments, including the `code` property.\n\nBlock the login transaction from completing by returning the callback function with an `UnauthorizedError` object as the [error parameter](https://auth0.com/docs/troubleshoot/error-handling-best-practices). The `UnauthorizedError` object always sets `error` to `unauthorized`, but you can customize the `error_message`:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const { riskAssessment } = event.authentication || {};\n  const { ImpossibleTravel } = riskAssessment && riskAssessment.assessments;\n\n  if (ImpossibleTravel.code === 'impossible_travel_from_last_login') {\n    return api.access.deny('Login blocked due to impossible travel detected.')\n  }\n}\n```\n\nThis redirects the user back to the application's callback URL with the `error` and `error_message` parameters included.\n\n### Safely handle when Auth0 fails to execute assessments\n\nAuth0 automatically assigns a `low` confidence score if there is any sort of failure performing the risk assessment.\n\nTo mitigate this scenario, use the [assessments](#assessments-object) object to inspect the `code` property for each individual assessment and check if the value is set to `assessment_not_available`.\n\n## Learn more\n\n*   [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)",
    "title": "Customize Adaptive MFA",
    "description": "Learn how to customize Adaptive Multi-Factor Authentication (MFA).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk",
    "markdown": "# Guardian.swift iOS SDK\n\n[Guardian.swift](https://github.com/auth0/Guardian.swift) allows you to integrate Auth0's Guardian multi-factor service in your own iOS app, transforming it into the second factor itself. Your users will get all the benefits of our frictionless multi-factor authentication from your app. To learn more, read [Getting Started with Apple Push Notification Service](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n\n## Requirements\n\n*   iOS 10+ and Swift 4.1 is required in order to use Guardian.\n    \n*   To use this SDK you have to configure your tenant's Guardian service with your own push notification credentials, otherwise, you would not receive any push notifications. To learn more, read [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa).\n    \n\n## Install Guardian iOS SDK\n\n### CocoaPods\n\nGuardian.swift is available through [CocoaPods](http://cocoapods.org/). To install it, add the following line to your Podfile:\n\n```\npod 'Guardian', '~> 1.1.0'\n```\n\n### Carthage\n\nAdd this line to your Cartfile:\n\n```\ngithub \"auth0/Guardian.swift\" ~> 1.1.0\n```\n\n## Enable Guardian push notifications\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/guardian).\n    \n    ![Auth0 Dashboard Security Multi-Factor Authentication](https://images.ctfassets.net/cdy7uua7fh8z/4xrjmhY1cLhXhlygZKyN4f/3ec3b4cfc0d4e3ce178b519a0fb7df17/Dashboard_-_Security_-_MFA.png)\n2.  Toggle **Push Notification** on to enable it.\n    \n3.  [Configure push notifications](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n    \n\n## Usage\n\n`Guardian` is the core of the SDK. To use the SDK, import the library:\n\nSet the domain for your tenant. Or, use the custom domain if you configured one for your tenant:\n\n```\nlet domain = \"{yourDomain}/appliance-mfa\"\n```\n\n### Enroll\n\nAn enrollment is a link between the second factor and an Auth0 account. When an account is enrolled you'll need it to provide the second factor required to verify the identity. If your app is not yet using push notifications or you're not familiar with it, see [Apple Push Notification Service Overview](https://developer.apple.com/go/?id=push-notifications) for details.\n\nFor an enrollment you need the following information, besides your Guardian domain:\n\n| Variable | Description |\n| --- | --- |\n| **Enrollment URI** | Value encoded in the QR code scanned from Guardian Web Widget or your enrollment ticket sent to you in email or SMS. |\n| **APNS Token** | Apple APNS token for the device. It must be a string containing the 64 bytes (in hexidecimal format). |\n| **Key Pair** | An RSA (private/public) key pair used to assert your identity with Auth0 Guardian. |\n\nAfter you have the information, you can enroll your device:\n\n```\nGuardian\n        .enroll(forDomain: \"{yourGuardianDomain}\",\n                usingUri: \"{enrollmentUri}\",\n                notificationToken: \"{apnsToken}\",\n                signingKey: signingKey,\n                verificationKey: verificationKey\n                )\n        .start { result in\n            switch result {\n            case .success(let enrolledDevice):\n                // success, we have the enrollment device data available\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\nOn success you'll obtain the enrollment information, that should be secured stored in your application. This information includes the enrollment identifier, and the token for Guardian API associated to your device for updating or deleting your enrollment.\n\n#### Signing and verification keys\n\nGuardian.swift provides a convenience class to generate a signing key:\n\n```\nlet signingKey = try DataRSAPrivateKey.new()\n```\n\nThis key only exists in memory but you can obtain its `Data` representation and store securely in, for example, an encrypted SQLiteDB:\n\n```\n// Store data\nlet data = signingKey.data\n// perform the storage\n\n// Load from Storage\nlet loadedKey = try DataRSAPrivateKey(data: data)\n```\n\nBut if you just want to store inside iOS Keychain:\n\n```\nlet signingKey = try KeychainRSAPrivateKey.new(with: \"com.myapp.mytag\")\n```\n\nThe above example creates a key and stores it automatically under the supplied tag. If you want to retrieve it, you can use the tag:\n\n```\nlet signingKey = try KeychainRSAPrivateKey(tag: \"com.myapp.mytag\")\n```\n\nFor the verification key, we can just obtain it from any `SigningKey`, for example:\n\n```\nlet verificationKey = try signingKey.verificationKey()\n```\n\n### Allow login requests\n\nOnce you have the enrollment in place, you will receive a push notification every time the user has to validate their identity with MFA. Guardian provides a method to parse the data received from APNs and return a `Notification` instance ready to be used.\n\n```\nif let notification = Guardian.notification(from: notificationPayload) {\n    // we have received a Guardian push notification\n}\n```\n\nOnce you have the notification instance, you can easily allow the authentication request by using the `allow` method. You'll also need some information from the enrolled device that you obtained previously. In case you have more than one enrollment, you'll have to find the one that has the same `id` as the notification (the `enrollmentId` property).\n\nWhen you have the information, `device` parameter is anything that implements the protocol `AuthenticatedDevice`:\n\n```\nstruct Authenticator: Guardian.AuthenticationDevice {\n    let signingKey: SigningKey\n    let localIdentifier: String\n}\n```\n\nLocal identifier is the local id of the device, by default on enroll `UIDevice.current.identifierForVendor`. Then just call:\n\n```\nGuardian\n        .authentication(forDomain: \"{yourGuardianDomain}\", device: device)\n        .allow(notification: notification)\n        .start { result in\n            switch result {\n            case .success:\n                // the auth request was successfuly allowed\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Reject login requests\n\nTo deny an authentication request call `reject` instead. You can also send an optional reject reason. The reject reason will appear in the Guardian logs.\n\n```\nGuardian\n        .authentication(forDomain: \"{yourGuardianDomain}\", device: device)\n        .reject(notification: notification)\n        // or reject(notification: notification, withReason: \"hacked\")\n        .start { result in\n            switch result {\n            case .success:\n                // the auth request was successfuly rejected\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Unenroll\n\nIf you want to delete an enrollment, for example, if you want to disable MFA, you can make the following request:\n\n```\nGuardian\n        .api(forDomain: \"{yourGuardianDomain}\")\n        .device(forEnrollmentId: \"{userEnrollmentId}\", token: \"{enrollmentDeviceToken}\")\n        .delete()\n        .start { result in\n            switch result {\n            case .success:\n                // success, the enrollment was deleted\n            case .failure(let cause):\n                // something failed, check cause to see what went wrong\n            }\n        }\n```\n\n### Set up mobile-only OTP enrollment\n\nYou can enable one-time passwords (OTP) as an MFA factor using the Auth0 Dashboard or Management API. This option does not require a QR code and allows users to enroll manually.\n\nTo invite a user to enroll, navigate to the [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and select a user. Then, access their Details tab and use the Multi-Factor Authentication section to send an enrollment invitation.\n\n![Auth0 Dashboard > User Management > Users > [Specific User] > Details](https://images.ctfassets.net/cdy7uua7fh8z/2p9KJ8OnVY99b3ytVLJVVQ/0502eb8ea888cc6d5d4225b7310e3884/image6.png)\n\n#### Connect a resource\n\nYou can connect a resource using the Auth0 Dashboard or the Guardian SDK.\n\n##### Use Auth0 Dashboard\n\n1.  Access the Auth0 login prompt and copy the provided code or a similar base32 encoded key obtained from another source. In the next step, you will enter this code into an authentication application.\n    \n    ![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n2.  Add the code you copied to an authentication application, such as Guardian.\n    \n\n![An example authentication app showing OTPs. ](https://images.ctfassets.net/cdy7uua7fh8z/SgOzh869kU7cTU4ZoBEVA/30be4ae2791be497354b3e413f2a8b1d/image4-scaled.png)\n\n##### Use the SDK\n\n1.  Import the Guardian library.\n    \n2.  Create a code generator.\n    \n    ```\n    let codeGenerator = try Guardian.totp(\n    \n       base32Secret: enrollmentCode,  // Enrollment code entered by user\n    \n       algorithm: .sha1\t\t\t// Algorithm used by TOTP\n    \n    )\n    ```\n    \n3.  Retrieve generated code.\n    \n\n#### Enter one-time code\n\nOn the Auth0 login prompt, enter the code you generated in the previous step.\n\n![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n\nAfter selecting Continue, a message displays stating your application has been added as an authentication factor for your user.\n\n![The success message that displays after entering your one-time code into the Auth0 login prompt. ](https://images.ctfassets.net/cdy7uua7fh8z/3Jm0ShXLZkeKcmpdHzuvs7/6c284b21a780cda8b6fac0ce1068ce2f/image5.png)\n\n#### Log in with your app\n\nAfter the factor has been enrolled, your user can log in using your app. First, choose the Guardian app as your authentication method.\n\n![The authentication method selection screen](https://images.ctfassets.net/cdy7uua7fh8z/1k7IsU9kfP5mrXU2jfGHuT/6f8f9deceb42737fbb68350afc3f387d/image2.png)\n\nThen, enter the one-time code into the login prompt to verify your identity.\n\n![The Verify Your Identity screen prompting the user for a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/S6uTieLjtuNUrQRMh8uch/901e7f08b431d1d48cc8eb4ba7dd6653/image3.png)",
    "title": "Guardian.swift iOS SDK",
    "description": "Describes how to install, use and configure options for the Guardian.swift iOS SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk",
    "markdown": "# Guardian for Android SDK\n\nThe [Guardian for Android SDK](https://github.com/auth0/Guardian.Android) helps you create Android apps with Guardian functionality, providing secure access to multi-factor authentication (MFA) with push notifications. With this toolkit, you can build your own customized version of the Guardian application that matches the look and feel of your organization. To learn more, read [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-apple-using-apn-).\n\nAndroid API level 15+ is required in order to use the Guardian for Android SDK.\n\n## Install Guardian Android SDK\n\nGuardian is available both in [Maven Central](http://search.maven.org/) and [JCenter](https://bintray.com/auth0/android/guardian).\n\n1.  To use Guardian, add these lines to your `build.gradle` dependencies file: `implementation 'com.auth0.android:guardian:0.4.0'` You can check for the latest version on the repository [Releases](https://github.com/auth0/GuardianSDK.Android/releases) tab, in [Maven](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22com.auth0.android%22%20AND%20a%3A%22guardian%22), or in [JCenter](https://bintray.com/auth0/android/guardian).\n    \n2.  After adding your Gradle dependency, make sure to sync your project with Gradle file.\n    \n\n### Enable Guardian push notifications\n\n1.  Go to [Dashboard > Security > Multifactor Auth > Push via Auth0 Guardian.](https://manage.auth0.com/#/security/mfa/guardian)\n    \n2.  Toggle the switch at the top to enable it.\n    \n\n![Auth0 Dashboard > Security > Multi-factor Auth > Guardian > Custom > Amazon SNS](https://images.ctfassets.net/cdy7uua7fh8z/6PKSyH99GJ2CalJoG38sfZ/fbe7229dcc6f7d303a582520001b3dc1/Amazon_SNS.png)\n\n3\\. [Configure push notifications](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa#configure-push-notifications-for-android-using-fcm).\n\n## Use SDK\n\nGuardian is the core of the SDK. You'll need to create an instance of this class for your specific tenant URL.\n\n```\nUri url = Uri.parse(\"https://{yourDomain}/appliance-mfa\");\n\nGuardian guardian = new Guardian.Builder()\n    .url(url)\n    .build();\n```\n\nor\n\n```\nString domain = \"{yourDomain}/appliance-mfa\";\n\nGuardian guardian = new Guardian.Builder()\n    .domain(domain)\n    .build();\n```\n\n### Enroll\n\nThe link between the second factor (an instance of your app on a device) and an Auth0 account is referred to as an **enrollment**.\n\nYou can create an enrollment using the `Guardian.enroll` function, but first, you'll have to create a new pair of RSA keys for it. The private key will be used to sign the requests to allow or reject a login. The public key will be sent during the enrollment process so the server can later verify the request's signature.\n\n```\nKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\nkeyPairGenerator.initialize(2048); // you MUST use at least 2048 bit keys\nKeyPair keyPair = keyPairGenerator.generateKeyPair();\n```\n\nNext, obtain the enrollment information by scanning the Guardian QR code, and use it to enroll the account:\n\n```\nUri enrollmentUriFromQr = ...; // the URI obtained from a Guardian QR code\n\nCurrentDevice device = new CurrentDevice(context, \"fcmToken\", \"deviceName\");\n\nEnrollment enrollment = guardian\n    .enroll(enrollmentUriFromQr, device, keyPair)\n    .execute();\n```\n\nAlternatively, you can execute the request in a background thread:\n\n```\nguardian\n    .enroll(enrollmentUriFromQr, device, keyPair)\n    .start(new Callback<Enrollment> {\n        @Override\n        void onSuccess(Enrollment enrollment) {\n            // we have the enrollment data\n        }\n\n        @Override\n        void onFailure(Throwable exception) {\n            // something failed\n        }\n    });\n```\n\nYou must provide the following data:\n\n| Variable | Description |\n| --- | --- |\n| `deviceName` | Name for the enrollment displayed to the user when the second factor is required. |\n| `fcmToken` | Token for Firebase Cloud Messaging (FCM) push notification service. See [Sample Register](https://firebase.google.com/docs/cloud-messaging/android/client#sample-register \"sample register\") for details. |\n\n### Unenroll\n\nTo disable MFA, you can delete the enrollment:\n\n```\nguardian\n    .delete(enrollment)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Allow login requests\n\nOnce you have the enrollment in place, you'll receive a FCM push notification every time the user needs multi-factor authentication.\n\nGuardian provides a method to parse the `Map<String, String>` data inside the [RemoteMessage](https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/RemoteMessage) received from FCM and return a `Notification` instance ready to be used.\n\n```\n// at the FCM listener you receive a RemoteMessage\n@Override\npublic void onMessageReceived(RemoteMessage message) {\n    Notification notification = Guardian.parseNotification(message.getData());\n    if (notification != null) {\n        // you received a Guardian notification, handle it\n        handleGuardianNotification(notification);\n        return;\n    }\n\n    /* handle other push notifications you might be using ... */\n}\n```\n\nOnce you have the notification instance, you can use the `allow` method to approve the authentication request. You'll also need the enrollment that you obtained previously. If there are multiple enrollments, be sure to use the one that has the same `id` as the notification (the `enrollmentId` property).\n\n```\nguardian\n    .allow(notification, enrollment)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Reject login requests\n\nTo deny an authentication request, use `reject` instead. You can also add an optional reason for the rejection, which will be available in the guardian logs.\n\n```\nguardian\n    .reject(notification, enrollment) // or reject(notification, enrollment, reason)\n    .execute(); // or start(new Callback<> ...)\n```\n\n### Set up mobile-only OTP enrollment\n\nYou can enable one-time passwords (OTP) as an MFA factor using the Auth0 Dashboard or Management API. This option does not require a QR code and allows users to enroll manually.\n\nTo invite a user to enroll, navigate to the [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users) and select a user. Then, access their Details tab and use the Multi-Factor Authentication section to send an enrollment invitation.\n\n![Auth0 Dashboard > User Management > Users > [Specific User] > Details](https://images.ctfassets.net/cdy7uua7fh8z/2p9KJ8OnVY99b3ytVLJVVQ/0502eb8ea888cc6d5d4225b7310e3884/image6.png)\n\n#### Connect a resource\n\nYou can connect a resource using the Auth0 Dashboard or the Guardian SDK.\n\n##### Use Auth0 Dashboard\n\n1.  Access the Auth0 login prompt and copy the provided code or a similar base32 encoded key obtained from another source.\n    \n    ![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n2.  After obtaining your code, add it to the Guardian SDK:\n    \n\n**Java**\n\n`public String copiedCode = \"{copiedCode}\";`\n\n**Kotlin**\n\n`val copiedCode: String = \"{copiedCode}\"`\n\n##### Use Guardian SDK\n\nFirst, add the `LoginCodeGenerator` class to your project. Then, use `getCode (String copiedCode) to` generate a one-time code in your app.\n\n**Java**\n\n```\npublic class LoginCodeGenerator {\n\n   private static final int TOTP_LENGTH = 6;\n\n   private static final int TOTP_DURATION = 30;\n\n   private static final String TOTP_ALGORITHM = \"SHA1\";\n\n   public String getCode(String copedCode) {\n\n       byte[] key = new byte[0];\n\n       try {\n\n           key = Base32.decode(copedCode);\n\n       } catch (Base32.DecodingException ex) {\n\n//            handle exception\n\n       }\n\n       TOTP totp = new TOTP(TOTP_ALGORITHM, key, TOTP_LENGTH, TOTP_DURATION);\n\n       return totp.generate();\n\n   }\n\n}\n```\n\n**Kotlin**\n\n```\nclass LoginCodeGenerator {\n\n   fun getCode(copiedCode: String): String {\n\n       var key: ByteArray? = ByteArray(0)\n\n       try {\n\n           key = Base32.decode(copiedCode)\n\n       } catch (ex: Base32.DecodingException) {\n\n//            handle exception\n\n       }\n\n       val totp = TOTP(TOTP_ALGORITHM, key, TOTP_LENGTH, TOTP_DURATION)\n\n       return totp.generate()\n\n   }\n\n   companion object {\n\n       private const val TOTP_LENGTH = 6\n\n       private const val TOTP_DURATION = 30\n\n       private const val TOTP_ALGORITHM = \"SHA1\"\n\n   }\n\n}\n```\n\n#### Enter one-time code\n\nEnter the generated one-time password from `getCode()` into the Auth0 login prompt.\n\n![An example login prompt displaying a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/1yoqiIuERVTwCU8yfx6IM8/86283023dddbddd3a903a654bf28cac2/image1.png)\n\nAfter selecting Continue, a message displays stating your application has been added as an authentication factor for your user.\n\n![The success message that displays after entering your one-time code into the Auth0 login prompt. ](https://images.ctfassets.net/cdy7uua7fh8z/3Jm0ShXLZkeKcmpdHzuvs7/6c284b21a780cda8b6fac0ce1068ce2f/image5.png)\n\n#### Log in with your app\n\nAfter the factor has been enrolled, your user can log in using your app. First, choose the Guardian app as your authentication method.\n\n![The authentication method selection screen](https://images.ctfassets.net/cdy7uua7fh8z/1k7IsU9kfP5mrXU2jfGHuT/6f8f9deceb42737fbb68350afc3f387d/image2.png)\n\nTo generate the one-time code, call `getCode(copedCode: String)` using the code you copied from the Auth0 login prompt.\n\nThen, enter the one-time code into the login prompt to verify your identity.\n\n![The Verify Your Identity screen prompting the user for a one-time code](https://images.ctfassets.net/cdy7uua7fh8z/S6uTieLjtuNUrQRMh8uch/901e7f08b431d1d48cc8eb4ba7dd6653/image3.png)\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)",
    "title": "Guardian for Android SDK",
    "description": "Describes how to install, configure, and use options for the Auth0 Guardian for Android SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login",
    "markdown": "# Customize MFA for Classic Login\n\nYou can enable multi-factor authentication in the [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) section. You can customize the MFA pages using basic branding options on the Auth0 Dashboard. For further customization, you can provide your own HTML for the MFA page. When using your own HTML, Classic Login uses the Auth0 MFA Widget with the following limitations:\n\n*   It does not support MFA with email.\n    \n*   If users enrolled in more than one factor, they cannot select which one to use. The MFA widget will ask them to login with the most secure factor.\n    \n*   It does not use Universal Login internationalization features. To learn more, read [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization).\n    \n\n## Customize HTML for the MFA page\n\nTo customize the MFA page, go to [Dashboard > Branding > Universal Login > Multi-factor Authentication](https://manage.auth0.com/#/mfa_page) tab and enable the **Customize MFA Page** toggle. You can then use the text editor to change your HTML, style your page using CSS, and alter the JavaScript used to retrieve custom variables. Once you've made your changes, and make sure to click **Save Changes**.\n\nMFA pages work without customization and Auth0 will update the included scripts as required. However, once you enable customization, you are responsible for updating and maintaining the script (including changing version numbers, such as that for the MFA Widget) since Auth0 can no longer update it automatically.\n\nTo learn more about how to override the text for many areas of the MFA process for Classic Login, read [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary). To learn more about the MFA Widget theme options, read [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options).\n\n## Reset page\n\nIf you'd like to revert to an earlier design, you have two options:\n\n*   Revert to the last saved template by clicking **Reset to Last**;\n    \n*   Revert to the default template provided by Auth0 by clicking **Reset to Default**.\n    \n\n## Render enrollment invitations\n\nThere are two different possible scenarios in which the page is rendered. If a user has been directed to this page specifically for enrollment (for instance, from an email with an enrollment link) then the property `ticket` will be available. Otherwise, the property `requestToken` will be available.\n\n## HTML and Liquid syntax\n\nThe hosted page uses Liquid syntax for templating. To learn more, read [Liquid for Designers](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) on GitHub. The following parameters are available to assist in rendering your page:\n\n*   `userData.email`\n    \n*   `userData.friendlyUserId`\n    \n*   `userData.tenant`\n    \n*   `userData.tenantFriendlyName`\n    \n*   `iconUrl`\n    \n\nMost of the parameters that are used in the MFA Widget need to be passed to Guardian as shown in the default template provided in the customization area. If you need a higher level of customization you could use [auth0-guardian.js](https://github.com/auth0/auth0-guardian.js/tree/master/example).\n\nTo learn more, read [Customize MFA User Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa).\n\n## Learn more\n\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)",
    "title": "Customize MFA for Classic Login",
    "description": "Learn how to customize MFA when using Classic Login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference",
    "markdown": "# Guardian Error Code Reference\n\nUse the error codes to display informative messages and to distinguish between recoverable and unrecoverable errors.\n\n| Error Code | Description |\n| --- | --- |\n| `invalid_token` | Invalid request or transaction token |\n| `insufficient_scope` | You don't have enought grants to perform the requested operation |\n| `invalid_bearer_format` | The bearer put in authentication header was not valid |\n| `enrollment_conflict` | There is another enrollment for the same user. You cannot enroll twice. |\n| `tenant_not_found` | The tenant associated cannot be found. Should not normally happen at least that you delete the tenant |\n| `login_transaction_not_found` | The mfa auth transaction is not active or has already expired |\n| `error_sending_push_notification` | Push notification delivery failed |\n| `push_notification_wrong_credentials` | Push notification delivery failed because of wrong credentials |\n| `invalid_otp` | Provided otp code was not valid |\n| `invalid_recovery_code` | Provided recovery code was not valid |\n| `invalid_body` | Body validation failed. Bad request. |\n| `invalid_query_string` | Query string validation failed. Bad request. |\n| `enrollment_transaction_not_found` | The mfa enrollment transaction is not active or has expired |\n| `invalid_phone_number` | The provided phone number is invalid |\n| `error_sending_sms` | SMS Delivery error |\n| `feature_disabled` | The requested feature is currently globally not available (contact the provider) |\n| `feature_disabled_by_admin` | The requested feature is currently disabled by your admin |\n| `pn_endpoint_disabled` | We were unable to deliver the push notification after retrying many times. Try removing you account for the device and adding it again. |\n| `too_many_sms` | You have exeed the amount of SMSs assigned to your user |\n| `too_many_pn` | You have exeed the amount of push notifications assigned to your user |\n| `too_many_sms_per_tenant` | You have exeed the amount of SMSs assigned to your tenant |\n| `too_many_pn_per_tenant` | You have exeed the amount of push notifications assigned to your tenant |\n| `field_required` | A field is required to perform the operation (this errors has a field attribute with a code for the field: `otpCode`, `recoveryCode`) |\n| `method_not_found` | You have requested a method that is currently not supported (should not happen) |\n| `no_method_available` | There is currently no method to enroll (all of them are disabled) |\n| `enrollment_method_disabled` | The specified enrollment method is disabled, this error has also a .method field |\n| `auth_method_disabled` | The specified authentication method is disabled, this error has also a .method field |\n| `invalid_otp_format` | OTP format validation error |\n| `invalid_recovery_code_format` | Recovery code format validation error |\n| `transaction_expired` | The transaction has already expired |\n| `already_enrolled` | You are already enrolled, cannot enroll again |\n| `not_enrolled` | You not enrolled. Must enroll first |\n| `invalid_enrollment` | The enrollment provided to transaction#requestAuth method is not valid or is null/undefined |",
    "title": "Guardian Error Code Reference",
    "description": "Lists Guardian error codes and descriptions.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-enrollments-universal-login",
    "markdown": "# Customize MFA Enrollments for Universal Login\n\nAuth0 supports a variety of factors for securing user access with [multi-factor authentication (MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)). Using `post-login` Actions, you can customize your MFA flows to prompt users to enroll in specific factors. After a user enrolls in a factor, they can use that factor as a secondary method of authentication in future logins.\n\nYou can also use contextual information to further customize your MFA enrollment flows. For example, you can prompt users to enroll in SMS for one application while prompting them to enroll in push notifications or WebAuthN for a different application.\n\nThis feature allows you to customize your MFA enrollment flows. If you want to customize MFA flows for users who are already enrolled, review [Customize MFA Selection for Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n\n## How it works\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to customize your MFA enrollment flows. Specifically, you can modify the `post-login` trigger of the [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) with the following Authentication API methods:\n\n*   `enrollWith`: Specifies the default factor presented to users during enrollment. Optionally, you can provide an alternative list of factors for users to choose from. If provided, a Try Another Method link displays on the enrollment prompt.\n    \n*   `enrollWithAny`: Specifies a set of factors users can choose from during enrollment. By default, this method presents a selection prompt that allows users to choose their desired factor. In some cases, the user experience may vary:\n    \n    *   If two or more factors have been specified, the selection prompt displays to the user.\n        \n    *   If the user has already enrolled in all specified factors except one, the selection prompt is skipped, and the user is prompted to enroll in the remaining factor.\n        \n    *   If the user has already enrolled in all specified factors, the command fails, and the login sequence continues.\n        \n\nYou can use a combination of these methods to customize your MFA enrollment flows. You can also incorporate user metadata, such as roles or last login date, to create more tailored experiences.\n\nCustomized enrollment flows support the following factors:\n\n*   `otp`\n    \n*   `recovery-code`\n    \n*   `push-notification`\n    \n*   `phone`\n    \n    *   `preferredMethod: voice`\n        \n    *   `preferredMethod: sms`\n        \n    *   `preferredMethod: both`\n        \n*   `webauthn-platform`\n    \n*   `webauthn-roaming`\n    \n\nAfter a user enrolls in a factor, its value is added to their `enrolledFactors`. This property represents the list of active factors associated with their user account.\n\nThe array `event.authentication.methods` includes a `type` field when the name of the method is set to `mfa`. This field contains factor values (string) that match those used by the `type` field from `enrolledFactors`.\n\nWhen an MFA enrollment occurs, `methods` contains the object of `name:mfa` with `type` set to the factor used for that event. `methods` and `enrolledFactors` are only updated when an Action first begins. You can access the results of an enrollment event in the next Action of the flow.\n\nTo learn more, review the following resources:\n\n*   [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object)\n    \n*   [Actions Triggers: post-login - API Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object)\n    \n\n### Sequenced and contextual flows\n\nWith the `enrollWith` or `enrollWithAny` commands, you can use contextual information to determine the best enrollment or series of enrollments to present to users.\n\n*   The `enrollWith` command supports an initial or default factor and a list of alternatives. Users can only enroll in one factor per command.\n    \n*   The `enrollWithAny` command supports a list of factors. The specified order of factors determines how the list displays to users. Users can only enroll in one factor per command.\n    \n\nWith these commands, you can leverage the following:\n\n*   **Sequenced flows**: Enroll users with a series of factors in a specific order.\n    \n*   **Contextual flows**: Determine which factor to prompt the user with based on metadata or previous commands in the flow.\n    \n\nTo help illustrate these flows, consider the following example:\n\n```\n// Action 1\n\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.enrolledFactors.length) {\n    // already enrolled, challenge\n    api.authentication.challengeWithAny(event.user.enrolledFactors.map(m => ({type: m.type})));\n    if (event.user.app_metadata.isAdmin &&\n        !event.user.enrolledFactors.some(m => m.type === 'webauthn-roaming')) {\n          // if is admin and doesn't have a security key, meaning a different factor was used, enroll now\n          api.authentication.enrollWith({type: 'webauthn-roaming'})\n        }\n  }\n  else {\n    // not enrolled; choose a factor to enroll now\n    api.authentication.enrollWithAny([{type: 'webauthn-roaming'}, {type: 'otp'}]);\n    if (event.user.app_metadata.isAdmin) {\n      // one more factor for admins\n      api.authentication.enrollWithAny([{type: 'webauthn-roaming'}, {type: 'otp'}]);\n    }\n  }\n};\n\n// Action 2\n\nexports.onExecutePostLogin = async (event, api) => {\n  function performed(type) {\n    return event.authentication.methods.some(m => m.name === 'mfa' &&\n           m.type === type &&\n           Date.now() - new Date(m.timestamp).getTime() < 5000)\n  }\n  if (event.user.app_metadata.isAdmin) {\n      // enforce both factors are used by challenging the one that has not been used yet\n      if (!performed('webauthn-roaming')) {\n        api.authentication.challengeWith({type: 'webauthn-roaming'})\n      }\n      else if (!performed('otp')) {\n        api.authentication.challengeWith({type: 'otp'})\n      }\n  }\n};\n```\n\nThese two Actions combine to create a scenario where users **without** the admin role are required to enroll with either a one-time password (OTP) or a security key. Conversely, users **with** the admin role must enroll in both factors.\n\nAction 1 reviews the `app_metadata` to determine if the user is an admin, then prompts them to enroll in specific factors. If an admin user has only enrolled in OTP, they are first challenged with OTP to complete their authentication. They are then prompted to enroll with security keys (`webauthn-roaming`).\n\nThe flow pauses after Action 1 executes, and both `event.user.enrolledFactors` and `event.authentication.methods` will be updated when Action 2 runs. This allows the Action code to make decisions based on actual user data when users are given a choice to challenge or enroll in different factors.\n\n**Note**: This method of executing Actions only applies to those containing `enrollWith` or `enrollWithAny` commands. Actions serving other purposes are not affected.\n\n## Before you begin\n\nBefore you can customize your MFA flows, you must set up MFA in your tenant and enable the Customize MFA Factors using Actions setting. You can enable one or more factors and define your MFA policies on your Auth0 Dashboard under [Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n\n*   To learn more about the setup process, review [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n*   For information about configuring specific factors, review [Multi-factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n\nTo customize your flows, you must enable the Customize MFA Factors using Actions toggle in the Additional Settings section. Your customized flows will not work properly if this setting is not enabled.\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Additional Settings](https://images.ctfassets.net/cdy7uua7fh8z/2hv0ELTkkka3t230SXfxw/46def5395652b2451cfc9e0ad01a371a/MFA_actions.png)\n\n**Note**: Actions with `enrollWith` or `enrollWithAny` commands override any existing policies or rules that enable or disable MFA in a tenant.\n\n## Customize MFA enrollment flows\n\nAfter setting up MFA for your tenant, you can create `post-login` Actions to customize your MFA enrollment flows.\n\n### Create your post-login Action\n\nYou can create Actions through the Auth0 Dashboard:\n\n1.  Navigate to [Actions > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**.\n    \n2.  In the Add Action panel, select the **plus sign (+)** icon and choose **Build from scratch**. \n    \n3.  On the Create Action popup:\n    \n    *   Enter a name for your Action.\n        \n    *   Select **Login / Post-Login** as the trigger.\n        \n    *   Use **Node 18 (Recommended)** for the runtime.\n        \n4.  Review the popup to ensure accuracy. Then, select **Create**.\n    \n5.  In the code editor, add your custom code to the `onPostExecute` command. \n    \n6.  When your command is ready, select **Deploy**.\n    \n7.  Select **Add to Flow** on the successful deployment notification.\n    \n    *   **Note**: If the notification closes, choose **Back to Flow** above the code editor.\n        \n8.  Drag and drop your new command from the Add Action panel into your Login flow. Then, select **Apply**.\n    \n\nTo make additional changes after saving, navigate to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. You can then update and redeploy your code as needed.\n\n### Test your post-login Action\n\nTo ensure your commands function appropriately, you can test your Action through the Auth0 Dashboard:\n\n1.  Navigate to [Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n2.  Select **Try** to open a sample login prompt in a new tab.\n    \n3.  Enter your credentials and test your new MFA flow.\n    \n\nIf the flow is successful, a confirmation screen displays. If you encounter any issues, you can update your code by navigating to [Actions > Library > Custom](https://manage.auth0.com/#/actions/library) in your Auth0 Dashboard.\n\n## Troubleshooting\n\nIn the event that you experience errors or unexpected results from your customized MFA enrollments, you can use the information below to help identify and resolve these issues.\n\n### Tenant Logs\n\nYou can monitor your customized MFA enrollments through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nTenant logs are available in the Auth0 Dashboard under [Monitoring > Logs](https://manage.auth0.com/#/logs). Alternatively, you can retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/introduction).\n\nIf you or your users experience unexpected behavior, review tenant logs for the following event codes to learn more:\n\n| Scenario | Event | Error Message |\n| --- | --- | --- |\n| A user is prompted to enroll with a specific factor. However, the requested factor meets one of the following conditions:  <br><br>*   The factor is not enabled in your tenant.<br>*   The factor is not supported by the user's browser.<br>*   The user has already enrolled in the requested factor.<br><br>In this scenario, the user can complete the flow if alternative factors are available. | w   | An MFA enrollment is used in a PostLogin action, but the requested factor ${factor.name} is not properly set up. Enable the requested factor and ensure the user is not already enrolled with it. |\n| A user is prompted to enroll with one or more factors, but the supplied factors cannot be used for enrollment. In this case, the user cannot complete the flow. | mfar | An MFA enrollment is used in a PostLogin action but the requested factors are not properly set up. To perform MFA, enable the requested factors and ensure the user is not already enrolled with them. |\n| A user attempts to enroll in a new factor without completing at least one challenge using an existing enrollment. | mfar | An MFA enrollment was requested but the user is already enrolled in MFA. Challenge with at least one existing factor before enrolling a new one. |\n\n### Troubleshooting checklist\n\nThe following checklist provides additional suggestions for identifying and resolving common issues with customized MFA flows.\n\n1.  The **Customize MFA factors with Actions** toggle must be enabled.\n    \n    *   Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure the toggle in the Additional Settings section is enabled.\n        \n2.  Factors referenced in your Actions must be enabled in your tenant.\n    \n    *   **Review your code**: Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and review your Actions code. Ensure all factors referenced are applicable to your use cases.\n        \n    *   **Review your factors**: Navigate to [Auth0 Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa) and ensure all factors referenced in your Actions are enabled.\n        \n3.  Ensure your Actions have been deployed and saved in your Pipeline.\n    \n    1.  Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library). Locate your Action in the list and ensure its status is **Deployed**. If a different status is listed, access your Action, review your code, and click **Deploy** to the top right.\n        \n    2.  Navigate to [Auth0 Dashboard > Actions > Library > Flows](https://manage.auth0.com/#/actions/flows) and select **Login**. Ensure your Action is listed in the flow. If not, access the **Custom tab** of the Add Action panel and drag and drop your Action into your Login flow. Then, select **Apply**.\n        \n4.  Ensure you've upgraded to the latest version of `post-login` Actions.\n    \n    *   Navigate to [Auth0 Dashboard > Actions > Library > Custom](https://manage.auth0.com/#/actions/library) and select your Action. If your Action is out-of-date, you will see a yellow banner prompting you to update the Action. If the banner displays, select **Update**.\n        \n    *   You can also specify the latest version of `post-login` Actions for deployment when using the Deploy CLI. For more information, review [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).",
    "title": "Customize MFA Enrollments for Universal Login",
    "description": "Customize MFA flows using post-login Actions to prompt users to enroll in specific factors.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary",
    "markdown": "# MFA Theme Language Dictionary\n\n```\ndefaults: {\n  iddleHelpUrl: '#',\n  rememberBrowserCheckbox: 'Remember this browser',\n  title: 'Login to {tenantName}'\n},\n\ndownloadApp: {\n  headerText: 'Download Auth0 Guardian for free:',\n  pushEnrollmentAction: 'I\\'ve already downloaded it',\n  smsAndTotpEnrollmentActions: 'I\\'d rather use <sms>SMS</sms> or <ga>Google Authenticator</ga>',\n  pushAndTotpEnrollmentActions: 'I\\'d rather use <push>Guardian</push> or <ga>Google Authenticator</ga>',\n  pushAndSmsEnrollmentActions: 'I\\'d rather use <push>Guardian</push> or <sms>SMS</sms>',\n  totpEnrollmentActions: 'I\\'d rather use <ga>Google Authenticator</ga>',\n  smsEnrollmentActions: 'I\\'d rather use <sms>SMS</sms>',\n  pushEnrollmentActions: 'I\\'d rather use <push>Guardian</push>',\n  iosLabel: 'App Store',\n  iosUrl: 'https://itunes.apple.com/us/app/auth0-guardian/id1093447833?ls=1&mt=8',\n  iosImg: '<svg width=\"27px\" height=\"33px\" viewBox=\"37 22 27 33\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"auth0-mfa-svg-icon\"><g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(37.000000, 22.000000)\"><path d=\"M22.0964148,17.5965957 C22.0594667,13.4821277 25.4586963,11.4804255 25.6141333,11.387234 C23.6890074,8.57489362 20.7051259,8.1906383 19.656563,8.16 C17.1504593,7.89574468 14.7195259,9.66255319 13.4429037,9.66255319 C12.1408,9.66255319 10.1749037,8.18553191 8.05611852,8.22893617 C5.3296,8.27106383 2.7789037,9.85276596 1.37997037,12.3089362 C-1.50708148,17.3170213 0.646103704,24.6765957 3.41211852,28.7246809 C4.79576296,30.707234 6.41256296,32.9208511 8.5288,32.8429787 C10.5991704,32.7574468 11.3725333,31.5204255 13.8709926,31.5204255 C16.3465185,31.5204255 17.0727407,32.8429787 19.2310222,32.7931915 C21.4530074,32.7574468 22.8519407,30.8017021 24.1871704,28.8012766 C25.7861333,26.5289362 26.4282667,24.2910638 26.4537481,24.1761702 C26.4015111,24.1582979 22.1384593,22.5280851 22.0964148,17.5965957 L22.0964148,17.5965957 Z\" fill=\"#FFFFFF\"></path><path d=\"M18.0193778,5.49702128 C19.1329185,4.10170213 19.8948148,2.20340426 19.6833185,0.277021277 C18.0716148,0.348510638 16.0560296,1.39404255 14.8953481,2.7587234 C13.8684444,3.9612766 12.9511111,5.93234043 13.1880889,7.78595745 C14.9985481,7.9212766 16.8574222,6.8706383 18.0193778,5.49702128 L18.0193778,5.49702128 Z\" fill=\"#FFFFFF\"></path></g></svg>',\n  androidLabel: 'Google Play',\n  androidUrl: 'https://play.google.com/store/apps/details?id=com.auth0.guardian',\n  androidImg: '<svg width=\"30px\" height=\"34px\" viewBox=\"35 22 30 34\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"auth0-mfa-svg-icon\"><g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(35.000000, 22.000000)\"><polygon fill=\"#ffffff\" points=\"0.0311829399 32.9244984 0.0311829399 1.02956758 16.5681333 17.6173695\"></polygon><polygon fill=\"#ffffff\" points=\"0.60957618 0.0196753921 17.3854403 16.8471259 22.6948251 11.782715\"></polygon><polygon fill=\"#ffffff\" transform=\"translate(11.025248, 26.014581) scale(1, -1) translate(-11.025248, -26.014581)\" points=\"0.60957618 18.1008562 17.3854403 33.9283067 21.4409189 29.8631472\"></polygon><path d=\"M18.3964257,17.493946 L23.8211074,12.6992188 L28.7813766,15.7894686 C29.3871829,16.1668862 29.4042508,16.7930368 28.8086222,17.1953618 L22.3003286,21.5914726 L18.3964257,17.493946 Z\" fill=\"#ffffff\"></path></g></svg>'\n},\n\npushAuth: {\n  pushSent: {\n    useTotpFallback: 'If you haven\\'t received the notification,<br></br>just <manualInput>enter the code</manualInput> manually.'\n  },\n\n  pushTimeout: {\n    resendAction: 'Resend push notification',\n    timeoutText: 'Didn\\'t receive the push notification?',\n    useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>',\n    useTotpFallback: '<manualInput>Enter the code manually</manualInput>'\n  }\n},\n\ntotpAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Get a verification code from the Google Authenticator (or similar) app:',\n  useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>'\n},\n\nsmsAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Enter the 6-digit code we\\'ve just sent to your phone.',\n  useRecoveryCode: 'Lost your device? <recovery>Use the recovery code</recovery>'\n},\n\nguardianTotpAuth: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'Get a verification code from the Auth0 Guardian app.'\n},\n\nrecoveryCodeAuth: {\n  codePlaceholder: 'Enter your code here',\n  headerText: 'We will generate a new recovery code<br />once you\\'ve logged in:'\n},\n\npushEnrollment: {\n  headerText: 'Scan this code with Auth0 Guardian:'\n},\n\nenrollmentCongrats: {\n  congrats: 'Congratulations, you are all set.<br />In the future when logging in you\\'ll want your device handy.',\n  continueButtonText: 'Continue'\n},\n\nreportRecoveryCode: {\n  headerText: 'In the event that you need to login without your device you\\'ll need a recovery code. Take a note and keep this somewhere safe:',\n  confirmationLabel: 'I have safely recorded this code'\n},\n\ngeneralError: {\n  errorsRecoveryHelp: {\n    default: 'Looks like something went wrong.<br />Please try logging in again from the application.',\n\n    globalTransactionExpired: 'The login was not successful.<br />Please try again.',\n\n    // Auth0 Server Errors\n    guardianInvalidNonce: 'Please try logging in again from the application.',\n    guardianInvalidToken: 'Please try logging in again from the application.',\n    invalidLoginTokenStatus: 'Please try logging in again from the application.',\n    loginTokenInvalidSignature: 'Please try logging in again from the application.',\n    loginTokenTransactionExpired: 'Please try logging in again from the application.'\n  }\n},\n\nsmsEnrollmentConfirm: {\n  codePlaceholder: 'Enter the 6-digit code',\n  headerText: 'In order to confirm enrollment we need to confirm your phone. Please enter the received code.'\n},\n\ntotpEnrollment: {\n  codePlaceholder: 'Enter your passcode here',\n  headerText: 'Scan this QR code with Google Authenticator (or similar) app:',\n  troubleScanning: 'Trouble Scanning ?'\n},\n\ntotpEnrollmentCode: {\n  codePlaceholder: 'Enter your passcode here',\n  headerText: 'Manually enter the following code into your preferred authenticator app and then enter the provided one-time code below.',\n  copyCodeButton: 'Copy code'\n},\n\nsmsEnrollmentAddPhoneNumber: {\n  headerText: 'Please enter your phone<br />in order to enroll.',\n  phoneNumberLabel: 'A code will be sent to this number:',\n  phoneNumberPlaceholder: 'Your phone number'\n  // countryCodes: { 'US': 'Translation of United States', ... '<country code>': '<translation>' }\n},\n\nauthCongrats: {\n  congrats: 'We have verified your identity. Redirecting...',\n  congratsNoRedirect: 'We have verified your identity.',\n  continueButtonText: 'Continue'\n},\n\nerrorMessages: {\n  alreadyEnrolled: 'You are already enrolled, cannot enroll again',\n  authMethodDisabled: 'The specified authentication method is disabled',\n  connectionError: 'Looks like we cannot contact our server. Please check your internet connection and retry.',\n  default: 'Looks like something went wrong. Please retry.',\n  defaultRequest: 'Looks like we found a problem contacting our server. Please retry.',\n  enrollmentConflict: 'Seems that you have already enrolled. Try logging in again from the application.',\n  enrollmentMethodDisabled: 'The specified enrollment method is disabled',\n  enrollmentNotFound: 'We couldn\\'t find your enrollment. You\\'ve probably started enrollment from another device. Finish it there or try logging in again from the application.',\n  enrollmentTransactionNotFound: 'The mfa enrollment transaction is not active or has expired. Please try again.',\n  errorSendingPushNotification: 'We found an error sending your notification. Please try again.',\n  errorSendingPushNotificationManualFallback: 'We could not send the push. Please enter the code manually.',\n  errorSendingSms: 'We found an error sending your code. Please try again in a few seconds.',\n  errorSendingSmsManualFallback: 'We could not send the sms. Please try the recovery code.',\n  featureDisabled: 'This module is currently disabled.',\n  featureDisabledByAdmin: 'This module was disabled by the admin.',\n  fieldRequired: 'Please fill out required field.',\n  globalTransactionExpired: 'Your login attempt has timed out.',\n  guardianInvalidNonce: 'There was a problem authenticating your request origin. Have you started too many parallel logins?',\n  guardianInvalidToken: 'There was a problem validating authentication request format.',\n  insufficientScope: 'Seems that you are not authorized to perform this action.',\n  invalidBearerFormat: 'Seems that you are not authorized to perform this action.',\n  invalidLoginTokenStatus: 'Unexpected state validating your request.',\n  invalidOtp: 'Seems that your code is not valid, please check and retry.',\n  invalidOtpFormat: 'OTP Code must have 6 numeric characters',\n  invalidPhoneNumber: 'Seems that your phone number is not valid. Please check and retry.',\n  invalidRecoveryCode: 'Seems that your recovery code is not valid. Please check and try again.',\n  invalidRecoveryCodeFormat: 'Recovery code must have 24 alphanumeric characters',\n  invalidToken: 'Seems that you are not authorized to perform this action.',\n  loginRejected: 'Auth has been rejected. Try again.',\n  loginTokenInvalidSignature: 'We cannot verify who seems to be the issuer for this request',\n  loginTokenTransactionExpired: 'Your authentication request is expired. Is your connection slow?',\n  loginTransactionNotFound: 'Seems that your device has taken too long to login. Please try again.',\n  noMethodAvailable: 'There is currently no authentication method available.',\n  noPublicKeyAvailable: 'We cannot verify your identity. Contact tenant admin.',\n  pnEndpointDisabled: 'Seems that we cannot deliver messages to your cell phone. Please try again.',\n  pushNotificationNotConfigured: 'Seems that enrollment was not finished. Please try logging in again from the application.',\n  pushNotificationWrongCredentials: 'Seems that your device credentials are outdated. Please re-enroll your device or wait for them to be updated.',\n  smsNotConfigured: 'You cannot use this module because you\\'ve enrolled with a different one.',\n  // tenant_not_found | The tenant associated cannot be found. Should not normally happen at least that you delete the tenant\n  tooManyPn: 'You have exceeded the amount of push notifications per minute. Please wait and try again.',\n  tooManyPnPerTenant: 'There are too many push requests right now. Wait a few minutes and try again.',\n  tooManySms: 'You have exceeded the amount of SMSs per hour. Wait a few minutes and try again.',\n  tooManySmsPerTenant: 'There are too many SMSs right now.  Wait a few minutes and try again.'\n  // | transaction_expired | The transaction has already expired |\n},\n\nsuccessMessages: {\n  auth: 'We have successfully verified your identity. Redirecting...',\n  pushSent: 'We\\'ve sent a push to: {enrollmentName}',\n  smsSent: 'We\\'ve sent an sms to: {phoneNumber}'\n},\n\ninfoMessages: {\n  iddle: 'Can we help you?<br></br><iddleHelp>Click here to learn more</iddleHelp>'\n}\n```",
    "title": "MFA Theme Language Dictionary",
    "description": "Describes the MFA hosted page configuration options for customizing the theme properties of the MFA pages.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api",
    "markdown": "# Auth0 MFA API\n\nAuth0 provides a built-in multi-factor authentication (MFA) enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). Use the [MFA API](https://auth0.com/docs/api/authentication#multi-factor-authentication) in the following scenarios if you want to:\n\n*   [Authenticate users with the Resource Owner Password Grant](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   Build an interface to let [users manage their own authentication factors](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\nTo use the MFA API, you must enable the MFA grant type for your application. To enable the MFA grant in the Auth0 Dashboard, go to [Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**. See [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) for details.\n\n## Limitations\n\nThe MFA API is designed to work with SMS, Voice, push via the Auth0 Guardian app, email, and OTP factors. It does not currently support enrolling with Duo or WebAuthn.\n\n## Learn more\n\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)\n*   [Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa)\n*   [Multi-Factor Authentication Developer Resources](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources)\n*   [Create Custom Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets)",
    "title": "Auth0 MFA API",
    "description": "Describes the Auth0 MFA API which allows you to enroll and manage MFA for users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options",
    "markdown": "# MFA Widget Theme Options\n\nWhen using your own HTML for MFA pages with Classic Login, it relies on the Auth0 MFA Widget which has the following limitations:\n\n*   It does not support MFA with email.\n    \n*   If users enrolled more than one factor, they cannot select which one to use, the MFA widget prompts them to login with the most secure factor.\n    \n*   It does not use Universal Login's [internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization) features.\n    \n\nThe theme options for the MFA Widget are namespaced under the `theme` property.\n\n| Option | Description |\n| --- | --- |\n| `icon` | The URL for the imaged used in the header. Default is the Auth0 logo. Recommended height is 58 pixels. |\n| `primaryColor` | Defines the primary color of the MFA widget. Useful when using a custom `icon` to ensure complimentary colors appear. Default is `#ea5323`. |\n\n## Examples\n\n```\nreturn new Auth0MFAWidget({\n\n...\n\n  theme: {\n    icon: 'https://example.com/assets/logo.png',\n    primaryColor: 'blue'\n  },\n  \n...  \n  \n})\n```\n\nSee a [Guardian basic widget example](https://github.com/auth0/auth0-guardian.js/blob/master/example/basic_widget.html) using [auth0-guardian.js](https://github.com/auth0/auth0-guardian.js). See the [readme](https://github.com/auth0/auth0-guardian.js/tree/master/example) for details.\n\n## Learn more\n\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)",
    "title": "MFA Widget Theme Options",
    "description": "Describes the MFA Widget theme options for customizing the theme properties of the MFA pages.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object",
    "markdown": "# Actions Triggers: post-login - Event Object\n\nThe `event` object for the post-login Actions trigger provides contextual information about a single user logging in via Auth0.\n\n| Property | Description |\n| --- | --- |\n| `event.authentication`<br><br>_(Optional)_ | Details about authentication signals obtained during the login flow.<br><br>Includes the following properties:<br><br>*   `methods` _Array of objects_.<br>    <br>    Contains the authentication methods a user has completed during their session.<br>    <br>    Array elements:<br>    <br>    *   One of the following object schemas:<br>        <br>        *   An object with the following properties:<br>            <br>            *   `name` _String_.<br>                <br>                The name of the first factor that was completed. Values include the following:<br>                <br>                *   `\"federated\"` A social or enterprise connection was used to authenticate the user as the first factor.<br>                *   `\"pwd\"` A password was used to authenticate a database connection user as the first factor.<br>                *   `\"passkey\"` A passkey was used to authenticate a database connnection user as the first factor.<br>                *   `\"sms\"` A Passwordless SMS connection was used to authenticate the user as the first factor.<br>                *   `\"email\"` A Passwordless Email connection was used to authenticate the user as the first factor or verify email for password reset.<br>                *   `\"phone_number\"` A phone number was used for password reset.<br>                *   `\"mock\"` Used for internal testing.<br>                *   `string` A custom authentication method denoted by a URL (as second or later factor).<br>            *   `timestamp` _String_.<br>        *   An object with the following properties:<br>            <br>            *   `name` _The value \"mfa\"_. The user completed multi-factor authentication (second or later factors).<br>            *   `timestamp` _String_.<br>*   `riskAssessment` _Optional object_.<br>    <br>    Details about risk assessments obtained during the login or password reset flow.<br>    <br>    Includes the following properties:<br>    <br>    *   `assessments` _Object_.<br>        <br>        Includes the following properties:<br>        <br>        *   `ImpossibleTravel` _Optional object_.<br>            <br>            Determines if the user is logging in from a location signaling impossible travel.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `minimal_travel_from_last_login`<br>                *   `travel_from_last_login`<br>                *   `substantial_travel_from_last_login`<br>                *   `impossible_travel_from_last_login`<br>                *   `invalid_travel`<br>                *   `missing_geoip`<br>                *   `anonymous_proxy`<br>                *   `unknown_location`<br>                *   `initial_login`<br>                *   `location_history_not_found`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>        *   `NewDevice` _Optional object_.<br>            <br>            Determines if the user is logging in from a known device.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `match`<br>                *   `partial_match`<br>                *   `no_match`<br>                *   `initial_login`<br>                *   `unknown_device`<br>                *   `no_device_history`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>            *   `details` _Optional object_.<br>                <br>                Includes the following properties:<br>                <br>                *   `device` _Optional string_.<br>                    <br>                    Possible values include:<br>                    <br>                    *   `known`<br>                    *   `unknown`<br>                *   `useragent` _Optional string_.<br>                    <br>                    Possible values include:<br>                    <br>                    *   `known`<br>                    *   `unknown`<br>        *   `UntrustedIP` _Optional object_.<br>            <br>            Shows if the IP was found in Auth0's repository of low reputation IPs.<br>            <br>            Includes the following properties:<br>            <br>            *   `code` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `not_found_on_deny_list`<br>                *   `found_on_deny_list`<br>                *   `invalid_ip_address`<br>                *   `assessment_not_available`<br>            *   `confidence` _String_.<br>                <br>                Possible values include:<br>                <br>                *   `low`<br>                *   `medium`<br>                *   `high`<br>                *   `neutral`<br>            *   `details` _Optional object_.<br>                <br>                Includes the following properties:<br>                <br>                *   `category` _Optional string_.<br>                *   `ip` _Optional string_. The originating IP address of the request.<br>                *   `matches` _Optional string_.<br>                *   `source` _Optional string_.<br>    *   `confidence` _String_.<br>        <br>        Overall risk score<br>        <br>        Possible values include:<br>        <br>        *   `low`<br>        *   `medium`<br>        *   `high`<br>        *   `neutral`<br>    *   `version` _String_. |\n| `event.authorization`<br><br>_(Optional)_ | An object containing information describing the authorization granted to the user who is logging in.<br><br>Includes the following properties:<br><br>*   `roles` _Array of strings_. An array containing the names of a user's assigned roles. |\n| `event.client` | Information about the Client with which this login transaction was initiated.<br><br>Includes the following properties:<br><br>*   `client_id` _String_. The client id of the application the user is logging in to.<br>*   `metadata` _Dictionary_. An object for holding other application properties.<br>*   `name` _String_. The name of the application (as defined in the Dashboard). |\n| `event.connection` | Details about the Connection that was used to authenticate the user.<br><br>Includes the following properties:<br><br>*   `id` _String_. The connection's unique identifier.<br>*   `metadata` _Optional dictionary_. Metadata associated with the connection.<br>*   `name` _String_. The name of the connection used to authenticate the user (such as `twitter` or `some-g-suite-domain`).<br>*   `strategy` _String_. The type of connection. For social connections, `event.connection.strategy === event.connection.name`. For enterprise connections, the strategy is `waad` (Windows Azure AD), `ad` (Active Directory/LDAP), `auth0` (database connections), and so on. |\n| `event.organization`<br><br>_(Optional)_ | Details about the Organization associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `display_name` _String_. The friendly name of the Organization.<br>*   `id` _String_. The Organization identifier.<br>*   `metadata` _Dictionary_. Metadata associated with the Organization.<br>*   `name` _String_. The name of the Organization. |\n| `event.refresh_token`<br><br>_(Optional)_ | \\[Private Early Access\\] The current refresh token.<br><br>Includes the following properties:<br><br>*   `client_id` _Optional string_. \\[Private Early Access\\] The ID of the client associated with the refresh token.<br>*   `created_at` _String_. \\[Private Early Access\\] Timestamp of when the refresh token was created.<br>*   `device` _Optional object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `initial_asn` _Optional string_. \\[Private Early Access\\] First autonomous system number associated with this refresh token.<br>    *   `initial_ip` _Optional string_. \\[Private Early Access\\] First IP address associated with this refresh token.<br>    *   `initial_user_agent` _Optional string_. \\[Private Early Access\\] First user agent of the device associated with this refresh token.<br>    *   `last_asn` _Optional string_. \\[Private Early Access\\] Last autonomous system number from which this refresh token was last exchanged.<br>    *   `last_ip` _Optional string_. \\[Private Early Access\\] Last IP address from which this refresh token was last exchanged.<br>    *   `last_user_agent` _Optional string_. \\[Private Early Access\\] Last user agent of the device from which this refresh token was last exchanged.<br>*   `expires_at` _Optional string_. \\[Private Early Access\\] Timestamp of when the refresh token will absolutely expire.<br>*   `id` _String_. \\[Private Early Access\\] The ID of the refresh token.<br>*   `idle_expires_at` _Optional string_. \\[Private Early Access\\] Timestamp of when the refresh token will idle expire.<br>*   `resource_servers` _Optional array of objects_.<br>    <br>    Elements include the following properties:<br>    <br>    *   `audience` _String_. \\[Private Early Access\\] The audience of the refresh token.<br>    *   `scopes` _String_. \\[Private Early Access\\] Scopes of the refresh token.<br>*   `rotating` _Optional boolean_. \\[Private Early Access\\] If the refresh token is a rotating refresh token.<br>*   `session_id` _Optional string_. \\[Private Early Access\\] The ID of the session bound to the refresh token.<br>*   `user_id` _Optional string_. \\[Private Early Access\\] The ID of the user bound to the refresh token. |\n| `event.request` | Details about the request that initiated the transaction.<br><br>Includes the following properties:<br><br>*   `asn` _Optional string_. The ASN (autonomous system number) of the user-agent making the request.<br>*   `body` _Dictionary_. The body of the POST request. This data will only be available during refresh token and Client Credential Exchange flows and Post Login Action.<br>*   `geoip` _Object_.<br>    <br>    Includes the following properties:<br>    <br>    *   `cityName` _Optional string_.<br>    *   `continentCode` _Optional string_.<br>    *   `countryCode` _Optional string_.<br>    *   `countryCode3` _Optional string_.<br>    *   `countryName` _Optional string_.<br>    *   `latitude` _Optional number_.<br>    *   `longitude` _Optional number_.<br>    *   `subdivisionCode` _Optional string_.<br>    *   `subdivisionName` _Optional string_.<br>    *   `timeZone` _Optional string_.<br>*   `hostname` _Optional string_. The hostname that is being used for the authentication flow.<br>*   `ip` _String_. The originating IP address of the request.<br>*   `language` _Optional string_. The language requested by the browser.<br>*   `method` _String_. The HTTP method used for the request<br>*   `query` _Dictionary_. The query string parameters sent to the authorization request.<br>*   `user_agent` _Optional string_. The value of the `User-Agent` header received when initiating the transaction. |\n| `event.resource_server`<br><br>_(Optional)_ | Details about the resource server to which the access is being requested.<br><br>Includes the following properties:<br><br>*   `identifier` _String_. The identifier of the resource server. For example: `https://your-api.example.com`. |\n| `event.session`<br><br>_(Optional)_ | The current login session.<br><br>Includes the following properties:<br><br>*   `authenticated_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was last authenticated.<br>*   `authentication` _Optional object_.<br>    <br>    \\[Private Early Access\\] Details about authentication signals obtained during the login flow.<br>    <br>    Includes the following properties:<br>    <br>    *   `methods` _Array of objects_.<br>        <br>        \\[Private Early Access\\] Contains the authentication methods a user has completed during their session.<br>        <br>        Array elements:<br>        <br>        *   \\[Private Early Access\\] Details about authentication signals obtained during the login flow.<br>            <br>            Includes the following properties:<br>            <br>            *   `name` _String_. \\[Private Early Access\\] One of: \"federated\", \"passkey\", \"pwd\", \"sms\", \"email\", \"mfa\", \"mock\" or a custom method denoted by a URL.<br>            *   `timestamp` _String_. \\[Private Early Access\\] Timestamp of when the signal was received.<br>            *   `type` _Optional string_. \\[Private Early Access\\] A specific MFA factor. Only present when \"name\" is set to \"mfa\"<br>*   `clients` _Optional array of objects_.<br>    <br>    \\[Private Early Access\\] List of client details for the session.<br>    <br>    Elements include the following properties:<br>    <br>    *   `client_id` _String_. \\[Private Early Access\\] ID of client for the session.<br>*   `created_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was created.<br>*   `device` _Optional object_.<br>    <br>    \\[Private Early Access\\] Metadata related to the device used in the session.<br>    <br>    Includes the following properties:<br>    <br>    *   `initial_asn` _Optional string_. \\[Private Early Access\\] First autonomous system number associated with this session.<br>    *   `initial_ip` _Optional string_. \\[Private Early Access\\] First IP address associated with this session.<br>    *   `last_asn` _Optional string_. \\[Private Early Access\\] Last autonomous system number from which this user logged in.<br>    *   `last_ip` _Optional string_. \\[Private Early Access\\] Last IP address from which this user logged in.<br>    *   `last_user_agent` _Optional string_. \\[Private Early Access\\] Last user agent of the device from which this user logged in.<br>*   `expires_at` _Optional string_. \\[Private Early Access\\] The date and time when the session will expire.<br>*   `id` _String_. The ID of the current session.<br>*   `idle_expires_at` _Optional string_. \\[Private Early Access\\] The date and time when the session will expire if idle.<br>*   `updated_at` _Optional string_. \\[Private Early Access\\] The date and time when the session was last updated.<br>*   `user_id` _Optional string_. \\[Private Early Access\\] ID of the user which can be used when interacting with other APIs. |\n| `event.stats` | Login statistics for the current user.<br><br>Includes the following properties:<br><br>*   `logins_count` _Number_. The number of times this user has logged in. |\n| `event.tenant` | Details about the Tenant associated with the current transaction.<br><br>Includes the following properties:<br><br>*   `id` _String_. The name of the tenant. |\n| `event.transaction`<br><br>_(Optional)_ | Details about the current transaction.<br><br>Includes the following properties:<br><br>*   `acr_values` _Array of strings_. Any acr\\_values provided in the original authentication request.<br>*   `linking_id` _Optional string_. Dynamic Linking ID that allows developers to reference this transaction.<br>*   `locale` _String_. The locale to be used for this transaction as determined by comparing the browser's requested languages to the tenant's language settings.<br>*   `login_hint` _Optional string_. Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary).<br>*   `prompt` _Optional array of strings_. List of instructions indicating whether the user may be prompted for re-authentication and consent.<br>*   `protocol` _Optional string_.<br>    <br>    Possible values include:<br>    <br>    *   `oidc-basic-profile` Most used, web-based login.<br>    *   `oidc-implicit-profile` Used on mobile devices and single-page apps.<br>    *   `samlp` SAML protocol used on SaaS apps.<br>    *   `wsfed` WS-Federation used on Microsoft products like Office365.<br>    *   `wstrust-usernamemixed` WS-trust User/password login used on CRM and Office365.<br>    *   `oauth2-device-code` Transaction using the Device Authorization Flow.<br>    *   `oauth2-resource-owner` User/password login typically used on database connections.<br>    *   `oauth2-resource-owner-jwt-bearer` Login using a bearer JWT signed with user's private key.<br>    *   `oauth2-password` Login using the password exchange.<br>    *   `oauth2-access-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-refresh-token` Refreshing a token using the refresh token exchange.<br>    *   `oauth2-token-exchange`<br>    *   `oidc-hybrid-profile` Allows your application to have immediate access to an ID token while still providing for secure and safe retrieval of access and refresh tokens.<br>*   `redirect_uri` _Optional string_. The URL to which Auth0 will redirect the browser after the transaction is completed.<br>*   `requested_authorization_details` _Optional array of objects_.<br>    <br>    The details of a rich authorization request per Section 2 of the Rich Authorization Requests spec at https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#section-2.<br>    <br>    Elements include the following properties:<br>    <br>    *   `type` _String_. The type of authorization details as a string. The value of the type field determines the allowable contents of the object which contains it.<br>*   `requested_scopes` _Array of strings_. The scopes requested (if any) when starting this authentication flow.<br>*   `response_mode` _Optional string_.<br>    <br>    Informs the Authorization Server of the mechanism to be used for returning parameters from the Authorization Endpoint.<br>    <br>    Possible values include:<br>    <br>    *   `query`<br>    *   `fragment`<br>    *   `form_post`<br>    *   `web_message`<br>*   `response_type` _Optional array of strings_.<br>    <br>    Possible values include:<br>    <br>    *   `code`<br>    *   `token`<br>    *   `id_token`<br>*   `state` _Optional string_. An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application.<br>*   `ui_locales` _Array of strings_. The ui\\_locales provided in the original authentication request. |\n| `event.user` | An object describing the user on whose behalf the current transaction was initiated.<br><br>Includes the following properties:<br><br>*   `app_metadata` _Dictionary_. Custom fields that store info about a user that influences the user's access, such as support plan, security roles, or access control groups.<br>*   `created_at` _String_. Timestamp indicating when the user profile was first created.<br>*   `email` _Optional string_. (unique) User's email address.<br>*   `email_verified` _Boolean_. Indicates whether the user has verified their email address.<br>*   `enrolledFactors` _Optional array of objects_.<br>    <br>    An an array of authentication factors that the user has enrolled.<br>    <br>    Array elements:<br>    <br>    *   An object describing an enrolled authentication factor type and any factor-specific options.<br>        <br>        Includes the following properties:<br>        <br>        *   `options` _Optional dictionary_. Additional options describing this instance of the enrolled factor.<br>        *   `type` _String_. The type of authentication factor such as `push-notification`, `phone`, `email`, `otp`, `webauthn-roaming` and `webauthn-platform`.<br>*   `family_name` _Optional string_. User's family name.<br>*   `given_name` _Optional string_. User's given name.<br>*   `identities` _Array of objects_.<br>    <br>    Contains info retrieved from the identity provider with which the user originally authenticates. Users may also link their profile to multiple identity providers; those identities will then also appear in this array. The contents of an individual identity provider object varies by provider.<br>    <br>    Elements include the following properties:<br>    <br>    *   `connection` _Optional string_. Name of the Auth0 connection used to authenticate the user.<br>    *   `isSocial` _Optional boolean_. Indicates whether the connection is a social one.<br>    *   `profileData` _Optional dictionary_. User information associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br>    *   `provider` _Optional string_. Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>    *   `user_id` _Optional string_. User's unique identifier for this connection/provider.<br>*   `last_password_reset` _Optional string_. Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections.<br>*   `multifactor` _Optional array of strings_. List of multi-factor authentication (MFA) providers with which the user is enrolled. This array is updated when the user enrolls in MFA and when an administrator resets a user's MFA enrollments.<br>*   `name` _Optional string_. User's full name.<br>*   `nickname` _Optional string_. User's nickname.<br>*   `phone_number` _Optional string_. User's phone number.<br>*   `phone_verified` _Optional boolean_. Indicates whether the user has verified their phone number.<br>*   `picture` _Optional string_. URL pointing to the [user's profile picture](https://auth0.com/docs/users/change-user-picture).<br>*   `updated_at` _String_. Timestamp indicating when the user's profile was last updated/modified.<br>*   `user_id` _String_. (unique) User's unique identifier.<br>*   `user_metadata` _Dictionary_. Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences.<br>*   `username` _Optional string_. (unique) User's username. |",
    "title": "Actions Triggers: post-login - Event Object",
    "description": "Learn about the post-login Action trigger's event object, which provides contextual information about a single user logging in via Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators",
    "markdown": "# Enroll and Challenge OTP Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure OTP](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with OTP\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nTo enroll with OTP, set the `authenticator_types` parameter to `[otp]`.\n\n*   [cURL](#c67037cdde834956a7fad57130f8349e_shell)\n*   [C#](#c67037cdde834956a7fad57130f8349e_csharp)\n*   [Go](#c67037cdde834956a7fad57130f8349e_go)\n*   [Java](#c67037cdde834956a7fad57130f8349e_java)\n*   [Node.JS](#c67037cdde834956a7fad57130f8349e_node)\n*   [Obj-C](#c67037cdde834956a7fad57130f8349e_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"otp\"] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {authenticator_types: ['otp']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"otp\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"authenticator_types\": [\"otp\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n  \"authenticator_type\": \"otp\",\n  \"secret\": \"EN...S\",\n  \"barcode_uri\": \"otpauth://totp/tenant:user?secret=...&issuer=tenant&algorithm=SHA1&digits=6&period=30\",\n  \"recovery_codes\": [ \"N3B...XC\"]\n}\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm OTP enrollment\n\nTo confirm the enrollment, the end user will need to enter the secret obtained in the previous step in an OTP generator application like Google Authenticator. They can enter the secret by scanning a QR code with the `barcode_uri` or by typing the secret code manually in that OTP application. You should provide users a way to get the secret as text in case they cannot scan the QR code (for example, if they are enrolling from a mobile device, or using a desktop OTP application).\n\nAfter the user enters the secret, the OTP application will display a 6-digit code, that the user should enter in your application. The application should then make a `POST` request to the OAuth Token endpoint, including that `otp` value.\n\n*   [cURL](#017aebdde879477ea6c70a0f6c8698d5_shell)\n*   [C#](#017aebdde879477ea6c70a0f6c8698d5_csharp)\n*   [Go](#017aebdde879477ea6c70a0f6c8698d5_go)\n*   [Java](#017aebdde879477ea6c70a0f6c8698d5_java)\n*   [Node.JS](#017aebdde879477ea6c70a0f6c8698d5_node)\n*   [Obj-C](#017aebdde879477ea6c70a0f6c8698d5_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-otp \\\n  --data 'client_id={yourClientId}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'otp={userOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n    client_id: '{yourClientId}',\n    mfa_token: '{mfaToken}',\n    client_secret: '{yourClientSecret}',\n    otp: '{userOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&otp={userOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&otp={userOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\n## Challenge with OTP\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_shell)\n*   [C#](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_csharp)\n*   [Go](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_go)\n*   [Java](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_java)\n*   [Node.JS](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_node)\n*   [Obj-C](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a list of authenticators with the following format:\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_qpOkGUOxBpw6R16t\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"totp|dev_6NWz8awwC8brh2dN\",\n        \"authenticator_type\": \"otp\",\n        \"active\": true\n    }\n]\n```\n\n### Challenge user with OTP\n\nTo trigger an OTP challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#dfb56fd34aca4302ab51a8ea05224ebc_shell)\n*   [C#](#dfb56fd34aca4302ab51a8ea05224ebc_csharp)\n*   [Go](#dfb56fd34aca4302ab51a8ea05224ebc_go)\n*   [Java](#dfb56fd34aca4302ab51a8ea05224ebc_java)\n*   [Node.JS](#dfb56fd34aca4302ab51a8ea05224ebc_node)\n*   [Obj-C](#dfb56fd34aca4302ab51a8ea05224ebc_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"challenge_type\": \"otp\", \"mfa_token\": \"{mfaToken}\", \"authenticator_id\" : \"totp|dev_6NWz8awwC8brh2dN\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    challenge_type: 'otp',\n    mfa_token: '{mfaToken}',\n    authenticator_id: 'totp|dev_6NWz8awwC8brh2dN'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"challenge_type\": @\"otp\",\n                              @\"mfa_token\": @\"{mfaToken}\",\n                              @\"authenticator_id\": @\"totp|dev_6NWz8awwC8brh2dN\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"challenge_type\": \"otp\",\n  \"mfa_token\": \"{mfaToken}\",\n  \"authenticator_id\": \"totp|dev_6NWz8awwC8brh2dN\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf successful, you receive the following response:\n\n```\n{\n  \"challenge_type\": \"otp\"\n}\n```\n\nThe user will collect a one time password, which you will then collect from them. You can verify the code and get authentication tokens using the OAuth0 Token endpoint, specifying the one time password in the `otp` parameter:\n\n*   [cURL](#47dd6242fa544db2a99b07575d4fb2d6_shell)\n*   [C#](#47dd6242fa544db2a99b07575d4fb2d6_csharp)\n*   [Go](#47dd6242fa544db2a99b07575d4fb2d6_go)\n*   [Java](#47dd6242fa544db2a99b07575d4fb2d6_java)\n*   [Node.JS](#47dd6242fa544db2a99b07575d4fb2d6_node)\n*   [Obj-C](#47dd6242fa544db2a99b07575d4fb2d6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-otp \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'otp={userOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    otp: '{userOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&otp={userOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&otp={userOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the format below, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)",
    "title": "Enroll and Challenge OTP Authenticators",
    "description": "Describes how to build your own MFA flows using one-time password (OTP) as an authentication factor.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators",
    "markdown": "# Enroll and Challenge Push Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\nYou can enroll and challenge users using push notifications with the Guardian application or SDK using the MFA API.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure Push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with push\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nTo enroll with push, set the `authenticator_types` parameter to `[oob]` and the `oob_channels` parameter to `[auth0]`.\n\n*   [cURL](#dd6af4895af6435cb7a3e0f2fa56548f_shell)\n*   [C#](#dd6af4895af6435cb7a3e0f2fa56548f_csharp)\n*   [Go](#dd6af4895af6435cb7a3e0f2fa56548f_go)\n*   [Java](#dd6af4895af6435cb7a3e0f2fa56548f_java)\n*   [Node.JS](#dd6af4895af6435cb7a3e0f2fa56548f_node)\n*   [Obj-C](#dd6af4895af6435cb7a3e0f2fa56548f_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"oob\"], \"oob_channels\": [\"auth0\"] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {authenticator_types: ['oob'], oob_channels: ['auth0']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"oob\" ],\n                              @\"oob_channels\": @[ @\"auth0\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"auth0\\\"] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": [\"auth0\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n    \"authenticator_type\": \"oob\",\n    \"barcode_uri\": \"otpauth://totp/tenant:user?enrollment_tx_id=qfjn2eiNYSjU3xID7dBYeCBSrdREWJPY&base_url=tenan\",\n    \"recovery_codes\": [\n        \"ALKE6EJZ4853BJYLM2DM2WU7\"\n    ],\n    \"oob_channel\": \"auth0\",\n    \"oob_code\": \"Fe26.2...SYAg\"\n}\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm push enrollment\n\nTo confirm the enrollment, the end user will need to scan a QR code with the `barcode_uri` in the Guardian application, within the next 5 minutes.\n\nOnce that is done, the Guardian application will notify Auth0 that the user enrolled successfully. To know if that happened, poll the Auth0 Token endpoint with the `oob_code` returned by the MFA Associate endpoint call.\n\n*   [cURL](#9edc92c4e71f496ba38663298e0e88e4_shell)\n*   [C#](#9edc92c4e71f496ba38663298e0e88e4_csharp)\n*   [Go](#9edc92c4e71f496ba38663298e0e88e4_go)\n*   [Java](#9edc92c4e71f496ba38663298e0e88e4_java)\n*   [Node.JS](#9edc92c4e71f496ba38663298e0e88e4_node)\n*   [Obj-C](#9edc92c4e71f496ba38663298e0e88e4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'authorization: Bearer {mfaToken}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {mfaToken}\");\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mfaToken}\")\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"authorization\", \"Bearer {mfaToken}\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {\n    authorization: 'Bearer {mfaToken}',\n    'content-type': 'application/x-www-form-urlencoded'\n  },\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mfaToken}\",\n                           @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mfaToken}\",\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nheaders = {\n    'authorization': \"Bearer {mfaToken}\",\n    'content-type': \"application/x-www-form-urlencoded\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {mfaToken}'\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mfaToken}\",\n  \"content-type\": \"application/x-www-form-urlencoded\"\n]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the user has not scanned the code, it will return an `authorization_pending` response, indicating that you need to call `oauth_token` again in a few seconds:\n\n```\n{\n    \"error\": \"authorization_pending\",\n    \"error_description\": \"Authorization pending: please repeat the request in a few seconds.\"\n}\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\n## Challenge with push\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#4ae436a2c5974d6d88e418acb7741570_shell)\n*   [C#](#4ae436a2c5974d6d88e418acb7741570_csharp)\n*   [Go](#4ae436a2c5974d6d88e418acb7741570_go)\n*   [Java](#4ae436a2c5974d6d88e418acb7741570_java)\n*   [Node.JS](#4ae436a2c5974d6d88e418acb7741570_node)\n*   [Obj-C](#4ae436a2c5974d6d88e418acb7741570_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a list of authenticators with the following format:\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_Ahb2Tb0ujX3w7ilC\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"push|dev_ZUla9SQ6tAIHSz6y\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"auth0\",\n        \"name\": \"user's device name\"\n    },\n    {\n        \"id\": \"totp|dev_gJ6Y6vpSrjnKeT67\",\n        \"authenticator_type\": \"otp\",\n        \"active\": true\n    }\n]\n```\n\nWhen users enroll with push, they also get enrolled in OTP, as Guardian supports [challenging with OTP](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators) for scenarios where the user does not have connectivity.\n\n### Challenge user with push\n\nTo trigger a push challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#72789a943e404ea3b853a03d15eb5a33_shell)\n*   [C#](#72789a943e404ea3b853a03d15eb5a33_csharp)\n*   [Go](#72789a943e404ea3b853a03d15eb5a33_go)\n*   [Java](#72789a943e404ea3b853a03d15eb5a33_java)\n*   [Node.JS](#72789a943e404ea3b853a03d15eb5a33_node)\n*   [Obj-C](#72789a943e404ea3b853a03d15eb5a33_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{ \"client_id\": \"{yourClientId}\",  \"client_secret\": \"{yourClientSecret\", \"challenge_type\": \"oob\", \"authenticator_id\": \"push|dev_ZUla9SQ6tAIHSz6y\", \"mfa_token\": \"{mfaToken}\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret',\n    challenge_type: 'oob',\n    authenticator_id: 'push|dev_ZUla9SQ6tAIHSz6y',\n    mfa_token: '{mfaToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret\",\n                              @\"challenge_type\": @\"oob\",\n                              @\"authenticator_id\": @\"push|dev_ZUla9SQ6tAIHSz6y\",\n                              @\"mfa_token\": @\"{mfaToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"push|dev_ZUla9SQ6tAIHSz6y\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret\",\n  \"challenge_type\": \"oob\",\n  \"authenticator_id\": \"push|dev_ZUla9SQ6tAIHSz6y\",\n  \"mfa_token\": \"{mfaToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf success, you receive the following response:\n\n```\n{\n    \"challenge_type\": \"oob\",\n    \"oob_code\": \"Fe26...jGco\"\n}\n```\n\nYour application must start polling the OAuth0 Token endpoint until the user accepts the push notification.\n\n*   [cURL](#0c1cc763c9004019a7eb3bf167b081d8_shell)\n*   [C#](#0c1cc763c9004019a7eb3bf167b081d8_csharp)\n*   [Go](#0c1cc763c9004019a7eb3bf167b081d8_go)\n*   [Java](#0c1cc763c9004019a7eb3bf167b081d8_java)\n*   [Node.JS](#0c1cc763c9004019a7eb3bf167b081d8_node)\n*   [Obj-C](#0c1cc763c9004019a7eb3bf167b081d8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe call can return one of the following results:\n\n| Result | Description |\n| --- | --- |\n| `authorization_pending` | Error: If the challenge has not been accepted or rejected. |\n| `slow_down` | Error: If the polling is too frequent. |\n| `access_token` and `refresh_token` | If the challenge has been accepted; polling should be stopped at this point. |\n| `invalid_grant` | Error: If the challenge has been rejected: polling should be stopped at this point. |\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
    "title": "Enroll and Challenge Push Authenticators",
    "description": "Describes how to build your own MFA flows using push as an authentication factor.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators",
    "markdown": "# Enroll and Challenge Email Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\nWhen email is enabled as a factor, all users with verified emails will be able to use them to complete MFA.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure Email](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with email\n\nTo enable users to enroll emails in addition to their verified email in their primary identity, you need to complete the following steps.\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nUse the following parameters:\n\n| Parameter | Value |\n| --- | --- |\n| `authentication_types` | `[oob]` |\n| `oob_channels` | `[email]` |\n| `email` | `email@address.com`, the users email address. |\n\n*   [cURL](#6f05dd94d61f49ce8ba14d073a96ddce_shell)\n*   [C#](#6f05dd94d61f49ce8ba14d073a96ddce_csharp)\n*   [Go](#6f05dd94d61f49ce8ba14d073a96ddce_go)\n*   [Java](#6f05dd94d61f49ce8ba14d073a96ddce_java)\n*   [Node.JS](#6f05dd94d61f49ce8ba14d073a96ddce_node)\n*   [Obj-C](#6f05dd94d61f49ce8ba14d073a96ddce_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"oob\"], \"oob_channels\": [\"email\"], \"email\" : \"email@address.com\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {\n    authenticator_types: ['oob'],\n    oob_channels: ['email'],\n    email: 'email@address.com'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"oob\" ],\n                              @\"oob_channels\": @[ @\"email\" ],\n                              @\"email\": @\"email@address.com\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"email\\\"], \\\"email\\\" : \\\"email@address.com\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": [\"email\"],\n  \"email\": \"email@address.com\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n    \"authenticator_type\": \"oob\",\n    \"binding_method\": \"prompt\",\n    \"oob_code\" : \"Fe26..nWE\",\n    \"oob_channel\": \"email\",\n    \"recovery_codes\": [ \"N3BGPZZWJ85JLCNPZBDW6QXC\" ]\n  }\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm email enrollment\n\nThe user should receive an email containing the 6-digit code that they can provide to the application.\n\nTo complete the enrollment, make a `POST` request to the [**`/oath/token`**](https://auth0.com/docs/api/authentication#get-token) endpoint. Include the `oob_code` returned in the previous response and the `binding_code` with the value in the email message.\n\n*   [cURL](#b330b86f829d4e3dbb656db629ee6964_shell)\n*   [C#](#b330b86f829d4e3dbb656db629ee6964_csharp)\n*   [Go](#b330b86f829d4e3dbb656db629ee6964_go)\n*   [Java](#b330b86f829d4e3dbb656db629ee6964_java)\n*   [Node.JS](#b330b86f829d4e3dbb656db629ee6964_node)\n*   [Obj-C](#b330b86f829d4e3dbb656db629ee6964_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data 'binding_code={userEmailOtpCode}' \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: '{userEmailOtpCode}',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code={userEmailOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code={userEmailOtpCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\nOptionally, you can customize the emails that users receive. See [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates) for details.\n\n## Challenge with email\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#18f53b8c09354cb39df22ed8f7fa2786_shell)\n*   [C#](#18f53b8c09354cb39df22ed8f7fa2786_csharp)\n*   [Go](#18f53b8c09354cb39df22ed8f7fa2786_go)\n*   [Java](#18f53b8c09354cb39df22ed8f7fa2786_java)\n*   [Node.JS](#18f53b8c09354cb39df22ed8f7fa2786_node)\n*   [Obj-C](#18f53b8c09354cb39df22ed8f7fa2786_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Challenge user with OTP\n\nTo trigger an email challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#ee2a535b9a8e4b12b524bb444cbdc4e8_shell)\n*   [C#](#ee2a535b9a8e4b12b524bb444cbdc4e8_csharp)\n*   [Go](#ee2a535b9a8e4b12b524bb444cbdc4e8_go)\n*   [Java](#ee2a535b9a8e4b12b524bb444cbdc4e8_java)\n*   [Node.JS](#ee2a535b9a8e4b12b524bb444cbdc4e8_node)\n*   [Obj-C](#ee2a535b9a8e4b12b524bb444cbdc4e8_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{  \"client_id\": \"{yourClientId}\",  \"client_secret\": \"{yourClientSecret}\",  \"challenge_type\": \"oob\",  \"authenticator_id\": \"email|dev_NU1Ofuw3Cw0XCt5x\", \"mfa_token\": \"{mfaToken}\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    challenge_type: 'oob',\n    authenticator_id: 'email|dev_NU1Ofuw3Cw0XCt5x',\n    mfa_token: '{mfaToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"challenge_type\": @\"oob\",\n                              @\"authenticator_id\": @\"email|dev_NU1Ofuw3Cw0XCt5x\",\n                              @\"mfa_token\": @\"{mfaToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\",  \\\"challenge_type\\\": \\\"oob\\\",  \\\"authenticator_id\\\": \\\"email|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"challenge_type\": \"oob\",\n  \"authenticator_id\": \"email|dev_NU1Ofuw3Cw0XCt5x\",\n  \"mfa_token\": \"{mfaToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf successful, you receive the following response:\n\n```\n{\n  \"challenge_type\": \"oob\",\n  \"oob_code\": \"abcd1234...\",\n  \"binding_method\": \"prompt\"\n}\n```\n\nYour application should prompt the user for the code and send it as part of the request in the `binding_code` parameter in the following call to the `oauth``/token` endpoint:\n\n*   [cURL](#057f5620d6f649b2ac69f2ff28bbc340_shell)\n*   [C#](#057f5620d6f649b2ac69f2ff28bbc340_csharp)\n*   [Go](#057f5620d6f649b2ac69f2ff28bbc340_go)\n*   [Java](#057f5620d6f649b2ac69f2ff28bbc340_java)\n*   [Node.JS](#057f5620d6f649b2ac69f2ff28bbc340_node)\n*   [Obj-C](#057f5620d6f649b2ac69f2ff28bbc340_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data 'binding_code={userEmailOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: '{userEmailOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code={userEmailOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserEmailOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code={userEmailOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the format below, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
    "title": "Enroll and Challenge Email Authenticators",
    "description": "Describes how to build your own MFA flows using SMS or voice as an authentication factor.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/import-user-mfa-authenticator-enrollments",
    "markdown": "# Import User MFA Authenticator Enrollments\n\nYou can import a user's MFA enrollments with [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) and [bulk user imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports). The supported enrollment types are:\n\n*   Email: for email verification.\n    \n*   Phone: for SMS verification.\n    \n*   OTP: for One-Time Passwords (OTPs) used with authenticator applications, such as Google Authenticator.\n    \n\nImporting MFA enrollments provides a seamless user experience, since users won't have to re-enroll after migration.\n\nThe classic login experience does not support factor selection for users with multiple factors. If you plan to import users with multiple registered factors, consider using the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) experience.\n\n## Schema\n\nThe schema applies to MFA factors for both of the following workflows.\n\n```\n{\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"totp\": {\n                \"type\": \"object\",\n                \"properties\": {\n                \"secret\": {\n                    \"type\": \"string\",\n                        \"pattern\": \"^[A-Z2-7]+$\",\n                        \"description\": \"The OTP secret is used for MFA authentication with Google Authenticator type apps. It must be supplied in un-padded Base32 encoding, such as: JBTWY3DPEHPK3PNP\"\n                    },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"secret\"],\n            },\n            \"phone\": {\n                \"type\": \"object\",\n                \"properties\": {\n                \"value\": {\n                    \"type\": \"string\",\n                    \"pattern\": \"^\\\\+[0-9]{1,15}$\",\n                    \"description\": \"The phone number for SMS or Voice MFA. The phone number should include a country code and begin with +, such as: +12125550001\"\n                },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"value\"],\n            },\n            \"email\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"value\": {\n                        \"type\": \"string\",\n                        \"format\": \"email\",\n                        \"description\": \"The email address for MFA\"\n                    },\n                },\n                \"additionalProperties\": false,\n                \"required\": [\"value\"],\n            },\n        },\n        \"maxProperties\": 1,\n        \"additionalProperties\": false,\n    },\n    \"minItems\": 1,\n    \"maxItems\": 10\n}\n```\n\n## Automatic migration\n\nMFA enrollments can also be imported during an [automatic migration](https://auth0.com/docs/connections/database/custom-db/overview-custom-db-connections#automatic-migration-scenario). This can be accomplished by providing any existing enrollments in the `mfa_factors` field of the user that is provided to the callback at the end of your custom DB [login script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login).\n\nAny failures will appear in your tenant logs as failed logins, and will be distinguishable from other failures by their description: `Unable to import MFA factors`. For example:\n\n```\n{\n  \"_id\": \"5e9df3b29ebabe00571c04a7\",\n  \"date\": \"2020-04-20T19:10:42.916Z\",\n  \"type\": \"fu\",\n  \"description\": \"Unable to import MFA factors.\",\n  \"connection\": \"Username-Password-Authentication\",\n  \"connection_id\": \"con_mMkvaycgzgCS0p0z\",\n  \"client_id\": \"aCbTAJNi5HbsjPJtRpSP6BIoLPOrSj2Cgg\",\n  \"client_name\": \"All Applications\",\n  \"ip\": \"10.12.13.1\",\n  \"client_ip\": null,\n  \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n  \"details\": {\n    \"error\": {\n      \"message\": \"Unable to import MFA factors.\"\n    }\n  },\n  \"user_name\": \"test@test.io\",\n  \"strategy\": \"auth0\",\n  \"strategy_type\": \"database\"\n}\n```\n\n## Bulk user import\n\n1.  Prepare a `users.json` file. See [bulk user imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports) for details.\n    \n2.  Include existing MFA enrollments for each user.\n    \n3.  Start a bulk user import.\n    \n4.  Update the factors of any existing users by enabling the `upsert` option in your initial request.\n    \n5.  Once the import job completes, check the response for any errors. If any of the users' MFA factors failed to import, you will see errors such as:\n    \n\nWhen using the `upsert` option, any non-MFA related updates to existing users will have been applied to the user's profile. For example, the following error summary shows the user's `picture` attribute was successfully set to `http://example.org/jdoe.png`, however we were unable to import the provided MFA factors. In cases like this, it is safe to retry the import for failed users.\n\n```\n[\n  {\n    \"user\": {\n      \"email\": \"antoinette@contoso.com\",\n      \"picture\": \"http://example.org/jdoe.png\",\n      \"mfa_factors\": [\n        {\n          \"totp\": {\n            \"secret\": \"2PRXZWZAYYDAWCD\"\n          }\n        },\n        {\n          \"phone\": {\n            \"value\": \"+15551112233\"\n          }\n        },\n        {\n          \"email\": {\n            \"value\": \"antoinette@antoinette.biz\"\n          }\n        }\n      ]\n    },\n    \"errors\": [\n      {\n        \"code\": \"MFA_FACTORS_FAILED\",\n        \"message\": \"Unable to import factors\"\n      }\n    ]\n  }\n]\n```\n\n## Recovery codes\n\nAuth0 does not provide a way to import recovery codes. When the user's MFA factors are imported, they won't have a recovery code.\n\nTo provide users a recovery code, you can check if they have one enrolled, and if not, use the [Recovery Code Regeneration endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_recovery_code_regeneration) to generate a new one.\n\n## Learn more\n\n*   [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)",
    "title": "Import User MFA Authenticator Enrollments",
    "description": "Describes how to import MFA enrollments for your existing users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes",
    "markdown": "# Challenge with Recovery Codes\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'recovery_code={recoveryCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    recovery_code: '{recoveryCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&recovery_code={recoveryCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&recovery_code=%7BrecoveryCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&recovery_code={recoveryCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Challenge with Recovery Codes",
    "description": "Describes how to use the MFA API to challenge users who lose access to their device or account using recovery codes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps",
    "markdown": "# Configure Step-up Authentication for Web Apps\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger mechanism to access sensitive information or perform certain transactions.\n\nFor instance, a user may be allowed to access views with sensitive data or reset their password only after confirming their identity using multi-factor authentication (MFA).\n\nTo accomplish step-up authentication for your web app, you will create an Action that challenges the user to authenticate with MFA when the web app asks for it, check the ID Token claims for MFA if the user tries to access a restricted page, and then challenge the user if MFA is not included in the claim.\n\n## Validate ID tokens for MFA\n\nWhen a user logs in, you get an [ID token](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens) that contains information relevant to the user's session in the form of claims. The relevant claim is `amr` (authentication methods reference) which is a JSON array of strings that indicates the authentication method used during login. It must be present in the ID token's payload and must contain the value `mfa`.\n\nIts values may include any of the pre-defined [Authentication Method Reference Values](https://tools.ietf.org/html/rfc8176). Because it can contain claims other than `mfa`, when validating you must both test for its existence and examine its contents for a value of `mfa`.\n\nIf a user attempts to access a restricted page and the token shows that the user has not authenticated with MFA, then you can retrigger authentication, which you have configured to trigger MFA using an Action. Once the user provides the second factor, a new ID token that contains the `amr` claim is generated and sent to the app.\n\n1.  [Get the ID token](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens).\n    \n2.  Verify the token's signature, which is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way.\n    \n3.  Validate the following claims:\n    \n    | Claim | Description |\n    | --- | --- |\n    | `exp` | Token expiration |\n    | `iss` | Token issuer |\n    | `aud` | Intended recipient of the token |\n    | `amr` | If `amr` does not exist in the payload or does not contain the value `mfa`, the user did not log in with MFA. If `amr` exists in the payload and contains the value `mfa`, then the user did log in with MFA. |\n    \n\n#### AMR claim exceptions\n\nThe `amr` claim is required except in the following use cases:\n\n1.  In hosted login flows, only after the user successfully passes an MFA challenge, the `amr` claim is injected into the ID token. If the app uses silent authentication or Refresh Tokens for newly issued ID tokens, the `amr` claim will not be present because the user previously completed login with MFA.\n    \n2.  MFA API issued tokens do not contain the `amr` claim. The `amr` claim flags the authentication methods used when the user receives the ID Token. In the MFA API authentication process, the application controls the authentication flow and can enforce MFA as needed.\n    \n\nIn the examples below, you can compare the potential values included in an ID token's payload when a user has authenticated with MFA versus when they have not.\n\n### Example: Values with MFA\n\nto configure this snippet with your account\n\n```\n{\n    \"iss\": \"https://{yourDomain}/\",\n    \"sub\": \"auth0|1a2b3c4d5e6f7g8h9i\",\n    \"aud\": \"{yourClientId}\",\n    \"iat\": 1522838054,\n    \"exp\": 1522874054,\n    \"acr\": \"http://schemas.openid.net/pape/policies/2007/06/multi-factor\",\n    \"amr\": [\n        \"mfa\"\n    ]\n}\n```\n\n### Example: Values without MFA\n\n```\n{\n    \"iss\": \"https://{yourDomain}/\",\n    \"sub\": \"auth0|1a2b3c4d5e6f7g8h9i\",\n    \"aud\": \"{yourClientId}\",\n    \"iat\": 1522838054,\n    \"exp\": 1522874054\n}\n```\n\n## Scenario: Salary data with push notifications\n\nIn the following scenario, a web app authenticates a user with a username and password. Some users want to access a specific screen that displays salary data, so they must authenticate with Guardian push factor.\n\n### Prerequisites\n\nFor this scenario, you must configure the following items in the Dashboard:\n\n*   [Register a web app](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n    \n*   [Create a database connection](https://manage.auth0.com/#/connections/database).\n    \n*   [Enable MFA](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) to use push notifications.\n    \n\n### Create an Action\n\nCreate an Action that challenges the user to authenticate with MFA when the web app requests it. Go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows), and create an Action that contains the following content:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n const CLIENTS_WITH_MFA = ['REPLACE_WITH_YOUR_CLIENT_ID'];\n // run only for the specified clients\n if (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n // ask for MFA only if the web app said so in the authentication request\n if (event.transaction?.acr_values.includes('http://schemas.openid.net/pape/policies/2007/06/multi-factor')) {\n api.multifactor.enable('any', { allowRememberBrowser: false });\n }\n }\n}\n```\n\n*   The `CLIENTS_WITH_MFA` variable contains the client IDs of the applications you want this Action to apply to. You can remove this (and the `if` conditional that follows) if you don't need it.\n    \n*   The `event.transaction.acr_values` property is an array of strings that contains the authentication context class reference(s) (`acr`). This is an optional property that only exists when the application includes it in the authentication request to the Authorization Server. In this example, our web app will include it in the authentication request, but only when a user who has not already authenticated with MFA tries to access salary information. When our web app includes it, it will set a value of `http://schemas.openid.net/pape/policies/2007/06/multi-factor`, which indicates that we want the Authorization Server to require MFA, and the `api.multifactor` property value that we set in our code will challenge the user for MFA using any of the available methods that have been configured in the tenant. To learn more about the `api.multifactor.enable()` method, read [Action Triggers: post-login API object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/api-object).\n    \n*   The `http://schemas.openid.net/pape/policies/2007/06/multi-factor` policy defines an authentication mechanism where the end user authenticates to the OpenID Provider by providing more than one authentication factor, or MFA. To learn more, read [OpenID Provider Authentication Policy Extension 1.0](https://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html).\n    \n\n### Configure app\n\nConfigure the app to check that the user has authenticated using MFA when a user tries to access the restricted salary information page. (When a user has authenticated with MFA, the ID token claims contain the `amr` claim with a value of `mfa`.) If the user has already authenticated with MFA, then the web app will display the restricted page; otherwise, the web app will send a new authentication request that includes the `acr_values` parameter with a value of: `http://schemas.openid.net/pape/policies/2007/06/multi-factor` which will trigger the Action.\n\nThe web app in this scenario uses the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) to authenticate, so the request is as follows:\n\n```\nhttps://{yourDomain}/authorize?\n        audience=https://{yourDomain}/userinfo&\n        scope=openid&\n        response_type=code&\n        client_id={yourClientId}&\n        redirect_uri={https://yourApp/callback}&\n        state={yourOpaqueValue}&\n        acr_values=http://schemas.openid.net/pape/policies/2007/06/multi-factor\n```\n\nOnce the user authenticates with MFA, the web app receives the authorization code, which must be exchanged for the new ID token, which should now contain the `amr` claim with a value of `mfa`. To learn how to exchange the code for an ID token, read [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n\n### Validate ID token\n\nIn this scenario, perform the validations using the [JSON Web Token Sample Code](https://github.com/auth0/node-jsonwebtoken), which verifies the token's signature (`jwt.verify`), decodes the token, checks whether the payload contains `amr`, and if so, logs the results in the console.\n\n```\nconst AUTH0_CLIENT_SECRET = '{yourClientSecret}';\nconst jwt = require('jsonwebtoken');\n\njwt.verify(id_token, AUTH0_CLIENT_SECRET, { algorithms: ['HS256'] }, function(err, decoded) {\n  if (err) {\n    console.log('invalid token');\n    return;\n  }\n\n  if (Array.isArray(decoded.amr) && decoded.amr.indexOf('mfa') >= 0) {\n    console.log('You used mfa');\n    return;\n  }\n\n  console.log('you are not using mfa');\n});\n```\n\n## Learn more\n\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Rule Use Cases](https://auth0.com/docs/rules/use-cases)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis)",
    "title": "Configure Step-up Authentication for Web Apps",
    "description": "Learn how to check if a user has logged in your web app with Multi-factor Authentication (MFA) by examining their ID Token.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0",
    "markdown": "# Configure Identity Provider Connection for User Profile Updates\n\nYou can update connection preferences for an upstream identity provider so you can control when updates to user profile root attributes are allowed using the Auth0 Dashboard or the Management API.\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the name, nickname, given\\_name, family\\_name, or picture root attributes on the normalized user profile, you must configure your connection sync with Auth0 so that user attributes will be updated from the identity provider only on user profile creation.\n\nYou can edit [root attributes individually](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users) or as a [bulk import](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-import) using the Management API.\n\n## Use the Dashboard\n\n1.  Go to [Auth0 Dashboard > Authentication](https://manage.auth0.com/#/connections), and select the type of connection: Database, Social, Enterprise, or Passwordless.\n    \n2.  Select the name of a connection to see its settings.\n    \n3.  Locate the **Advanced** section, toggle the **Sync user profile attributes at each login** switch to the desired setting, and select **Save**.\n    \n    ![Dashboard - Authentication - Settings - Sync User Profile Attributes](https://images.ctfassets.net/cdy7uua7fh8z/4V2iUSkyaOMlXtHEACoVuW/b12b6c62fcc60371bd75d224229a6614/dashboard-connections-social-create_enter-details.png)\n\n## Use the Management API\n\nBefore completing this step, you should first [retrieve the existing values of the connection's `options` object](https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options) to avoid overriding the current values. If you do not, parameters missing from the original object will be lost after you update.\n\nMake a `PATCH` call to the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). Make sure you include the original options values in the call to avoid overriding the current values. Also, be sure to replace `CONNECTION_ID`, `MGMT_API_ACCESS_TOKEN`, and `ATTRIBUTE_UPDATE_VALUE` placeholder values with your connection ID, Management API access token, and attribute update value, respectively.\n\n*   [cURL](#fbba7651386a4341a2d0b7040538c164_shell)\n*   [C#](#fbba7651386a4341a2d0b7040538c164_csharp)\n*   [Go](#fbba7651386a4341a2d0b7040538c164_go)\n*   [Java](#fbba7651386a4341a2d0b7040538c164_java)\n*   [Node.JS](#fbba7651386a4341a2d0b7040538c164_node)\n*   [Obj-C](#fbba7651386a4341a2d0b7040538c164_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\":{\"set_user_root_attributes\": \"ATTRIBUTE_UPDATE_VALUE\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {options: {set_user_root_attributes: 'ATTRIBUTE_UPDATE_VALUE'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"set_user_root_attributes\": @\"ATTRIBUTE_UPDATE_VALUE\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{\\\"options\\\":{\\\"set_user_root_attributes\\\": \\\"ATTRIBUTE_UPDATE_VALUE\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"options\": [\"set_user_root_attributes\": \"ATTRIBUTE_UPDATE_VALUE\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `CONNECTION_ID` | ID of the connection for which you want to allow updates to root attributes. |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:connections`. |\n| `ATTRIBUTE_UPDATE_VALUE` | Indicates when you want to allow updates to user profile root attributes. Valid values are `on_first_login` and `on_each_login`. Defaults to `on_each_login` for new connections. |\n\n## Learn more\n\n*   [Retrieve Connection Options](https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options)\n*   [Set Root Attributes During User Import](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-import)\n*   [Set Root Attributes During User Signup](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/set-root-attributes-during-user-sign-up)\n*   [Update Root Attributes for Users](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users)\n*   [Promote Connections to Domain Level](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level)",
    "title": "Configure Identity Provider Connection for User Profile Updates",
    "description": "Learn how to update connection preferences for an upstream identity provider so you can control when user profile root attributes are updated.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis",
    "markdown": "# Configure Step-up Authentication for APIs\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger mechanism to access sensitive information or perform certain transactions.\n\nFor example, a user of a banking app may be allowed to transfer money between accounts only after they have confirmed their identity using multi-factor authentication (MFA).\n\nWhen your audience is an API, you can implement step-up authentication with Auth0 using scopes, access tokens, and [Actions](https://auth0.com/docs/customize/actions). When an application wants to access an API's protected resources, it must provide an access token. The resources that it will have access to depend on the permissions that are included in the access token. These permissions are defined as [scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n\n## Validate access tokens for MFA\n\nIn addition to checking the scope, the API must [validate the access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens) to:\n\n*   Verify the token's signature, used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way.\n    \n*   Validate the standard claims:\n    \n    | Claim | Description |\n    | --- | --- |\n    | `exp` | Token expiration |\n    | `iss` | Token issuer |\n    | `aud` | Intended recipient of the token |\n    \n\n## Scenario: Bank transactions with push notifications\n\nIn the following scenario, an application authenticates a user with username and password and then requests an account balance. Before retrieving the account balance information, the user must authenticate with Guardian push factor.\n\nThe banking API can accept two different levels of authorization: view account balance (scope `view:balance`) or transfer funds (scope `transfer:funds`). When the application asks the API to retrieve the user's balance, the access token should contain the `view:balance` scope. To transfer money to another account, the access token should contain the `transfer:funds` scope.\n\n### Workflow\n\n1.  The user logs in to the application using username and password authentication. The standard login gives this user the ability to interact with the API and fetch their balance. This means that the access token that the app receives after the user authenticates contains the `view:balance` scope.\n    \n2.  The application sends a request to the API to retrieve the balance, using the access token as credentials.\n    \n3.  The API validates the token and sends the balance info to the application, so the user can view it.\n    \n4.  The user wants to transfer funds from one account to another, which is deemed a high-value transaction that requires the `transfer:funds` scope. The application sends a request to the API using the same access token.\n    \n5.  The API validates the token and denies access because the token is missing the required `transfer:funds` scope.\n    \n6.  The application redirects to Auth0, where an Action is used to challenge the user to authenticate with MFA since a high-value scope was requested. Once the user successfully authenticates with MFA, a new access token that includes the correct scope is generated and sent to the application as part of the response.\n    \n7.  The application sends another transfer funds request using the new access token, which includes the `transfer:funds` scope this time.\n    \n8.  The API validates the token, discards it, and proceeds with the operation.\n    \n\n### Prerequisites\n\nFor this scenario, you must configure the following items in the Dashboard:\n\n*   [Register a Single-Page Web App](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n    \n*   [Create a database connection](https://manage.auth0.com/#/connections/database).\n    \n*   [Register the API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis). Create two scopes: `view:balance` and `transfer:funds`.\n    \n*   [Enable MFA](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) to use push notifications.\n    \n\n### Create an Action\n\nCreate an Action that challenges the user to authenticate with MFA when the `transfer:funds` scope is requested. Go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows) and create an Action that contains the following content:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const CLIENTS_WITH_MFA = ['REPLACE_WITH_YOUR_CLIENT_ID'];\n  // run only for the specified clients\n  if (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n    // ask for MFA only if scope transfer:funds was requested\n    if (event.transaction.requested_scopes.indexOf('transfer:funds') > -1)\n      api.multifactor.enable('any', { allowRememberBrowser: false });\n    }\n  }\n}\n```\n\n*   The `CLIENTS_WITH_MFA` variable contains the client IDs of the applications you want this Action to apply to. You can remove this (and the `if` conditional that follows) if you don't need it.\n    \n*   The `event.transaction.requested_scopes` property contains all the scopes for which the authentication request asked. If it includes the value `transfer:funds`, then we ask for MFA by setting the `context.multifactor` property to the appropriate value. In this case, we are asking for MFA using [push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa).\n    \n\n### Configure app\n\nConfigure the app to send the appropriate authentication request to the API, depending on whether the user is attempting to perform the high-value transaction of transferring funds. Notice that the only difference between the two authentication requests (with or without MFA) is the scope.\n\n*   With MFA:\n    \n    ```\n    https://{yourDomain}/authorize?\n    audience=https://my-banking-api&\n    scope=openid%20view:balance%20transfer:funds&\n    response_type=id_token%20token&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    nonce=NONCE&\n    state=OPAQUE_VALUE\n    ```\n    \n*   Without MFA:\n    \n    ```\n    https://{yourDomain}/authorize?\n    audience=https://my-banking-api&\n    scope=openid%20view:balance&\n    response_type=id_token%20token&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    nonce=NONCE&\n    state=OPAQUE_VALUE\n    ```\n    \n\n| Parameter | Setting |\n| --- | --- |\n| `audience` | Set to the **Identifier** of your API (find it at [API Settings](https://manage.auth0.com/#/apis/)). We set ours to `https://my-banking-api`. |\n| `response_type` | Set to `id_token token` so we get both an ID Token and an Access Token in the response. |\n| `client_id` | Set to the Client ID of your application (find it at [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)). |\n| `redirect_uri` | Set to a URL in your application that Auth0 should redirect back to after authentication (find it at [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)). |\n| `nonce` | Set to a secure string value which will be included in the response from Auth0. This is [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce) and is required for `response_type=id_token token`. |\n| `state` | Set to an opaque value that Auth0 includes when redirecting back to the application. This value must be used by the application to prevent CSRF attacks. |\n\n### Configure API\n\nConfigure the API to validate the incoming token and check the authorized permissions.\n\n1.  Configure two endpoints for our API: `GET /balance`: to retrieve the current balance `POST /transfer`: to transfer funds\n    \n2.  Use `Node.js` and a number of modules:\n    \n    1.  [express](https://expressjs.com/): adds the Express web application framework.\n        \n    2.  [jwks-rsa](https://github.com/auth0/node-jwks-rsa): retrieves RSA signing keys from a **JWKS** (JSON Web Key Set) endpoint. Using `expressJwtSecret`, we can generate a secret provider that will issue the right signing key to `express-jwt` based on the `kid` in the JWT header.\n        \n    3.  [express-jwt](https://github.com/auth0/express-jwt): lets you authenticate HTTP requests using JWT tokens in your Node.js applications. It provides several functions that make working with JWTs easier.\n        \n    4.  [express-jwt-authz](https://github.com/auth0/express-jwt-authz): checks if the access token contains a specific scope.\n        \n3.  Install the dependencies: `npm install express express-jwt jwks-rsa express-jwt-authz --save`\n    \n4.  Define the API endpoints, create a middleware function to validate the access token, and secure the endpoints using that middleware. The code in your `server.js` file should look like the following sample script:\n    \n    ```\n    // set dependencies\n        const express = require('express');\n        const app = express();\n        const jwt = require('express-jwt');\n        const jwksRsa = require('jwks-rsa');\n        const jwtAuthz = require('express-jwt-authz');\n    \n        // Create middleware for checking the JWT\n        const checkJwt = jwt({\n          // Dynamically provide a signing key based on the kid in the header and the signing keys provided by the JWKS endpoint\n          secret: jwksRsa.expressJwtSecret({\n            cache: true,\n            rateLimit: true,\n            jwksRequestsPerMinute: 5,\n            jwksUri: `https://{yourDomain}/.well-known/jwks.json`\n          }),\n    \n          // Validate the audience and the issuer\n          audience: 'https://my-banking-api', // replace with your API's audience, available at Dashboard > APIs\n          issuer: 'https://{yourDomain}/',\n          algorithms: [ 'RS256' ] // we are using RS256 to sign our tokens\n        });\n    \n        // create retrieve balance endpoint\n        app.get('/balance', checkJwt, jwtAuthz(['view:balance']), function (req, res) {\n          // code that retrieves the user's balance and sends it back to the calling app\n          res.status(201).send({message: \"This is the GET /balance endpoint\"});\n        });\n    \n    \n        // create transfer funds endpoint\n        app.post('/transfer', checkJwt, jwtAuthz(['transfer:funds']), function (req, res) {\n          // code that transfers funds from one account to another\n          res.status(201).send({message: \"This is the POST /transfer endpoint\"});\n        });\n    \n        // launch the API Server at localhost:8080\n        app.listen(8080);\n        console.log('Listening on http://localhost:8080');\n    ```\n    \n    Each time the API receives a request the following happens:\n    1.  The endpoint calls the `checkJwt` middleware.\n        \n    2.  `express-jwt` decodes the token and passes the request, the header, and the payload to `jwksRsa.expressJwtSecret`.\n        \n    3.  `jwks-rsa` downloads all signing keys from the JWKS endpoint and checks if one of the signing keys matches the `kid` in the header of the access token. If none of the signing keys match the incoming `kid`, an error is thrown. If there is a match, we pass the right signing key to `express-jwt`.\n        \n    4.  `express-jwt` continues its own logic to validate the signature of the token, the expiration, audience, and the issuer.\n        \n    5.  `jwtAuthz` checks if the scope that the endpoint requires is part of the access token. If the specified scopes are missing from the access token, the request is rejected with a 403 error message.\n        \n\n## Learn more\n\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Action Use Cases](https://auth0.com/docs/customize/actions/use-cases)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps)",
    "title": "Configure Step-up Authentication for APIs",
    "description": "Learn how an API can check if a user has logged in with Multi-factor Authentication by examining their access token.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure",
    "markdown": "# User Profile Structure\n\nAuth0's normalized user profile consists of a few different components:\n\n*   **Details**: Core User Profile object, which contains basic info, such as name, email, and timestamp of the user's latest login, in pre-defined attributes. This object may also contain info from a user's source connection. Most of the user attributes are root attributes (attributes stored at the first, or root, level of the `user` object), and some of these are editable.\n    \n*   **Metadata**: Two sub-objects that operate as secondary storage to store additional user info in customizable attributes: `user_metadata` and `app_metadata`. To learn more, including when to use `app_metadata` and `user_metadata`, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n    \n\n## User profile attributes\n\nThe following attributes are available on the user profile. Many are root attributes (attributes stored at the first, or root, level of the `user` object), and some may be updated, imported, and exported, as noted below.\n\nIf there are user fields that should not be stored by Auth0 due to privacy reasons, you can add the attributes you do not want persisting in Auth0 databases to the DenyList. To learn more, read [Add User Attributes to the DenyList](https://auth0.com/docs/secure/security-guidance/data-security/denylist).\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\n| Name | Type | Description | [Search?](https://auth0.com/docs/users/search) | [Update?](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) | [Import?](https://auth0.com/docs/users/guides/bulk-user-imports) | [Upsert during import?](https://auth0.com/docs/users/guides/bulk-user-imports#request-bulk-import) | [Export?](https://auth0.com/docs/users/guides/bulk-user-exports) |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| `app_metadata` | object | Custom fields that store info about a user that influences the user's access, such as support plan, security roles (if not using the Authorization Core feature set), or access control groups. To learn more, read [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata). | Y   | Y   | Y   | Y   | Y   |\n| `blocked` | boolean | Indicates whether the user has been blocked. Importing enables subscribers to ensure that users remain blocked when migrating to Auth0. | Y   | Y   | Y   | N   | Y   |\n| `blocked_for` | array (object) | IP addresses that have been blocked under suspicion of a bruteforce attack. | N   | N   | N   | N   | N   |\n| `created_at` | date time | Timestamp indicating when the user profile was first created. | Y   | N   | N   | N   | Y   |\n| `email` | text | (unique) The user's email address. | Y   | Y   | Y   | N   | Y   |\n| `email_verified` | boolean | Indicates whether the user has verified their email address. | Y   | Y   | Y   | Y   | Y   |\n| `family_name` | text | The user's family name. | Y   | Y   | Y   | Y   | Y   |\n| `given_name` | text | The user's given name. | Y   | Y   | Y   | Y   | Y   |\n| `guardian_authenticators` | array (object) | Detailed information about the guardian backup authorization methods the user has set up, including SMS and Recovery Codes. | N   | N   | N   | N   | N   |\n| `identities` | array (object) | Contains info retrieved from the identity provider with which the user originally authenticates. Users may also [link their profile to multiple identity providers](https://auth0.com/docs/users/concepts/overview-user-account-linking); those identities will then also appear in this array. The contents of an individual identity provider object varies by provider, but it will typically include the following:<br><br>*   `connection` (text): Name of the Auth0 connection used to authenticate the user.<br>*   `isSocial` (boolean): Indicates whether the connection is a social one.<br>*   `provider` (text): Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>*   `user_id` (text): User's unique identifier for this connection/provider.<br>*   `profileData` (object): User info associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br><br>In some cases, it will also include an API Access Token to be used with the provider. | Y   | N   | N   | N   | Y   |\n| `last_ip` | text | IP address associated with the user's last login. | Y   | N   | N   | N   | Y   |\n| `last_login` | date time | Timestamp indicating when the user last logged in. If a user is blocked and logs in, the blocked session updates `last_login`. If you are using this property from inside a [Rule](https://auth0.com/docs/rules) using the `user<` object, its value will be associated with the login that triggered the rule; this is because rules execute after login. | Y   | N   | N   | N   | Y   |\n| `last_password_reset` | date time | Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections. | N   | N   | N   | N   | N   |\n| `logins_count` | integer | Number of times the user has logged in. If a user is blocked and logs in, the blocked session is counted in `logins_count`. | Y   | N   | N   | N   | Y   |\n| `multifactor` | array (string) | List of multi-factor providers with which the user is enrolled. | N   | N   | N   | N   | Y   |\n| `multifactor_last_modified` | date time | Date and time of the last update to a user's multifactor authentication. | N   | N   | N   | N   | Y   |\n| `name` | text | The user's full name. | Y   | Y   | Y   | Y   | Y   |\n| `nickname` | text | The user's nickname. | Y   | Y   | Y   | Y   | Y   |\n| `phone_number` | text | The user's phone number. Only valid for users with SMS connections. | Y   | Y   | N   | N   | Y   |\n| `phone_verified` | boolean | Indicates whether the user has been verified their phone number. Only valid for users with SMS connections. | Y   | Y   | N   | N   | Y   |\n| `picture` | text | URL pointing to [the user's profile picture](https://auth0.com/docs/users/guides/change-user-pictures). | N   | Y   | Y   | Y   | Y   |\n| `tenant` | text | Name of the tenant being used. | N   | N   | N   | N   | N   |\n| `updated_at` | date time | Timestamp indicating when the user's profile was last updated/modified. Changes to `last_login` are considered updates, so most of the time, `updated_at` will match `last_login`. | Y   | N   | N   | N   | Y   |\n| `user_id` | text | (unique) The user's identifier. Importing allows user records to be synchronized across multiple systems without using mapping tables. | Y   | N   | Y   | N   | Y   |\n| `user_metadata` | object | Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences. To learn more, read [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata). | Y   | Y   | Y   | Y   | Y   |\n| `username` | text | (unique) The user's username. | Y   | Y   | Y   | N   | Y   |\n\nThree other fields are not technically part of the user profile, but may be of interest when importing users:\n\n*   `password_hash` (text): Hashed password for the user's connection. When users are created, Auth0 uses [bcrypt](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/) to secure the password. Importing compatible hashed passwords allows users to retain their passwords, thereby providing a smoother experience. Compatible passwords should be hashed using bcrypt $2a$ or $2b$ and have 10 saltRounds. Note that you can provide this field only when the user is first imported; you cannot update it later.\n    \n*   `custom_password_hash` (object): Hashed password for the user's connection when created using an alternate algorithm. Used in place of the `password_hash` field. During the bulk import process, you can update the `custom_password_hash` if the user did not login using the initially imported `custom_password_hash.`\n    \n\n## Learn more\n\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [Bulk User Import Database Schema and Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
    "title": "User Profile Structure",
    "description": "Lists the attributes that are available on the Auth0 user profile",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api",
    "markdown": "# Manage Authentication Methods with Management API\n\nThe [Auth0 Management API](https://auth0.com/docs/api/management/v2) provides several endpoints you can use to manage your users' MFA authentication methods.\n\nThis method relies on authenticating using a confidential application. To learn more about confidential vs. public applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n\n## Get all authentication methods\n\nUse the [Gets a list of authentication methods](https://auth0.com/docs/api/management/v2#!/Users/get_authentication_methods) endpoint to get a list of all of the authentication methods a user has either fully or partially enrolled.\n\nThis endpoint requires the scope: `read:authentication_methods`.\n\n### Examples\n\nThe following request returns a list of all authentication methods for a specified user.\n\n*   [cURL](#3b5a5f122ec3429b9948c16aa1aff26c_shell)\n*   [C#](#3b5a5f122ec3429b9948c16aa1aff26c_csharp)\n*   [Go](#3b5a5f122ec3429b9948c16aa1aff26c_go)\n*   [Java](#3b5a5f122ec3429b9948c16aa1aff26c_java)\n*   [Node.JS](#3b5a5f122ec3429b9948c16aa1aff26c_node)\n*   [Obj-C](#3b5a5f122ec3429b9948c16aa1aff26c_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n[\n  {\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"totp\",\n    \"confirmed\": true,\n    \"created_at\": \"2021-09-23T22:57:30.206Z\",\n    \"last_auth_at\": \"2021-09-23T22:57:51.652Z\"\n  }\n]\n```\n\n## Get a single authentication method\n\nUse the [Gets an authentication method by ID](https://auth0.com/docs/api/management/v2#!/Users/get_authentication_methods_by_authentication_method_id) endpoint to get a single authentication method for a user specified by the authentication method's ID.\n\nThis endpoint requires the scope: `read:authentication_methods`.\n\n### Examples\n\nThe following request returns a single authentication method for a user based on the specified authentication method's ID.\n\n*   [cURL](#f700359625d047618aed0838489b967d_shell)\n*   [C#](#f700359625d047618aed0838489b967d_csharp)\n*   [Go](#f700359625d047618aed0838489b967d_go)\n*   [Java](#f700359625d047618aed0838489b967d_java)\n*   [Node.JS](#f700359625d047618aed0838489b967d_node)\n*   [Obj-C](#f700359625d047618aed0838489b967d_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"totp\",\n    \"confirmed\": true,\n    \"created_at\": \"2021-09-23T22:57:30.206Z\",\n    \"last_auth_at\": \"2021-09-23T22:57:51.652Z\"\n}\n```\n\n## Create an authentication method\n\nUse the [Creates an authentication method for a given user](https://auth0.com/docs/api/management/v2#!/Users/post_authentication_methods) endpoint to create an authentication method for a user, including SMS, email, one-time password (OTP), or WebAuthn with security keys. To learn more about available MFA authentication factors, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\nThis endpoint requires the scope: `create:authentication_methods`.\n\n### SMS\n\nSend users an OTP over SMS which the user is then prompted to enter before they can finish authenticating.\n\n#### Examples\n\nThe following request creates a SMS authentication method for a user.\n\n*   [cURL](#125e4fee03724ad591df12b41984cac4_shell)\n*   [C#](#125e4fee03724ad591df12b41984cac4_csharp)\n*   [Go](#125e4fee03724ad591df12b41984cac4_go)\n*   [Java](#125e4fee03724ad591df12b41984cac4_java)\n*   [Node.JS](#125e4fee03724ad591df12b41984cac4_node)\n*   [Obj-C](#125e4fee03724ad591df12b41984cac4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"phone\", \"name\": \"SMS\", \"phone_number\": \"+00000000000\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'phone', name: 'SMS', phone_number: '+00000000000'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"phone\",\n                              @\"name\": @\"SMS\",\n                              @\"phone_number\": @\"+00000000000\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"phone\\\", \\\"name\\\": \\\"SMS\\\", \\\"phone_number\\\": \\\"+00000000000\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"phone\",\n  \"name\": \"SMS\",\n  \"phone_number\": \"+00000000000\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"phone\",\n    \"name\": \"SMS\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"phone_number\": \"user@example.com\",\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### Email\n\nSend users an OTP over email which the user is then prompted to enter before they can finish authenticating. The email factor is only supported when a user has no other factors available.\n\n#### Examples\n\nThe following request creates an email authentication method for a user.\n\n*   [cURL](#f0def55fa5044124a3cf2dc747f56b83_shell)\n*   [C#](#f0def55fa5044124a3cf2dc747f56b83_csharp)\n*   [Go](#f0def55fa5044124a3cf2dc747f56b83_go)\n*   [Java](#f0def55fa5044124a3cf2dc747f56b83_java)\n*   [Node.JS](#f0def55fa5044124a3cf2dc747f56b83_node)\n*   [Obj-C](#f0def55fa5044124a3cf2dc747f56b83_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"email\", \"name\": \"Email Factor\", \"email\": \"user@example.com\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'email', name: 'Email Factor', email: 'user@example.com'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"email\",\n                              @\"name\": @\"Email Factor\",\n                              @\"email\": @\"user@example.com\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"email\\\", \\\"name\\\": \\\"Email Factor\\\", \\\"email\\\": \\\"user@example.com\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"email\",\n  \"name\": \"Email Factor\",\n  \"email\": \"user@example.com\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"email\",\n    \"name\": \"Email Factor\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"email\": \"user@example.com\",\n    \"id\": \"email|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### One-time passwords (OTP)\n\nEnable users to use an authenticator application, such as Google Authenticator, on their personal device to generate an OTP that changes periodically, which the user is prompted to enter before they finish authenticating.\n\n#### Examples\n\nThe following request creates an OTP authentication method for a user.\n\n*   [cURL](#22cc0e0844fd435982f39f76e6444d36_shell)\n*   [C#](#22cc0e0844fd435982f39f76e6444d36_csharp)\n*   [Go](#22cc0e0844fd435982f39f76e6444d36_go)\n*   [Java](#22cc0e0844fd435982f39f76e6444d36_java)\n*   [Node.JS](#22cc0e0844fd435982f39f76e6444d36_node)\n*   [Obj-C](#22cc0e0844fd435982f39f76e6444d36_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"totp\", \"name\": \"OTP Application\", \"totp_secret\": \"{yourSecret}\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {type: 'totp', name: 'OTP Application', totp_secret: '{yourSecret}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"totp\",\n                              @\"name\": @\"OTP Application\",\n                              @\"totp_secret\": @\"{yourSecret}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"totp\\\", \\\"name\\\": \\\"OTP Application\\\", \\\"totp_secret\\\": \\\"{yourSecret}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"totp\",\n  \"name\": \"OTP Application\",\n  \"totp_secret\": \"{yourSecret}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"totp\",\n    \"name\": \"OTP Application\",\n    \"created_at\": \"2023-01-01T00:00:00.000Z\",\n    \"email\": \"user@example.com\",\n    \"id\": \"totp|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n### WebAuthn with security keys\n\nEnable users to use FIDO-compliant security keys (for example, [Yubikey](https://www.yubico.com/) or [Google Titan](https://cloud.google.com/titan-security-key)) to perform multi-factor authentication.\n\n#### Examples\n\nThe following request creates a WebAuthn with security keys authentication method for a user.\n\n*   [cURL](#e505fa923c254c44b9d35dc0e72af19d_shell)\n*   [C#](#e505fa923c254c44b9d35dc0e72af19d_csharp)\n*   [Go](#e505fa923c254c44b9d35dc0e72af19d_go)\n*   [Java](#e505fa923c254c44b9d35dc0e72af19d_java)\n*   [Node.JS](#e505fa923c254c44b9d35dc0e72af19d_node)\n*   [Obj-C](#e505fa923c254c44b9d35dc0e72af19d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"type\": \"webauthn_roaming\", \"name\": \"WebAuthn with security keys\", \"public_key\": \"{yourPublicKey}\", \"key_id\": \"{yourKeyId}\", \"relying_party_identifier\": \"{yourDomain}\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {\n    type: 'webauthn_roaming',\n    name: 'WebAuthn with security keys',\n    public_key: '{yourPublicKey}',\n    key_id: '{yourKeyId}',\n    relying_party_identifier: '{yourDomain}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"type\": @\"webauthn_roaming\",\n                              @\"name\": @\"WebAuthn with security keys\",\n                              @\"public_key\": @\"{yourPublicKey}\",\n                              @\"key_id\": @\"{yourKeyId}\",\n                              @\"relying_party_identifier\": @\"{yourDomain}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"type\\\": \\\"webauthn_roaming\\\", \\\"name\\\": \\\"WebAuthn with security keys\\\", \\\"public_key\\\": \\\"{yourPublicKey}\\\", \\\"key_id\\\": \\\"{yourKeyId}\\\", \\\"relying_party_identifier\\\": \\\"{yourDomain}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  \"type\": \"webauthn_roaming\",\n  \"name\": \"WebAuthn with security keys\",\n  \"public_key\": \"{yourPublicKey}\",\n  \"key_id\": \"{yourKeyId}\",\n  \"relying_party_identifier\": \"{yourDomain}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"webauthn-roaming\",\n    \"name\": \"WebAuthn with security keys\",\n    \"relyingPartyIdentifier\": \"example-tenant.auth0.com\",\n    \"keyId\": \"X9FrwMfmzj...\",\n    \"publicKey\": \"bXktcHVibGljLWtle...\",\n    \"created_at\": \"2023-03-09T17:33:47.545Z\",\n    \"id\": \"webauthn-roaming|dev_XXXXXXXXXXXXXXXX\"\n}\n```\n\n## Replace all authentication methods\n\nUse the [Updates all authentication methods by replacing them with the given ones](https://auth0.com/docs/api/management/v2#!/Users/put_authentication_methods) endpoint to replace all existing authentication methods with those provided.\n\nThis endpoint requires the scope: `update:authentication_methods`.\n\n### Examples\n\nThe following request replaces all existing authentication methods for a user.\n\n*   [cURL](#a93d4b978c294c4d8e0ff450c68954de_shell)\n*   [C#](#a93d4b978c294c4d8e0ff450c68954de_csharp)\n*   [Go](#a93d4b978c294c4d8e0ff450c68954de_go)\n*   [Java](#a93d4b978c294c4d8e0ff450c68954de_java)\n*   [Node.JS](#a93d4b978c294c4d8e0ff450c68954de_node)\n*   [Obj-C](#a93d4b978c294c4d8e0ff450c68954de_objc)\n*   [...](#)\n\n```\ncurl --request PUT \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '[{ \"type\": \"phone\", \"preferred_authentication_method\": \"sms\", \"phone_number\": \"+00000000000\", \"name\": \"SMS\" }]'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.PUT);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\tpayload := strings.NewReader(\"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\")\n\n\treq, _ := http.NewRequest(\"PUT\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.put(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PUT',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: [\n    {\n      type: 'phone',\n      preferred_authentication_method: 'sms',\n      phone_number: '+00000000000',\n      name: 'SMS'\n    }\n  ]\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @[ @{ @\"type\": @\"phone\", @\"preferred_authentication_method\": @\"sms\", @\"phone_number\": @\"+00000000000\", @\"name\": @\"SMS\" } ];\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PUT\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PUT\",\n  CURLOPT_POSTFIELDS => \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"PUT\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Put.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"[{ \\\"type\\\": \\\"phone\\\", \\\"preferred_authentication_method\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"+00000000000\\\", \\\"name\\\": \\\"SMS\\\" }]\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\n  [\n    \"type\": \"phone\",\n    \"preferred_authentication_method\": \"sms\",\n    \"phone_number\": \"+00000000000\",\n    \"name\": \"SMS\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PUT\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n[\n  {\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n    \"type\": \"phone\",\n    \"name\": \"SMS\",\n    \"phone_number\": \"+00000000000\",\n    \"created_at\": \"2023-03-09T17:53:23.647Z\",\n    \"preferred_authentication_method\": \"sms\",\n    \"authentication_methods\": [\n      {\n        \"id\": \"sms|dev_XXXXXXXXXXXXXXXX\",\n        \"type\": \"sms\"\n      }\n    ]\n  }\n]\n```\n\n## Update a single authentication method\n\nUse the [Updates an authentication method](https://auth0.com/docs/api/management/v2#!/Users/patch_authentication_methods_by_authentication_method_id) endpoint to update a single authentication method for a user.\n\nThis endpoint requires the scope: `update:authentication_methods`.\n\n### Examples\n\nThe following request updates a single authentication method for a user based on the specific authentication method's ID.\n\n*   [cURL](#a54d5e45e2b74c799ca4ca039519a3b0_shell)\n*   [C#](#a54d5e45e2b74c799ca4ca039519a3b0_csharp)\n*   [Go](#a54d5e45e2b74c799ca4ca039519a3b0_go)\n*   [Java](#a54d5e45e2b74c799ca4ca039519a3b0_java)\n*   [Node.JS](#a54d5e45e2b74c799ca4ca039519a3b0_node)\n*   [Obj-C](#a54d5e45e2b74c799ca4ca039519a3b0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --data '{ \"name\": \"Mobile SMS\" }'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"undefined\", \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\tpayload := strings.NewReader(\"{ \\\"name\\\": \\\"Mobile SMS\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"name\\\": \\\"Mobile SMS\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'},\n  data: {name: 'Mobile SMS'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"name\": @\"Mobile SMS\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\"\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"PATCH\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"name\\\": \\\"Mobile SMS\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\nlet parameters = [\"name\": \"Mobile SMS\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response in the JSON format.\n\n```\n{\n    \"type\": \"phone\",\n    \"name\": \"Mobile SMS\",\n    \"created_at\": \"2023-01-12T00:03:52.855Z\",\n    \"last_auth_at\": \"2023-01-12T00:04:05.157Z\",\n    \"phone_number\": \"+00000000000\",\n    \"preferred_authentication_method\": \"sms\",\n    \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n    \"authentication_methods\": [\n        {\n            \"id\": \"phone|dev_XXXXXXXXXXXXXXXX\",\n            \"type\": \"phone\"\n        }\n    ]\n}\n```\n\n## Delete all authentication methods\n\nUse the [Deletes all authentication methods for the given user](https://auth0.com/docs/api/management/v2#!/Users/delete_authentication_methods) endpoint to delete all authentication methods for a user.\n\nThis endpoint requires the scope: `delete:authentication_methods`.\n\n### Examples\n\nThe following request deletes all authentication methods for a user.\n\n*   [cURL](#b409083687be45958d52693e29e96da4_shell)\n*   [C#](#b409083687be45958d52693e29e96da4_csharp)\n*   [Go](#b409083687be45958d52693e29e96da4_go)\n*   [Java](#b409083687be45958d52693e29e96da4_java)\n*   [Node.JS](#b409083687be45958d52693e29e96da4_node)\n*   [Obj-C](#b409083687be45958d52693e29e96da4_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"DELETE\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response with a `204` status code and empty body.\n\n## Delete a single authentication method\n\nUse the [Deletes an authentication method by ID](https://auth0.com/docs/api/management/v2#!/Users/delete_authentication_methods_by_authentication_method_id) endpoint to delete a single authentication method for a user.\n\n### Examples\n\nThe following request deletes a single authentication method for a user based on the specified authentication method's ID.\n\n*   [cURL](#91c40f52334743998b02ee2c7a3ea8a5_shell)\n*   [C#](#91c40f52334743998b02ee2c7a3ea8a5_csharp)\n*   [Go](#91c40f52334743998b02ee2c7a3ea8a5_go)\n*   [Java](#91c40f52334743998b02ee2c7a3ea8a5_java)\n*   [Node.JS](#91c40f52334743998b02ee2c7a3ea8a5_node)\n*   [Obj-C](#91c40f52334743998b02ee2c7a3ea8a5_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"DELETE\", \"%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://%7ByourDomain%7D/api/v2/users/%7BuserId%7D/authentication-methods/%7BauthenticationMethodId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Responses\n\nFor each valid request, the Management API will return a response with a `204` status code and empty body.\n\n## Learn more\n\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)",
    "title": "Manage Authentication Methods with Management API",
    "description": "Learn how to use the Auth0 Management API to manage MFA authentication methods for your users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles",
    "markdown": "# Sample User Profiles\n\n## Google User Profile\n\nThis is a sample user profile from a user that logged in through **Google**:\n\n```\n{\n  \"email\": \"johnfoo@gmail.com\",\n  \"email_verified\": true,\n  \"family_name\": \"Foo\",\n  \"gender\": \"male\",\n  \"given_name\": \"John\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"103547991597142817347\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"locale\": \"en\",\n  \"name\": \"John Foo\",\n  \"nickname\": \"FooJon\",\n  \"picture\": \"https://lh4.googleusercontent.com/-OdsbOXom9qE/AAAAAAAAAAI/AAAAAAAAADU/_j8SzYTOJ4I/photo.jpg\",\n  \"user_id\": \"google-oauth2|103547991597142817347\"\n}\n```\n\n## Microsoft Account User Profile\n\nThis is a sample profile from **Microsoft Account**:\n\n```\n{\n  \"email\": \"bobdoe@outlook.com\",\n  \"email_verified\": true,\n  \"emails\": [\n    \"bobdoe@outlook.com\",\n    \"bobdoe@outlook.com\"\n  ],\n  \"family_name\": \"Doe\",\n  \"given_name\": \"Bob\",\n  \"identities\": [\n    {\n      \"provider\": \"windowslive\",\n      \"user_id\": \"4cf0a30169d55031\",\n      \"connection\": \"windowslive\",\n      \"isSocial\": true\n    }\n  ],\n  \"locale\": \"en_US\",\n  \"name\": \"Bob Doe\",\n  \"nickname\": \"doebob@outlook.com\",\n  \"picture\": \"https://secure.gravatar.com/avatar/c89b2bb92df91508e14172097a5e17da?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"user_id\": \"windowslive|4cf0a30169d55031\"\n}\n```\n\n## Office 365 User Profile\n\nThis is a sample profile from **Office 365 (Microsoft Azure Active Directory)**:\n\n```\n{\n  \"email\": \"jeff@foo.onmicrosoft.com\",\n  \"family_name\": \"Jeff\",\n  \"given_name\": \"Beth\",\n  \"identities\": [\n    {\n      \"user_id\": \"10030000838D23AF@MicrosoftOnline.com\",\n      \"provider\": \"office365\",\n      \"connection\": \"foo-onmicrosoft\",\n      \"isSocial\": false\n    }\n  ],\n  \"name\": \"Jeff Beth\",\n  \"nickname\": \"jeff@auth0.onmicrosoft.com\",\n  \"picture\": \"https://secure.gravatar.com/avatar/a7f86ddd090d5a4cb833b97baab2aca1?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"tenantid\": \"75696069-df44-4310-9bcf-08b45e3007c9\",\n  \"upn\": \"jeff@foo.onmicrosoft.com\",\n  \"user_id\": \"office365|10030000838D23AF@MicrosoftOnline.com\"\n}\n```\n\n## ADFS User Profile\n\nThis is a sample profile from **ADFS (Active Directory Federation Services)**:\n\n```\n{\n  \"email\": \"john@fabrikam.com\",\n  \"family_name\": \"Fabrikam\",\n  \"email_verified\": false,\n  \"given_name\": \"John\",\n  \"identities\": [\n    {\n      \"user_id\": \"john@fabrikam.com\",\n      \"provider\": \"adfs\",\n      \"connection\": \"auth10.com\",\n      \"isSocial\": false\n    }\n  ],\n  \"issuer\": \"https://adfs.fabrikam.com\",\n  \"name\": \"John Fabrikam\",\n  \"nickname\": \"john\",\n  \"picture\": \"https://secure.gravatar.com/avatar/5426f6b9d63ad92d60e6fe9fdf83aa21?s=480&r=pg&d=https%3A%2F%2Fssl.gstatic.com%2Fs2%2Fprofiles%2Fimages%2Fsilhouette80.png\",\n  \"user_id\": \"adfs|john@fabrikam.com\"\n}\n```\n\nWas this article helpful?",
    "title": "Sample User Profiles",
    "description": "Examples of user profiles.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema",
    "markdown": "# Normalized User Profile Schema\n\nThe attributes that Auth0 maps to a common schema are listed below.\n\nFields that are always generated:\n\n*   `**name**`: the user's full name.\n    \n*   `**nickname**`: by default, the local part of the user's email.\n    \n*   `**picture**`: the URL of the [user's picture](https://auth0.com/docs/manage-users/user-accounts/change-user-picture). If unavailable, Auth0 uses the Gravatar image associated with the user's email address.\n    \n*   `**user_id**`: the user's unique identifier. This is unique per Connection, but the same for all apps that authenticate via that Connection.\n    \n\nBy default, a user's `name`, `nickname`, and `picture` attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable since they are updated from the identity provider each time a user logs in. If you want to be able to edit these attributes, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. Root attributes will then be available to be [edited individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) or [by bulk import](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) using the Management API.\n\nFields that are generated when the details are available:\n\n*   `**email**`: the user's email address.\n    \n*   `**email_verified**`: a boolean indicating if the user's email address has been verified.\n    \n*   `**given_name**`: the user's first name.\n    \n*   `**family_name**`: the user's last name.\n    \n\nWhen creating a user with the [Create a User Management API endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_users) you can submit the `given_name` and `family_name`. By default, a user's `given_name` and `family_name` attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable since they are updated from the identity provider each time a user logs in. If you want to be able to edit these attributes, you must [configure your connection sync with Auth0](https://auth0.com/docs/dashboard/guides/connections/configure-connection-sync) so that user attributes will be updated from the identity provider only on user profile creation. Root attributes will then be available to be [edited individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) or [by bulk import](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) using the Management API\n\nIf you are writing a login script for a [custom database](https://auth0.com/docs/connections/database/mysql) you are responsible for returning the information in the user profile. A unique and immutable `user_id` property is mandatory to correctly identify the user (see [Uniquely Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users)).\n\n## Additional Attributes\n\nThe User Profile includes an array of identities. In the most common case (logging in with a single provider), the array contains only one element. If the user has multiple accounts linked, the array will have an element for each associated account. See [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) for more information.\n\nThe `identities` array contains the following attributes:\n\n*   `connection`: the name of the connection.\n    \n*   `isSocial`: indicates if the provider is a Social provider.\n    \n*   `provider`: the provider of the connection.\n    \n*   `user_id`: the unique identifier of the user for this connection.\n    \n\nAuth0 passes all other properties supplied by the identity provider to your app, even if they are not mapped to the standard attributes listed above.",
    "title": "Normalized User Profile Schema",
    "description": "Normalized User Profile schema reference.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling",
    "markdown": "# Understand How Progressive Profiling Works\n\nProgressive profiling is the process of incrementally collecting additional information about your users as they engage with your website or application. You can gather detailed user information only when relevant to a user's activities.\n\nFor example, you could collect the user's name, email, and password during signup, then ask them for the name of their company and their job title the next time they log in.\n\nImplementing progressive profiling improves your users' experience by:\n\n*   Shortening registration forms.\n    \n*   Avoiding repetitive questions.\n    \n*   Collecting more relevant information.\n    \n*   Increasing conversion rates.\n    \n\n## How it works\n\nEvery time a user authenticates through Auth0, Auth0 updates their user profile. The data used to update their profile can come from different sources:\n\n*   Attributes supplied by the IdP.\n    \n*   Attributes created dynamically with [Auth0 Actions](https://auth0.com/docs/customize/actions).\n    \n*   Attributes returned from calling APIs such as [FullContact](https://www.fullcontact.com/) and [Clearbit](https://clearbit.com/).\n    \n*   Attributes managed by the application.\n    \n\n## Use action triggers\n\nWith the `post-login` action trigger, you can modify a user's `user_metadata` and `app_metadata` fields during the login flow. This is useful for tasks such as storing application-specific data on the user's profile, recording whether or not specific operations have occurred for a user, or caching the results of expensive operations on the user profile so they can be re-used for future logins. To learn more, read [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata).\n\n## Use the Management API\n\nYou can use the Auth0 Management API [Update a User](https://auth0.com/docs/api/management/v2/#!/Users/patch_users_by_id) endpoint to update the profile data of an authenticated user, including the `app_metadata` and `user_metadata` fields. To learn more, read [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api).\n\n## Use the Lock library\n\nYou can use the `additionalSignUpFields` option to add custom fields to user signup forms. When a user enters data into a custom field, Auth0 stores the value in their profile's `user_metadata` field. To learn more, read [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration#additionalsignupfields-array-).\n\n## Learn more\n\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
    "title": "Understand How Progressive Profiling Works",
    "description": "Understand how progressive profiling can gather information about users over time as they engage with your website or application.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes",
    "markdown": "# User Profile Root Attributes\n\nAuth0's normalized user profile contains a number of root attributes (attributes stored at the first, or root, level of the object), some of which may be updated. To learn more about the user profile structure and its attributes, read [User Profile Structure.](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n\nMethods for updating root attributes vary depending on connection type.\n\n## Auth0 as the identity provider\n\nWhen Auth0 is the Identity Provider (IdP), subscribers may:\n\n*   Set root attributes [on user sign-up](https://auth0.com/docs/api/management/guides/users/set-root-attributes-user-signup) (via the Management API or via public signup) or [on import](https://auth0.com/docs/api/management/guides/users/set-root-attributes-user-import)\n    \n*   [Update root attributes individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) via the Management API\n    \n\nAuth0 is the IdP for the following connection types:\n\n*   [Regular database connections](https://auth0.com/docs/connections/database)\n    \n*   [Custom database connections](https://auth0.com/docs/connections/database/custom-db) with import mode\n    \n*   [Passwordless connections](https://auth0.com/docs/connections/passwordless)\n    \n\n## Upstream identity providers\n\nWhen an upstream IdP (like Google or Facebook) is used, subscribers have two options:\n\n*   The upstream IdP sets the root attributes when users are first created and then automatically updates them with each subsequent login. This is the default behavior.\n    \n*   The upstream IdP sets the root attributes on user creation only and does not update them on subsequent logins, thereby allowing subscribers to [update root attributes individually](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) via the Management API. To enable this, you will need to [configure your connection sync with Auth0](https://auth0.com/docs/api/management/guides/connections/configure-connection-sync).\n    \n\nUpstream Identity Providers handle the following connection types:\n\n*   [Social connections](https://auth0.com/docs/connections#social)\n    \n*   [Enterprise connections](https://auth0.com/docs/connections#enterprise)\n    \n*   [Legal identity connections](https://auth0.com/docs/connections#legal-identities)",
    "title": "User Profile Root Attributes",
    "description": "Learn about root attributes available for the Auth0 normalized user profile and methods of updating them.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/verified-email-usage",
    "markdown": "# Use Verified Email in User Profiles\n\nThe `email_verified` field of a user profile indicates whether the user has verified their email address. Email verification is optional, but valid email addresses are required for certain actions, such as sending email communications, password reset/recovery links, and passwordless magic links to users.\n\nAn email is usually verified immediately after the user account is created or when the user logs in to the application for the first time. It's a good way to know that the person signing up actually owns the email at that moment.\n\nSince email verification happens once at that specific moment, we can't ensure that a person who logs in with the user account at a later time still owns the email address that was verified.\n\nIn case of federated identity providers, they sometimes report if the user has a verified email, and based on that, Auth0 sets the `email_verified` field in the user profile. This, however, transfers the responsibility to the identity provider to do it properly - something we can't ensure. We also don't know if the verified email from that provider is still owned by the user.\n\nFor all of these reasons, we need to be careful on what we can assume based on a verified email.\n\n## When does Auth0 set emails as verified?\n\nWhen users signup with email and password, they get a verification email with a link. When they click the link, Auth0 verifies their email. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nWhen users authenticate with a federated identity provider (e.g. a social or enterprise connection), the value of the `email_verified` field will match what the identity provider returns in the user profile. If they identity provider does not return any value, it will be set to `false`.\n\n## Verified Emails and Account Linking\n\nWhen you want to [link two user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking), you need to make sure that the user still has access to both accounts. The only way to achieve that is to have users authenticate with both accounts before linking them.\n\nYou **should not automatically link accounts based on the user's emails**. Always prompt users to authenticate again before doing that. This will prevent scenarios like:\n\n*   John Doe, an employee of Travel0, signs up to a site using his corporate email `john.doe@travel0.com` and a password. Months later, John Doe leaves Travel0, and a new John Doe is hired, with the same email account. That person goes to the same website, and authenticates with his corporate identity provider (such as Google Workspace), and gets the account automatically linked to the other user.\n    \n*   Federated identity providers can make mistakes on how they handle email verification and can report that users own an email they do not.\n    \n\nOn the other hand, we recommend you to still check for the `email_verified` field before performing account linking, to mitigate scenarios like:\n\n*   An attacker creates a Google account `attacker@gmail.com`.\n    \n*   Attacker creates a new database users with the victim's email (e.g. `victim@hotmail.com`).\n    \n*   Attacker links both accounts.\n    \n*   Attacker sends a phishing attack to victim.\n    \n*   The victim tries to sign-up, they are told the user already exists and get offered to reset the password.\n    \n*   The user enters their password and logs into the attacker's account, which now has access to whatever data the victim enters in the application.\n    \n\nIn the same way that you can't fully trust the email, you can't fully trust the email domain either.\n\nIf your application needs to restrict access based on the user's employer, the fact that a user is logged in with an email from a specific corporate domain does not guarantee that it should be granted access.\n\nFor example:\n\n*   If your application allows customers to sign up for new accounts, and employees from different companies authenticate using their corporate credentials, a user that signs up with a `user@acme.com` account shouldn't be granted access to the same feature set that a user authenticating with acme.com's corporate directory.\n    \n*   If your application supports authenticating with Azure AD, and the directory supports guest users, you can get users from any domain logging-in from that Azure AD tenant. You should not give guest users the same access level as the rest of the users authenticating with that tenant.\n    \n\nAs a general recommendation, **you should not use the email's domain to make authorization decisions**. If you need to check if the user belongs to a specific organization, it's better to rely on the connection they used to authenticate, or in connection-specific attributes like the Azure AD's tenant id.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
    "title": "Use Verified Email in User Profiles",
    "description": "Outlines proper usage of the email_verified field in a user profile.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/update-user-profiles-using-your-database",
    "markdown": "# Update User Profiles Using Your Database\n\nUpdate user profiles when [using your own database as an identity provider](https://auth0.com/docs/connections/database/custom-db) by doing the following tasks:\n\n*   Use the [Management API](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n    \n*   Update the user in your database.\n    \n*   [Configure user migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database) from your database to Auth0.\n    \n\n## Update users with the Management API\n\nWhen using your own database for authentication, you can use the [Management API](https://auth0.com/docs/api/management/v2) to update the following fields:\n\n*   `app_metadata`\n    \n*   `user_metadata`\n    \n*   `blocked`\n    \n\nIf you need to update other user fields, you will need to do it directly in your database.\n\n## Update users in your database\n\nYou can update user profiles in your database as you normally do, and Auth0 will update its cached user profile the next time that user logs in.\n\nThe user profile in the custom database can be implemented with any user profile structure, but you need to map it in the Login call to the Auth0 normalized user profile attributes as shown in the \"Login\" custom database template.\n\nAccess the custom database templates are accessed via Connections -> Database -> Custom Database. Be sure to turn on the \"Use my own database\" toggle to enable editing the scripts.\n\nSee the [User profile cache](#user-profile-cache) section below for a brief overview of how Auth0 caches user profiles.\n\n## Update users through migration\n\nIf you have [enabled user migration](https://auth0.com/docs/connections/database/migrating), and a user has already been migrated to the Auth0 database, then Auth0 will not query your database again for the user profile. Therefore, all changes made in the custom database for that user will never reflect in Auth0.\n\nOnce a user has been migrated, you will also be able to update fields, such as `name`, `nickname`, `given_name`, `family_name`, `picture`, `email`, and `email_verified` via the Management API.\n\nHowever, rules for updating other user fields will still apply as described in the [Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n\n## User profile cache\n\nAuth0 caches the user profile received from a [database connection](https://auth0.com/docs/connections/database) before sending it to the client application. This cache is stored in the Auth0 database and is refreshed each time the user authenticates.\n\nThe cached values for the [Normalized User Profile](https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema) fields are based on the values returned from the Login Script of your custom database connection.\n\nThe User Profile is cached for several reasons. First, caching allows you the option of implementing [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) at the Auth0 layer to avoid going to the connection for every request. Additionally, this provides resilience if a connection is temporarily unavailable.\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
    "title": "Update User Profiles Using Your Database",
    "description": "Learn how to update user profiles when using your own database as an identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules",
    "markdown": "# Manage Metadata with Rules\n\nYou can read, update, and delete metadata using [Auth0 Rules](https://auth0.com/docs/customize/rules). In the following sections, we will refer to this example where the user and their information is represented by the following JSON snippet:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n## Read metadata\n\nYou can read metadata using rules with the Management API. You can also search for profile-related information in `user_metadata`, such as:\n\n*   `name`\n    \n*   `nickname`\n    \n*   `given_name`\n    \n*   `family_name`\n    \n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nAs an example, assume the following metadata is stored for a user with the email address `jane.doe@example.com`:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nUsing the example metadata above, you can refer to specific items from the dataset in [Auth0 Rules](https://auth0.com/docs/customize/rules) or via a call to the [Management API](https://auth0.com/docs/users/guides/manage-user-metadata) as follows:\n\n```\nconsole.log(user.email); // \"jane.doe@example.com\"\nconsole.log(user.user_metadata.hobby); // \"surfing\"\nconsole.log(user.app_metadata.plan); // \"full\"\n```\n\nAny valid JSON snippet can be used as metadata, but note that `user.app_metadata` is `Undefined` by default.\n\nTo read the available metadata, you will need to access the correct user property.\n\n### Read app metadata\n\nYou can make a decision based on the user's roles:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  if (user.app_metadata.roles.indexOf('writer')){\n    // code to be executed\n  }\n  ...\n}\n```\n\n### Read user metadata\n\nYou can base decisions on specific preferences, such as a color preference:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  if (user.user_metadata.preferences.color === 'black'){\n    // code to be executed\n  }\n  ...\n}\n```\n\n### Read application metadata (clientMetadata)\n\nApplication metadata (`clientMetadata`) is an optional, top-level property of the `context` object. Existing applications will have no value for this property.\n\n```\nfunction(user, context, callback){\n  context.clientMetadata = context.clientMetadata || {};\n  if (context.clientMetadata.usersuppliedkey1 === 'black'){\n    // this code would not be executed for the user\n  }\n  ...\n}\n```\n\n## Update metadata\n\n### Update app metadata\n\nTo add an administrative role to the user:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = user.app_metadata.roles || [];\n  user.app_metadata.roles.push('administrator');\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\", \"administrator\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n### Update user metadata\n\nTo add the user's `fontSize` preference to the user profile:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  user.user_metadata.preferences.fontSize = 12;\n\n  // persist the user_metadata update\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\",\n      \"fontSize\": 12\n    }\n  }\n}\n```\n\n### Update app and user metadata simultaneously\n\nTo reduce the rule's processing time, you may update both the `app_metadata` and `user_metadata` in the same rule:\n\n```\nfunction(user, context, callback){\n\n  var q = require('q');\n\n  user.app_metadata = user.app_metadata || {};\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  user.user_metadata.preferences.fontSize = 12;\n\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = user.app_metadata.roles || [];\n  user.app_metadata.roles.push('admin');\n\n  // persist the app_metadata update\n  var appMetadataPromise  = auth0.users.updateAppMetadata(user.user_id, user.app_metadata);\n\n  // persist the user_metadata update\n  var userMetadataPromise = auth0.users.updateUserMetadata(user.user_id, user.user_metadata);\n\n  // using q library to wait for all promises to complete\n  q.all([userMetadataPromise, appMetadataPromise])\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\", \"admin\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\",\n      \"fontSize\": 12\n    }\n  }\n}\n```\n\n## Delete metadata\n\n### Delete app metadata properties and values\n\nTo delete a property, set the property's value to `null`.\n\n#### Delete user's roles example\n\nTo delete the user's roles, use the following sample rule:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  // update the app_metadata that will be part of the response\n  user.app_metadata.roles = null;\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": { },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\n#### Delete single property value example\n\nTo delete a single value of a property, remove that specific value. For example, to remove the `writer` role from the user profile:\n\n```\nfunction(user, context, callback){\n  user.app_metadata = user.app_metadata || {};\n  user.app_metadata.roles = user.app_metadata.roles || [];\n\n  var index = user.app_metadata.roles.indexOf('writer');\n\n  if (index !== -1){\n    // update the app_metadata that will be part of the response\n    user.app_metadata.roles.splice(index, 1);\n  }\n\n  // persist the app_metadata update\n  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n    });\n}\n```\n\nThis results in the following JSON representation of the user profile:\n\n```\n{\n  \"user_id\": \"google-oauth2|1234\",\n  \"email\": \"john.doe@gmail.com\",\n  \"app_metadata\": {\n    \"roles\": [ ]\n  },\n  \"user_metadata\": {\n    \"preferences\": {\n      \"color\": \"blue\"\n    }\n  }\n}\n```\n\nNote that the `roles` property still exists but does not contain any value.\n\n### Delete user metadata properties and values\n\nTo delete the user's color preference:\n\n```\nfunction(user, context, callback){\n  user.user_metadata = user.user_metadata || {};\n  // update the user_metadata that will be part of the response\n  user.user_metadata.preferences = user.user_metadata.preferences || {};\n  delete user.user_metadata.preferences.color;\n\n  // persist the user_metadata update\n  auth0.users.updateUserMetadata(user.user_id, user.user_metadata)\n    .then(function(){\n      callback(null, user, context);\n    })\n    .catch(function(err){\n      callback(err);\n  });\n}\n```\n\nThis results in the following JSON representation of the user profile details:\n\n```\n{\n  \"user_id\": \"jdoe\",\n  \"email\": \"john.doe@example.com\",\n  \"app_metadata\": {\n    \"roles\": [ \"writer\" ]\n  },\n  \"user_metadata\": {\n    \"preferences\": { }\n  }\n}\n```\n\n## Learn more\n\n*   [Use the Management API from within Rules](https://auth0.com/docs/customize/rules/use-management-api)\n*   [Context Object Properties in Rules](https://auth0.com/docs/customize/rules/context-object)\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)",
    "title": "Manage Metadata with Rules",
    "description": "Learn how to manage with app metadata, user metadata, and client metadata using Rules.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data",
    "markdown": "# Metadata Field Names and Data Types\n\nAuth0 distinguishes between three types of metadata used to store specific kinds of information.\n\n| **Metadata Type** | **Field Name** | **Description** |\n| --- | --- | --- |\n| **User Information** | `user_metadata` | Stores user attributes such as preferences that do not impact a user's core functionality. This data **can** be edited by logged in users if you build a form using the Management API and should **not** be used as a secure data store. |\n| **Access Information** | `app_metadata` | Stores information such as permissions, Auth0 plan, and external IDs that can impact user access to features. This data **cannot** be edited by users and there are restrictions for what can be stored in this field. |\n| **Application Information** | `client_metadata` in the `Client` object, `context.clientMetadata` in Rules, and `event.client.metadata` in post-login Actions. | Stores information about an application (or _client_ in OIDC OAuth2 terminology). For example, the URL for the application home page (any value that Auth0 doesn’t set in the application settings). |\n\n## Metadata field names\n\n### Accepted characters\n\nField names must not contain the `.` (dot) or `$` (dollar sign) characters.\n\nFor example, this is not allowed:\n\n```\n{\n  \"preference.color\": \"pink\"\n}\n```\n\nBut you can expand it like this:\n\n```\n{\n    \"preference\": { \n        \"color\": \"pink\" \n    }\n}\n```\n\n### Dynamic field names\n\nField names should be static. Dynamic field names reduce indexing efficiency and cause degradation in search queries. A static schema is easier to search, manipulate, and work with.\n\nInstead of doing this:\n\n```\n{\n    \"participants\": [\n        \"Alice\": {\n            \"role\": \"sender\"\n         },\n        \"Bob\": {\n            \"role\": \"receiver\"\n        }\n    ]\n}\n```\n\nDo this:\n\n```\n{\n    \"participants\": [\n        {\n            \"name\": \"Alice\",\n            \"role\": \"sender\"\n        },\n        {\n            \"name\" : \"Bob\",\n            \"role\": \"receiver\"\n        }\n    ]\n}\n```\n\n### Name collision\n\nAvoid using the same name for `app_metadata` fields and root profile fields. The `app_metadata` field is merged onto the root profile in both Rules and Actions, which may override root profile fields.\n\nFor example, if a user has a `groups` field present on their root profile (returned from a SAML identity provider) and a `groups` field within `app_metadata`, their profile might look like this:\n\n```\n{\n    \"user_id\": \"samlp|example-samlp-connection|username@domain.com\",\n    \"groups\": [\n        \"external-group-1\",\n        \"external-group-2\"\n    ],\n    \"app_metadata\": {\n        \"groups\": [\n            \"internal-group-1\",\n            \"internal-group-2\"\n        ]\n    }\n}\n```\n\nWhen you read the `groups` field on the [User object](https://auth0.com/docs/customize/rules/user-object-in-rules) from a [Rule](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules), it will return: `[\"internal-group-1\", \"internal-group-2\"]`.\n\n## Metadata data types\n\nMetadata fields support all [JSON-compatible data types](https://datatracker.ietf.org/doc/html/rfc7159):\n\n*   String\n    \n*   Number\n    \n*   Array\n    \n*   Object\n    \n\nMake sure to keep data types consistent between users. For example, if you store a value as a string for one user (`user.user_metadata.age = \"23\"`) and as a number for another user (`user.user_metadata.age = 23`), you may encounter issues when retrieving the data.\n\n## Limitations and restrictions\n\n### Rate limits\n\nWhen you update metadata during login with [Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules) or [Actions](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata), you are subject to your tenant’s rate limits. To learn more, read [Management API Endpoint Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n### Size limits and storage\n\n*   There is a 1 MB per-user limit on user data that can be indexed, queried, and returned by the [user search endpoint](https://auth0.com/docs/api/management/v2/users/get-users). If a user profile is larger than 1 MB, any attribute values larger than 256 characters within `app_metadata` and `user_metadata` will not be searchable or returned in a search result. If the user profile is still over 1 MB after omitting these large values, then none of the `app_metadata` and `user_metadata` attributes will be searchable or returnable for that user. Auth0 captures and logs instances where a user profile is still over 1MB after omittances under the `wum` [event code](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes). The [get user endpoint](https://auth0.com/docs/api/management/v2/users/get-users-by-id) must be used to retrieve all metadata attributes for oversized user profiles.\n    \n*   When you set the `user_metadata` field using the Auth0 Authentication API [Signup endpoint](https://auth0.com/docs/api/authentication?javascript#signup), you can include a maximum of 10 string fields whose values do not exceed 500 characters each. For an example of working with metadata during a custom signup process, read [Custom Signup](https://auth0.com/docs/libraries/custom-signup).\n    \n*   The `client_metadata` field can have a maximum of 10 keys. Its keys and values have a maximum length of 255 characters each and cannot contain UTF-8 special characters.\n    \n\n### Restrictions\n\nThe `app_metadata` field must not contain any of these properties:\n\n*   `__tenant`\n    \n*   `_id`\n    \n*   `blocked`\n    \n*   `clientID`\n    \n*   `created_at`\n    \n*   `email_verified`\n    \n*   `email`\n    \n*   `globalClientID`\n    \n*   `global_client_id`\n    \n*   `identities`\n    \n*   `lastIP`\n    \n*   `lastLogin`\n    \n*   `loginsCount`\n    \n*   `metadata`\n    \n*   `multifactor_last_modified`\n    \n*   `multifactor`\n    \n*   `updated_at`\n    \n*   `user_id`\n    \n\n## Learn more\n\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)\n*   [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage)",
    "title": "Metadata Field Names and Data Types",
    "description": "Describes user metadata, app metadata, and application (client) metadata field names, data types, and limitations and restrictions.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-lock",
    "markdown": "# Manage Metadata with Lock\n\nYou can use the [Lock library](https://auth0.com/docs/libraries/lock) to define, add, read, and update the `user_metadata.` You can read the user's `user_metadata` properties the same way you would read any other user profile property. For example, the following code snippet retrieves the value associated with `user_metadata.hobby` and assigns it to an element on the page:\n\n```\n// Use the accessToken acquired upon authentication to call getUserInfo\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    document.getElementById('hobby').textContent = profile.user_metadata.hobby;\n  }\n});\n```\n\nYou can use `additionalSignUpFields` to add custom fields to user sign-up forms. When a user adds data in a custom field, Auth0 stores entered values in that user's `user_metadata`. To learn more about adding `user_metadata` on signup, read [Additional Signup Fields](https://auth0.com/docs/libraries/lock/v10/customization#additionalsignupfields-array-).\n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n*   [Lock API Reference](https://auth0.com/docs/libraries/lock/lock-api-reference)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)",
    "title": "Manage Metadata with Lock",
    "description": "Learn how to manage user and app metadata with the Auth0 Lock library.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/configure-application-metadata",
    "markdown": "# Configure Application Metadata\n\nApplication metadata is optional and consists of customizable keys and values (max 255 characters each), that you can set for each application. Metadata is exposed in the `Client` object as `client_metadata`, and in Rules as `context.clientMetadata`. You might store, for example, the URL for the application’s home page (a field that Auth0 doesn’t provide by default in the application settings).\n\nClient metadata is stored as part of the application (client) properties. To learn more about data types, field names, and storage limitations, read [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data).\n\n#### Where to store client secrets\n\nWhere to store the secret depends on the scope of the secret:\n\n*   Is it just one secret per application? Then `client_metadata` would be a good place.\n    \n*   Is it the same secret for the whole system (i.e., for all applications or many)? Then the rule’s configuration values might be a better choice\n    \n*   Is it a different secret for each user? Then storing in `app_metadata` might be better.\n    \n\nExisting applications will have no value for this property.\n\nYou can access application metadata in [Actions](https://auth0.com/docs/customize/actions):\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.client.metadata.SKIP_VERIFICATION === \"yes\"){\n    return;\n  }\n  // ... continue this Action\n}\n```\n\n... or in [Rules](https://auth0.com/docs/customize/rules):\n\n```\nfunction applicationMetadataExample (user, context, callback){\n  context.clientMetadata = context.clientMetadata || {};\n  if (context.clientMetadata.SKIP_VERIFICATION === \"yes\"){\n    return callback();\n  }\n  // ... continue this Rule\n}\n```\n\nYou can read and add to the application metadata using either the Dashboard or the Management API. To learn how to manage client metadata with the Management API, read [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api).\n\n## Add application metadata key/value pairs\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name and value, then click **Add**.\n    \n    ![Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab](https://images.ctfassets.net/cdy7uua7fh8z/7GWHyQloNihda3fuYiVEWQ/d32531dbb111dc90f491985970da76fe/dashboard-applications-applications-settings-advanced-app-metadata.png)\n4.  Click **Save Changes**.\n    \n\n## Update application metadata value\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name that you want to change and enter a new value, then click **Add**.\n    \n4.  Click **Save Changes**\n    \n\n## Delete application metadata\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab locate the key/value pair you want to delete and click the trash can icon.\n    \n4.  Confirm the deletion.\n    \n5.  Click **Save Changes**.\n    \n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret)",
    "title": "Configure Application Metadata",
    "description": "Learn how to configure, update, and delete application metadata (client_metadata and clientMetadata)  in the Auth0 Dashboard Applications Advanced Settings.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api",
    "markdown": "# Manage Metadata Using the Management API\n\n## User metadata\n\n### Create user metadata\n\nTo create a user with the following profile details:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nMake the following `POST` call to the Management API [`/post_users`](https://auth0.com/docs/api/management/v2#!/Users/post_users) endpoint to create the user and set the property values:\n\n*   [cURL](#74458d6fe1e7405faba6aa748168fffd_shell)\n*   [C#](#74458d6fe1e7405faba6aa748168fffd_csharp)\n*   [Go](#74458d6fe1e7405faba6aa748168fffd_go)\n*   [Java](#74458d6fe1e7405faba6aa748168fffd_java)\n*   [Node.JS](#74458d6fe1e7405faba6aa748168fffd_node)\n*   [Obj-C](#74458d6fe1e7405faba6aa748168fffd_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"email\": \"jane.doe@example.com\", \"user_metadata\": {\"hobby\": \"surfing\"}, \"app_metadata\": {\"plan\": \"full\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users\"\n\n\tpayload := strings.NewReader(\"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    email: 'jane.doe@example.com',\n    user_metadata: {hobby: 'surfing'},\n    app_metadata: {plan: 'full'}\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"email\": @\"jane.doe@example.com\",\n                              @\"user_metadata\": @{ @\"hobby\": @\"surfing\" },\n                              @\"app_metadata\": @{ @\"plan\": @\"full\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"email\\\": \\\"jane.doe@example.com\\\", \\\"user_metadata\\\": {\\\"hobby\\\": \\\"surfing\\\"}, \\\"app_metadata\\\": {\\\"plan\\\": \\\"full\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"email\": \"jane.doe@example.com\",\n  \"user_metadata\": [\"hobby\": \"surfing\"],\n  \"app_metadata\": [\"plan\": \"full\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Update user metadata\n\nYou can update a user's metadata by making a `PATCH` call to the Management API [`/patch_users_by_id`](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint.\n\nAssuming you created a user with the following metadata values:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\"\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\nTo update `user_metadata` and add the user's home address as a second-level property:\n\n```\n{\n    \"addresses\": {\n        \"home\": \"123 Main Street, Anytown, ST 12345\"\n    }\n}\n```\n\nYou would make the following `PATCH` call:\n\n*   [cURL](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_shell)\n*   [C#](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_csharp)\n*   [Go](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_go)\n*   [Java](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_java)\n*   [Node.JS](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_node)\n*   [Obj-C](#332a65ea34ea4d5fb9fa0f7ad8c66e5c_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"addresses\": {\"home\": \"123 Main Street, Anytown, ST 12345\"}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {user_metadata: {addresses: {home: '123 Main Street, Anytown, ST 12345'}}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"addresses\": @{ @\"home\": @\"123 Main Street, Anytown, ST 12345\" } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\"}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"addresses\": [\"home\": \"123 Main Street, Anytown, ST 12345\"]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe user's profile will now appear as follows:\n\n```\n{\n    \"email\": \"jane.doe@example.com\",\n    \"user_metadata\": {\n        \"hobby\": \"surfing\",\n        \"addresses\": {\n            \"home\": \"123 Main Street, Anytown, ST 12345\"\n        }\n    },\n    \"app_metadata\": {\n        \"plan\": \"full\"\n    }\n}\n```\n\n### Merge user metadata\n\nOnly properties at the root level are merged into the object. All lower-level properties will be replaced.\n\nFor example, to add a user's work address as an additional inner property, you would have to include the complete contents of the `addresses` property. Since the `addresses` object is a root-level property, it will be merged into the final JSON object representing the user, but its sub-properties will not.\n\n```\n{\n  \"user_metadata\": {\n    \"addresses\": {\n      \"home\": \"123 Main Street, Anytown, ST 12345\",\n      \"work\": \"100 Industrial Way, Anytown, ST 12345\"\n    }\n  }\n}\n```\n\nTherefore, the corresponding `PATCH` call to the API would be:\n\n*   [cURL](#4b2020974c664c04bf1e1e20837bb7bb_shell)\n*   [C#](#4b2020974c664c04bf1e1e20837bb7bb_csharp)\n*   [Go](#4b2020974c664c04bf1e1e20837bb7bb_go)\n*   [Java](#4b2020974c664c04bf1e1e20837bb7bb_java)\n*   [Node.JS](#4b2020974c664c04bf1e1e20837bb7bb_node)\n*   [Obj-C](#4b2020974c664c04bf1e1e20837bb7bb_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/user_id' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"addresses\": {\"home\": \"123 Main Street, Anytown, ST 12345\", \"work\": \"100 Industrial Way, Anytown, ST 12345\"}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/user_id\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/user_id\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/user_id\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/user_id',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    user_metadata: {\n      addresses: {\n        home: '123 Main Street, Anytown, ST 12345',\n        work: '100 Industrial Way, Anytown, ST 12345'\n      }\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"addresses\": @{ @\"home\": @\"123 Main Street, Anytown, ST 12345\", @\"work\": @\"100 Industrial Way, Anytown, ST 12345\" } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/user_id\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/user_id\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/user_id\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/user_id\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"addresses\\\": {\\\"home\\\": \\\"123 Main Street, Anytown, ST 12345\\\", \\\"work\\\": \\\"100 Industrial Way, Anytown, ST 12345\\\"}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"addresses\": [\n      \"home\": \"123 Main Street, Anytown, ST 12345\",\n      \"work\": \"100 Industrial Way, Anytown, ST 12345\"\n    ]]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/user_id\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Delete user metadata\n\nYou can delete `user_metadata`:\n\n## App metadata\n\nPatching the metadata with an empty object removes the metadata completely. For example, sending this body removes everything in `app_metadata`:\n\n## Client metadata\n\n### Create applications with client metadata\n\nA `clientMetadata` object can be included when creating a new application via the `POST /api/v2/` applications endpoint.\n\n### Read client metadata\n\nClient metadata is included in the response to the `GET /api/v2/clients` and `GET /api/v2/client/{id}` endpoints.\n\n### Update client metadata\n\nClient metadata can be updated using the [`PATCH /api/v2/clients/{id}`](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint, supplying an application object with the `clientMetadata property`, which has a value that consists of an object containing the metadata you'd like to change.\n\n**Application before:**\n\n```\n{\n  ...\n  \"name\": \"myclient\",\n  \"client_metadata\": {\n    \"mycolor\": \"red\",\n    \"myflavor\": \"grape\"\n  }\n  ...\n}\n```\n\nRequest: `PATCH /api/v2/client/myclientid123` with body:\n\n```\n{ \"client_metadata\": { \"mycolor\": \"blue\" } }\n```\n\n**Application after:**\n\n```\n{\n  \"name\": \"myclient\",\n  \"client_metadata\": {\n    \"mycolor\": \"blue\",\n    \"myflavor\": \"grape\"\n  }\n  ...\n}\n```\n\n### Delete client metadata properties and values\n\nClient metadata keys can be removed by issuing a PATCH, as described in \"Update app\\_metadata\" above, but supplying `null` for the key value. This behavior matches that of the `user_metadata` and `app_metadata` properties in the `PATCH` [/api/v2/users/{id}](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) endpoint.\n\n## Learn more\n\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)",
    "title": "Manage Metadata Using the Management API",
    "description": "Learn how to create, update, merge, and delete metadata with the Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata",
    "markdown": "# Manage User Metadata with the post-login Action Trigger\n\nAuth0 provides a rich system for storing [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) on the Auth0 user profile. You can configure a `post-login` trigger to modify `user_metadata` and `app_metadata` as part of a user’s login flow. Post-login triggers are useful for tasks such as storing application-specific data on the user profile, capturing user operation logs, mapping SAML attributes to the metadata field, or caching expensive operation values on the User profile for re-used in future logins.\n\nThe `post-login` `api` object provides common operations that can be performed in this trigger. To manage user metadata, we want to use the `api.user.setAppMetadata` and `api.user.setUserMetadata` methods. For example, to guard against some behavior running more than once for a specific user, consider an Action that looks like this:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.app_metadata.didAnExpensiveTask) {\n    console.log(`Skipping the expensive task because it already occurred for ${event.user.email}.`);\n    return;\n  }\n  // do and expensive task\n  api.user.setAppMetadata(\"didAnExpensiveTask\", true);\n};\n```\n\nHere, we added a check at the start of the Action to see if we have already performed the expensive task for this user. If the metadata field exists, then we return from the function.\n\nAt the end of the Action, we call `api.user.setAppMetadata` to signal that we would like to store some metadata on the user object. At the end of each trigger’s execution, Actions will update the user profile as a single operation. If several calls are made to `setUserMetadata` actions, even if they are made in different actions as part of the same flow, Actions will only update the user profile a single time--at the end of the trigger’s execution.\n\n## Best practices\n\nBeware of storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes, and users can edit their own `user_metadata` field, so don't store sensitive data in it. The metadata and search capabilities of Auth0 are not designed for marketing research or anything else that requires heavy search or update frequency. Your system is likely to run into scalability and performance issues if you use Auth0 for this purpose. A better approach is to store data in an external system and store a pointer (the user ID) in Auth0 so that backend systems can fetch the data if needed.\n\n## Rate limits\n\nEven though a single call is made to update the user profile, that operation is still subject to your tenant’s \"Write User\" [rate limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits). If the Rate Limit is hit when attempting to update metadata, Actions will retry the request as long as a `429` HTTP status code is returned. The delay between retries is governed by the value of the `X-RateLimit-Reset` header returned as part of the `429` response.\n\n## Redirects\n\nIn the event of a Redirect invoked with `api.redirect.sendUserTo()`, any pending user or app metadata updates will be applied to the user profile before the user is redirected to the external site. To learn more, see [Redirecting With Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n## Learn more\n\n*   [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions)",
    "title": "Manage User Metadata with the post-login Action Trigger",
    "description": "Learn how to use the post-login Action trigger to modify user_metadata and app_metadata as part of a user’s login flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/users/post-users",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users",
    "markdown": "# Assign Permissions to Users\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/permissions' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"permissions\": [ { \"resource_server_identifier\": \"API_IDENTIFIER\", \"permission_name\": \"PERMISSION_NAME\" }, { \"resource_server_identifier\": \"API_IDENTIFIER\", \"permission_name\": \"PERMISSION_NAME\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/permissions\"\n\n\tpayload := strings.NewReader(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/permissions',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    permissions: [\n      {\n        resource_server_identifier: 'API_IDENTIFIER',\n        permission_name: 'PERMISSION_NAME'\n      },\n      {\n        resource_server_identifier: 'API_IDENTIFIER',\n        permission_name: 'PERMISSION_NAME'\n      }\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"permissions\": @[ @{ @\"resource_server_identifier\": @\"API_IDENTIFIER\", @\"permission_name\": @\"PERMISSION_NAME\" }, @{ @\"resource_server_identifier\": @\"API_IDENTIFIER\", @\"permission_name\": @\"PERMISSION_NAME\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/permissions\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/permissions\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/USER_ID/permissions\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/permissions\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"permissions\\\": [ { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" }, { \\\"resource_server_identifier\\\": \\\"API_IDENTIFIER\\\", \\\"permission_name\\\": \\\"PERMISSION_NAME\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"permissions\": [\n    [\n      \"resource_server_identifier\": \"API_IDENTIFIER\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ],\n    [\n      \"resource_server_identifier\": \"API_IDENTIFIER\",\n      \"permission_name\": \"PERMISSION_NAME\"\n    ]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/permissions\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Assign Permissions to Users",
    "description": "Learn how to assign permissions to a user using the Auth0 Dashboard or the Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users",
    "markdown": "# Assign Roles to Users\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/roles' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"roles\": [ \"ROLE_ID\", \"ROLE_ID\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/roles\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/roles\"\n\n\tpayload := strings.NewReader(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/USER_ID/roles\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/roles',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {roles: ['ROLE_ID', 'ROLE_ID']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"roles\": @[ @\"ROLE_ID\", @\"ROLE_ID\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/roles\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/roles\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/USER_ID/roles\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/roles\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"roles\\\": [ \\\"ROLE_ID\\\", \\\"ROLE_ID\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"roles\": [\"ROLE_ID\", \"ROLE_ID\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/roles\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
    "title": "Assign Roles to Users",
    "description": "Learn how to assign roles to a user using the Auth0 Dashboard or the Management API. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options",
    "markdown": "# Select from Multiple Connection Options\n\nWith Auth0 you can offer users multiple methods of authenticating. This is important with SaaS or multi-tenant apps, where many organizations use a single app. Each organization might use different systems such as LDAP, Active Directory, Google Workspace, or username/password stores.\n\nIn Auth0, you can associate different connections (methods of authentication) to specific applications, or directly to a tenant (as [domain connections](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level)). When a user logs in, one of these connections will need to be selected as the one to use.\n\n![Home Realm Discovery in Lock](https://images.ctfassets.net/cdy7uua7fh8z/1wnZRx9V1cyyV1nRgsu9fD/f2569441334d3b277702db225045e102/2023-09-22_14-18-30.png)\n\nSelecting the appropriate Identity Providers from multiple options is called \"Home Realm Discovery\".\n\nIf you use at most one database connection and zero or more social connections the selection process is straightforward. The user will either:\n\n*   Click on one of the social identity providers buttons (e.g., \"Log in with Google\")\n    \n*   Enter their email and password (meaning \"I will use the database connection\").\n    \n\nBut if the application or tenant has other connection types enabled (like enterprise connections or multiple databases) the selection process might be more involved. How do you indicate that a user wants to use a specific database connection if more than one is enabled? What if a user wants to use an enterprise connection to log in using Single Sign-on (SSO)?\n\nIf you implement [a custom login UI](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk) you have full control over the authentication flow. You can choose the connection based on context (like the given email address) or by asking the user, then provide the `connection` parameter to one of Auth0.js' [login methods](https://auth0.com/docs/libraries/auth0js).\n\n## Lock and multiple connections\n\nLock has built-in functionality for identity provider selection. For social connections, it shows logos for all those enabled in a particular app. It also provides username/email and password fields if a database connection or Active Directory connection is enabled.\n\nYou will only see a login button if it is the only connection enabled for the application (for [Classic Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) experience). Otherwise, you will need to use a [custom UI](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk) or the [New Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience), which does support having a button for every social and enterprise connection enabled.\n\n## Using email domains with enterprise connections\n\nAn additional feature in Lock is the use of email domains as a way of routing authentication requests. Enterprise connections in Auth0 can be mapped to `domains`. For example, when configuring an ADFS or a SAML\\-P identity provider:\n\n![Configuring ADFS or SAML-P identity providers](https://images.ctfassets.net/cdy7uua7fh8z/6c8fqJpKCPNSqlop6ZJGYK/b20b1125302b8f5511825be1299e0f96/enterprise-connection.png)\n\nIf a connection has domains mapped to it, then the password input field gets disabled automatically when a user enters an email with a mapped domain.\n\n![Mapped domain login screen](https://images.ctfassets.net/cdy7uua7fh8z/6pb7kGpuHkj0rVPPaJw6Xb/373b9e7a2bf49748a1a306623c13b299/hrd-sso.png)\n\nIn the example above the domain `auth0.com` has been mapped to an enterprise connection.\n\nNotice that you can associate multiple domains to a single connection.\n\n## Selecting among multiple database connections\n\nIf your application has multiple database connections enabled, Lock needs to know which one to use. You can provide a [`connectionResolver` option](https://github.com/auth0/lock#other-options), which takes a function that decides the connection to use based on the user input and context. In this example an alternative database connection is used if the email domain is \"auth0.com\":\n\n```\nvar options = {\n  connectionResolver: function (username, context, cb) {\n    var domain = username.indexOf('@') !== -1 && username.split('@')[1];\n    if (domain && domain ==='auth0.com') {\n      // If the username is test@auth0.com, the connection used will be the `auth0-users` connection.\n      cb({ type: 'database', name: 'auth0-users' });\n    } else {\n      // Use the default approach to figure it out the connection\n      cb(null);\n    }\n  }\n}\n```\n\nYou can use the [`defaultDatabaseConnection` option](https://auth0.com/docs/libraries/lock/v11/configuration#defaultdatabaseconnection-string-) to specify the database connection that will be used by default.\n\n## Filtering available connections programmatically\n\nThe [`allowedConnections` option](https://auth0.com/docs/libraries/lock/v11/configuration#allowedconnections-array-) in Lock lets you indicate which of the available connections should be presented as an option to the user.\n\nThis lets you tailor the experience based on additional input or context (e.g. \"Click here to log in as a student, or here to log in as a faculty member\").\n\nto configure this snippet with your account\n\n```\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  {\n    allowedConnections: ['yourConnection'];\n  }\n);\n```\n\nNote that you can also provide the `allowedConnections` option to the `lock.show()` method if providing it at instantiation is not ideal for your use case. Please refer to the [API documentation](https://auth0.com/docs/libraries/lock/lock-api-reference) for the `show` method for more information.\n\n## Sending realm information from the application\n\nSometimes the application requesting an authentication can know, in advance, the realm intended to be used by the user. E.g. a multi-tenant application might use URLs in the form of: `https://{customer}.yoursite.com` or `https://www.yoursite.com/{customer}`. When a user arrives at your application with the vanity URL, you can pick up that `tenant` value and pass it as the `login_hint` in the `authorize` request:\n\n`https://{YOUR_AUTH0_DOMAIN}/authorize?client_id=[...]&login_hint={customer}`\n\n`login_hint` is a hint to the authorization server (Auth0) to indicate what the user might use to log in. In this case, based on the URL where the user landed, we treat the \"customer\" as the realm.\n\nThe default hosted login page code uses it to pre-fill the email field in Lock, but we can modify the code to alter the default database connection to be used if a realm is provided instead of an actual email address:\n\n```\n// from the default Hosted Login Page template\nvar config = JSON.parse(decodeURIComponent(escape(window.atob('@@config@@'))));\n[...]\n\nvar loginHint = config.extraParams.login_hint;\nvar realmHint;\n\n// if the login hint is not an email address, we treat it as a realm hint\nif (loginHint && loginHint.indexOf('@') < 0) {\n  realmHint = loginHint;\n  loginHint = null;\n}\n\n// now we map the realm into an actual database\nvar defaultDatabaseConnection;\nif (realmHint === 'acme') {\n  defaultDatabaseConnection = 'acme-users';\n} else if (realmHint === 'auth0') {\n  defaultDatabaseConnection = 'auth0-DB';\n}\n    \n// When configuring Lock, we provide the values obtained before\nvar lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n  [...] // other options\n  prefill: loginHint ? { email: loginHint, username: loginHint } : null,\n  defaultDatabaseConnection: defaultDatabaseConnection\n}\n```\n\nThe above code is, of course, just a sample. You could expand this logic to filter out social connections, or to set a default connection to be used even if an email address is provided as a `login_hint`.\n\nMapping the \"customer\" as a realm is an arbitrary design decision for this example. But it is generally a good idea to isolate applications from the actual \"connection\" concept used within Auth0 and use the more abstract \"realm\" concept instead, possibly doing a realm-to-connection mapping within the hosted login page (where it's easier to make changes if necessary).",
    "title": "Select from Multiple Connection Options",
    "description": "How to select different connection types for multiple login options with Lock V11.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object",
    "markdown": "# Actions Triggers: post-login - API Object\n\nThe API object for the post-login Actions trigger includes:\n\n## `api.access`\n\nModify the user's login access, such as by rejecting the login attempt.\n\n### `api.access.deny(reason)`\n\nMark the current login attempt as denied. This will prevent the end-user from completing the login flow. This will _NOT_ cancel other user-related side effects (such as metadata changes) requested by this Action. The login flow will immediately stop following the completion of this action and no further Actions will be executed.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `reason` | _String_. A human-readable explanation for rejecting the login. This is sent as `error_description` to the application that initiated the request. |\n\n## `api.accessToken`\n\nRequest changes to the access token being issued.\n\n### `api.accessToken.setCustomClaim(name, value)`\n\nSet a custom claim on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. Name of the claim (note that this may need to be a fully-qualified URL). |\n| `value` | _Any value_. The value of the claim. |\n\n### `api.accessToken.addScope(scope)`\n\nAdd a scope on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `scope` | _String_ The scope to be added. |\n\n### `api.accessToken.removeScope(scope)`\n\nRemove a scope on the Access Token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `scope` | _String_ The scope to be removed. |\n\n## `api.authentication`\n\nRequest changes to the authentication state of the current user's session.\n\n### `api.authentication.recordMethod(provider_url)`\n\nIndicate that a custom authentication method has been completed in the current session. This method will then be available in the \\`event.authentication.methods\\` array in subsequent logins.\n\n**Important**: This API is only available from within the `onContinuePostLogin` function for `PostLogin` Actions. In other words, this may be used to record the completion of a custom authentication method after redirecting the user via `api.redirect.sendUserTo()`.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `provider_url` | _String_. A url representing the identity of the custom authenticated method that was completed. |\n\n### `api.authentication.challengeWith(factor, options)`\n\nChallenge the user with one or more specified multifactor authentication factors. This method presents the default challenge first, then allows the user to select a different option if additional factors have been supplied. If the user has not enrolled in any of the factors supplied (including both the default and any additional factors), the command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _Object_. An object containing the `type` field. `type` is a string used to specify the default MFA factor or factors used to challenge the user.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `email`<br>*   `push-notification`<br><br>*   `otpFallback`When set to `false`, the user cannot use the OTP fallback option of the push notification factor.<br><br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming`<br><br>Example<br><br>```<br>api.authentication.challengeWith({ <br>    type: 'phone', <br>    options: { preferredMethod: 'both'} <br>  });<br>```<br><br>Was this helpful?<br><br>/ |\n| `options` | _Optional object_. An object containing the optional `additionalFactors` field.<br><br>`additionalFactors` is an array used to specify other factors a user can choose from when completing the MFA challenge. Supports the same values as the `type` field.<br><br>Example<br><br>```<br>api.authentication.challengeWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/ |\n\n### `api.authentication.challengeWithAny(factors)`\n\nTrigger an MFA challenge and allow the user to select their preferred factor from the supplied list. This method presents a factor picker to the user rather than a specific challenge, in accordance with the following conditions:\n\n*   If two or more factors are specified, a factor picker displays to the user.\n*   If the user has only enrolled in one of the specified factors (or only one factor is specified), the factor picker is skipped.\n*   If the user has not enrolled in any of the specified factors, the challenge command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factors` | _Array_. An array of objects that includes the `type` field. `type` is a string used to specify an MFA factor the user can choose from when challenged.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `email`<br>*   `push-notification`<br><br>*   `otpFallback`When set to `true`, the user cannot use the OTP fallback option of the push notification factor.<br><br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming` |\n\n### `api.authentication.enrollWith(factor, options)`\n\nPrompt the user to enroll with a specific MFA factor. This method prompts the user to enroll with a default factor, but can optionally allow the user to select a different option if additional factors have been supplied. If the user has already enrolled in all of the supplied factors (including both the default value and any additional factors), the command fails.\n\n**Note**: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n\n| Parameter | Description |\n| --- | --- |\n| `factor` | _Object_. An object containing the `type` field. `type` is a string used to specify the default MFA factor the user is prompted to enroll.<br><br>Supported values include:<br><br>*   `otp`<br>*   `recovery-code`<br>*   `push-notification`<br>*   `phone`<br><br>*   `preferredMethod: voice`<br>*   `preferredMethod: sms`<br>*   `preferredMethod: both`<br><br>*   `webauthn-platform`<br>*   `webauthn-roaming` |\n| `options` | _Optional object_. An object containing the optional `additionalFactors` field.<br><br>`additionalFactors` is an array used to specify other factors a user can choose from during enrollment. Supports the same values as the `type` field.<br><br>Example<br><br>```<br>api.authentication.enrollWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/<br><br>Example<br><br>```<br>api.authentication.enrollWith({<br>    type: 'otp'<br>  }, {<br>    additionalFactors: [{<br>      type: 'push-notification'<br>    }, {<br>      type: 'phone'<br>    }]<br>  })<br>```<br><br>Was this helpful?<br><br>/ |\n\n```\n<h3><code>api.authentication.enrollWithAny(factors)</code></h3>\n<p>\n  Prompt the user to select an MFA factor to enroll in from the supplied list. This method presents a factor picker to the user rather than a default factor prompt, in accordance with the following conditions: \n</p>\n<p>\n  <ul>\n    <li>If two or more factors are specified, the factor picker displays to the user.</li>\n    <li>If the user has already enrolled in all supplied factors except one, the factor picker is skipped, and the user is prompted to enroll in the remaining factor.</li>\n    <li> If the user has already enrolled in all of the supplied factors, the command fails.</li>\n</ul>\n</p>\n<p>\n    <strong>Note</strong>: This method overrides existing policies and rules that enable or disable MFA in a tenant.\n</p>\n<table class=\"table\">\n  <thead>\n    <tr>\n      <th>Parameter</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code>factors</code></td>\n      <td>\n        <p>\n          <em>Array</em>. An array of objects that includes the <code> type</code> field. <code> type</code> is a string used to specify the default MFA factor the user is prompted to enroll. \n        </p>\n          <p>Supported values include:</p>\n        <ul>\n          <li><code>otp</code></li>\n          <li><code>recovery-code</code></li>\n          <li><code>push-notification</code></li>\n          <li><code>phone</code></li>\n               <ul>\n                  <li><code>preferredMethod: voice</code></li>\n                  <li><code>preferredMethod: sms</code></li>\n                  <li><code>preferredMethod: both</code></li>\n              </ul>\n          <li><code>webauthn-platform</code></li>\n          <li><code>webauthn-roaming</code></li>\n        </ul>\n      </td>\n  </tbody>\n</table>\n```\n\n### `api.authentication.setPrimaryUser(primary_user_id)`\n\nChange the primary user for the login transaction.\n\nIn scenarios that require linking users, the user identity used to initiate the login may no longer exist as a discrete user. That identity may now be a secondary identity of an existing user. In such situations, the `setPrimaryUser()` function can be used to indicate that the subject of the login should be changed.\n\nImportant:\n\n*   Insecurely linking accounts can allow malicious actors to access legitimate user accounts, your tenant should request authentication for both accounts before linking occurs.\n*   The identity used to authenticate the login must be among the secondary identities of the user referenced by `primary_user_id`. The login will fail and tokens will not be issued otherwise.\n\n| Parameter | Description |\n| --- | --- |\n| `primary_user_id` | _String_. The user ID of the user for whom tokens should be issued (the `sub` claim). |\n\n## `api.cache`\n\nStore and retrieve data that persists across executions.\n\n### `api.cache.delete(key)`\n\nDelete a record describing a cached value at the supplied key if it exists.\n\nReturns a `CacheWriteResult` object with `type: \"success\"` if a value was removed from the cache. A failed operation returns `type: \"error\"`. For errors, the returned object will have a `code` property that indicates the nature of the failure.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.get(key)`\n\nRetrieve a record describing a cached value at the supplied `key`, if it exists. If a record is found, the cached value can be found at the `value` property of the returned object.\n\nReturns a cache record if an item is found in the cache for the supplied `key`. Cache records are objects with a `value` property holding the cached value as well as an `expires_at` property indicating the maximum expiry of the record in milliseconds since the Unix epoch.\n\n**Important:** This cache is designed for short-lived, ephemeral data. Items may not be available in later transactions even if they are within their supplied their lifetime.\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n\n### `api.cache.set(key, value, [options])`\n\nStore or update a string value in the cache at the specified key.\n\nValues stored in this cache are scoped to the Trigger in which they are set. They are subject to the [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\nValues stored in this way will have lifetimes of up to the specified `ttl` or `expires_at` values. If no lifetime is specified, a default of lifetime of 24 hours will be used. Lifetimes may not exceed the maximum duration listed at [Actions Cache Limits](https://auth0.com/docs/customize/actions/limitations).\n\n| Parameter | Description |\n| --- | --- |\n| `key` | _String_. The key of the record stored in the cache. |\n| `value` | _String_. The value of the record to be stored. |\n| `options` | _Optional object_. Options for adjusting cache behavior. |\n| `options.expires_at` | _Optional number_. The absolute expiry time in milliseconds since the unix epoch. While cached records may be evicted earlier, they will never remain beyond the the supplied `expires_at`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `ttl`. If both options are supplied, the earlier expiry of the two will be used. |\n| `options.ttl` | _Optional number_. The time-to-live value of this cache entry in milliseconds. While cached values may be evicted earlier, they will never remain beyond the the supplied `ttl`.<br><br>_Note:_ This value should not be supplied if a value was also provided for `expires_at`. If both options are supplied, the earlier expiry of the two will be used. |\n\n## `api.idToken`\n\nRequest changes to the ID token being issued.\n\n### `api.idToken.setCustomClaim(name, value)`\n\nSet a custom claim on the ID token that will be issued upon completion of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. Name of the claim (note that this may need to be a fully-qualified URL). |\n| `value` | _Any value_. The value of the claim. |\n\n## `api.multifactor`\n\nSet the requirement for multifactor authentication on the login attempt.\n\n### `api.multifactor.enable(provider, options)`\n\nEnable multifactor authentication for this login flow. When enabled, users must complete the configured multifactor challenge. The actual multifactor challenge will be deferred to the end of the login flow.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `provider` | _String_. The name of the multifactor provider to use or the value `any` to use any of the configured providers.<br><br>Supported values include:<br><br>*   `any` Use any of the configured challenges.<br>*   `duo` Use the Duo multifactor provider.<br>*   `google-authenticator` Use the Google Authenticator provider.<br>*   `guardian` Use the Guardian provider.<br>*   `none` Use none of the configured challenges to prevent the MFA flow from triggering. |\n| `options` | _Optional object_. Additional options for enabling multifactor challenges. |\n| `options.allowRememberBrowser` | _Optional boolean_. When provider is set to `google-authenticator` or `duo`, the user is prompted for MFA once every 30 days. When provider is set to `guardian`, the MFA prompt displays the enrollment checkbox for users to choose whether or not to enroll. Defaults to `false`. To learn more, read [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa) |\n| `options.providerOptions` | _Optional object_. Additional options to configure the challenge, only available for the `duo` provider.<br><br>Supported options include:<br><br>*   `host` _String_. This is the API hostname value from your Duo account.<br>*   `ikey` _String_. This is the Client ID (previously Integration key) value from your Duo account.<br>*   `skey` _String_. This is the Client secret (previously Secret key) value from your Duo account.<br>*   `username` _Optional string_. Use some attribute of the profile as the username in DuoSecurity. This is also useful if you already have your users enrolled in Duo. |\n\n## `api.user`\n\nMake application-specific changes to the metadata of the user that is logging in.\n\nNOTE: **Invoking these methods does not update the metadata immediately**. You can call them several times throughout multiple Actions of the same flow, and the engine will aggregate the changes and **update the metadata at once before the flow is completed**.\n\n### `api.user.setAppMetadata(name, value)`\n\nSet application metadata for the user that is logging in. Data stored within app\\_metadata is not editable by the user.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request hits the rate limit and fails to retry within the timeout window, you will receive a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to `null` to remove the metadata property. |\n\n### `api.user.setUserMetadata(name, value)`\n\nSet general metadata for the user that is logging in.\n\nNote: This trigger makes a call to the Management API, consuming the Management API rate limit. If this request hits the rate limit and fails to retry within the timeout window, you will receive a `Deadline Exceeded` error.\n\nReturns a reference to the `api` object.\n\n| Parameter | Description |\n| --- | --- |\n| `name` | _String_. The name of metadata property. |\n| `value` | _Any value_. The value of the metadata property. This may be set to `null` to remove the metadata property. |\n\n## `api.redirect`\n\n### `api.redirect.encodeToken(options)`\n\nCreate a session token suitable for using as a query string parameter redirect target (via `sendUserTo`) that contains data whose authenticity must be provable by the target endpoint. The target endpoint can verify the authenticity and integrity of the data by checking the JWT's signature using a shared secret.\n\nReturns a JWT string.\n\n| Parameter | Description |\n| --- | --- |\n| `options` | _Options_. Configure how sensitive data is encoded into the query parameters of the resulting url. |\n| `options.expiresInSeconds` | _Number_. Number of seconds before this token will expire (defaults to 900). |\n| `options.payload` | _Options_. The data intended to be passed to the target of the redirect and whose authenticity and integrity must be provable. |\n| `options.secret` | _String_. A secret that will be used to sign a JWT that is shared with the redirect target. The secret value should be stored as a secret and retrieved using `event.secrets['SECRET_NAME']`. |\n\n```\n<section>\n  <h3><code>api.redirect.sendUserTo(url, options)</code></h3>\n  <p>\n    Trigger a browser redirect to the target `url` immediately after this\n    action completes.\n  </p>\n  <p>Returns a reference to the <code>api</code> object.</p>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>Parameter</th>\n        <th>Description</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td><code>url</code></td>\n        <td>\n          <p><em>String</em>. The url in which to redirect the user.</p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options</code></td>\n        <td>\n          <p>\n            <em>Options</em>. An object representing additional query string\n            parameters that should be appended to the redirect URL.\n          </p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.query</code></td>\n        <td>\n          <p>\n            <em>Options</em>. Additional query string parameters that should\n            be appended to the redirect URL.\n          </p>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</section>\n\n<section>\n  <h3><code>api.redirect.validateToken(options)</code></h3>\n  <p>\n    Retrieve the data encoded in a JWT token passed to the\n    <code>/continue</code> endpoint while verifying the authenticity and\n    integrity of that data.\n  </p>\n  <p>Returns payload of the JWT token.</p>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>Parameter</th>\n        <th>Description</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td><code>options</code></td>\n        <td>\n          <p>\n            <em>Options</em>. Options for retrieving the data encoded in a JWT\n            token passed to the <code>/continue</code> endpoint following a\n            redirect.\n          </p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.secret</code></td>\n        <td>\n          <p><em>String</em>. Secret used to encode the token.</p>\n        </td>\n      </tr>\n      <tr>\n        <td><code>options.tokenParameterName</code></td>\n        <td>\n          <p>\n            <em>String</em>. The name of the query or body parameter that was\n            sent to the <code>/continue</code> endpoint. (defaults to\n            <code>session_token</code>\n          </p>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</section>\n<section>\n  <h3><code>api.rules</code></h3>\n  <p>\n    Get information about the Rules that have run during the current transaction.\n  </p>\n  <h3><code>api.rules.wasExecuted(ruleId)</code></h3>\n  <p>Check whether a specific Rule has been executed prior to this Action in the current transaction. This can be used to avoid running logic that has been duplicated from that Rule into this Action during migration to Actions.\n```\n\nThis method returns `true` when the Rule with the provided ID has been executed in this transaction and `false` when it has not..\n\n| Parameter | Description |\n| --- | --- |\n| `ruleId` | String. The Rule ID to check. |\n\n## `api.samlResponse`\n\nModify the SAML Response for the user that is logging in.\n\n### `api.samlResponse.setAttribute(attribute, value)`\n\nSet a custom SAML attribute.\n\nA failed operation throws an `Error`. For errors, the returned object has a message that indicates the nature of the failure.\n\nThe value must be of type `SAMLValue`, which can be `string | number | boolean | null | Array < string | number | boolean >`\n\n| Parameter | Description |\n| --- | --- |\n| `attribute` | _String_. The SAML attribute to be set. |\n| `value` | _SAMLValue_. The value of the SAML assertion. This may be set to `null` to remove the attribute property. |\n\n### `api.samlResponse.setAudience(audience)`\n\nAlter the audience of the SAML Response. Default is the issuer on SAMLRequest.\n\n| Parameter | Description |\n| --- | --- |\n| `audience` | _String_. The SAML audience to be set. |\n\n### `api.samlResponse.setEncryptionPublicKey(publicKey)`\n\nOptionally specify a public key used to encrypt the SAML assertion. The public key should be obtained from the service provider. Both the public key and certificate must be specified.\n\n| Parameter | Description |\n| --- | --- |\n| `publicKey` | _String_. The public key to be set. |\n\n### `api.samlResponse.setRecipient(recipient)`\n\nAlter the recipient of the SAML assertion (SubjectConfirmationData). Default is `AssertionConsumerUrl` on `` SAMLRequest `or callback URL if no SAMLRequest was sent.` ``\n\n````````` ````````   | Parameter | Description | | --- | --- | | `recipient` | _String_. The SAML recipient to be set. |  ### `api.samlResponse.setCreateUpnClaim(createUpnClaim)`  Dictates if a UPN claim should be created. Default is `true`.  | Parameter | Description | | --- | --- | | `createUpnClaim` | _Boolean_ Toggle to create a UPN claim. |  ### `api.samlResponse.setPassthroughClaimsWithNoMapping(passthroughClaimsWithNoMapping)`  If `true` (default), for each claim that is not mapped to the common profile, Auth0 passes through those in the output assertion. If `false`, those claims won't be mapped.  | Parameter | Description | | --- | --- | | `passthroughClaimsWithNoMapping` | _Boolean_ Should claims should be mapped to the output assertion. |  ### `api.samlResponse.setMapUnknownClaimsAsIs(mapUnknownClaimsAsIs)`  If `passthroughClaimsWithNoMapping` is `true` and this is `false` (default), for each claim not mapped to the common profile Auth0 adds a prefix http://schema.auth0.com. If `` true`, it will pass through the claim as-is.` ``  ``````` ``````   | Parameter | Description | | --- | --- | | `mapUnknownClaimsAsIs` | _Boolean_ Should claims should be mapped as-is. |  ### `api.samlResponse.setMapIdentities(mapIdentities)`  If `true` (default), this adds more information in the token such as the provider (Google, ADFS, AD, etc.) and the access token, if available  | Parameter | Description | | --- | --- | | `mapIdentities` | _Boolean_ Should identities be mapped. |  ### `api.samlResponse.setDestination(destination)`  Destination of the SAML response. If not specified, it will be AssertionConsumerUrl of SAMLRequest or callback URL if there was no SAMLRequest.  | Parameter | Description | | --- | --- | | `destination` | _String_ Destination of the SAML response. |  ### `api.samlResponse.setLifetimeInSeconds(lifetimeInSeconds)`  Expiration of the token in seconds. Default is `` 3600 `seconds (1 hour).` ``  ````` ````   | Parameter | Description | | --- | --- | | `lifetimeInSeconds` | _Number_ Expiration of the token in seconds. |  ### `api.samlResponse.setSignResponse(signResponse)`  Whether or not the SAML response should be signed. By default the SAML assertion will be signed, but not the SAML response. If `true`, SAML Response will be signed instead of SAML assertion. Default to `false`.  | Parameter | Description | | --- | --- | | `signResponse` | _Boolean_ Should the SAML response be signed. |  ### `api.samlResponse.setNameIdentifierFormat(nameIdentifierFormat)`  Sets the name ID format. Default is `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`.  | Parameter | Description | | --- | --- | | `nameIdentifierFormat` | _String_ The Name ID Format. |  ### `api.samlResponse.setNameIdentifierProbes(nameIdentifierProbes)`  Auth0 tries to name each of the attributes of this array in order. If one of them has a value, it will use that for the Subject/NameID. The order is:  1.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier (mapped from `user_id`) 2.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress (mapped from `email`), 3.  http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name (mapped from `name`)  | Parameter | Description | | --- | --- | | `nameIdentifierProbes` | _String array_ An array of attributes to try for the name identifier. |  ### `api.samlResponse.setAuthnContextClassRef(authnContextClassRef)`  Default is `urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified`.  | Parameter | Description | | --- | --- | | `authnContextClassRef` | _String_ The AuthnContextClassRef. |  ### `api.samlResponse.setSigningCert(signingCert)`  Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `signingCert` | _String_ Optional public key certificate used to validate SAML requests. |  ### `api.samlResponse.setIncludeAttributeNameFormat(includeAttributeNameFormat)`  When set to `true`, we infer the NameFormat based on the attribute name. NameFormat values are ``` urn:oasis:names:tc:SAML:2.0:attrname-format:uri``, `urn:oasis:names:tc:SAML:2.0:attrname-format:basic` and `urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified`.`` ```  ``` ``   If set to `false`, the attribute NameFormat is not set in the assertion. Default is `true`.  | Parameter | Description | | --- | --- | | `includeAttributeNameFormat` | _Boolean_Should NameFormat be inferred based on the attribute name. |  ### `api.samlResponse.setTypedAttributes(typedAttributes)`  When set to `true`, we infer the `xs:type` of the element. Types are `xs:string`, `xs:boolean`, `xs:double` and `xs:anyType`. When set to `false` all `xs:type` are `xs:anyType`. Default is `true`.  | Parameter | Description | | --- | --- | | `typedAttributes` | _Boolean_Should `xs:type` be inferred. |  ### `api.samlResponse.setEncryptionCert(encryptionCert)`  Optionally specify a certificate used to encrypt the SAML assertion. The certificate should be obtained from the service provider. Both the certificate and public key must be specified. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `encryptionCert` | _String_Optional certificate to encrypt the SAML assertion. |  ### `api.samlResponse.setCert(cert)`  By default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own certificate and private key.  Both the certificate and private key must be specified.  A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.  | Parameter | Description | | --- | --- | | `cert` | _String_Optional certificate to sign the SAML responses or assertions. |  ### `api.samlResponse.setKey(key)`  By default, Auth0 will use the private/public key pair assigned to your tenant to sign SAML responses or assertions. For very specific scenarios, you might wish to provide your own certificate and private key.  Since this private key is sensitive, we recommend using the **Add Secret functionality of Actions**. See here for more details: Write Your First Action  Both the certificate and private key must be specified.  A sample value would be `\"-----BEGIN PRIVATE KEY-----\\nnMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END PRIVATE KEY-----\\n\"`.  | Parameter | Description | | --- | --- | | `key` | _String_Optional private key to sign the SAML responses or assertions. |  ### `api.samlResponse.setSignatureAlgorithm(signatureAlgorithm)`  **Deprecated**: Default is `rsa-sha256`  | Parameter | Description | | --- | --- | | `signatureAlgorithm` | `rsa-sha256` \\| `rsa-sha1`. `rsa-sha1` should not be used. This is insecure. |  ### `api.samlResponse.setDigestAlgorithm(digestAlgorithm)`  **Deprecated**: Default is `sha256`  | Parameter | Description | | --- | --- | | `digestAlgorithm` | `sha256` \\| `sha1`. `rsa-sha1` should not be used. This is insecure. |   `` ``` ```` ````` `````` ``````` ```````` `````````",
    "title": "Actions Triggers: post-login - API Object",
    "description": "Learn about the post-login Action trigger's API object.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow",
    "markdown": "# Machine to Machine Flow\n\nThe Machine to Machine Flow runs when an Access Token is being issued via the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\n![Diagram showing the Actions Machine to Machine Flow and when the triggers inside of it run.](https://images.ctfassets.net/cdy7uua7fh8z/1JPl54LFWCUh5StuglZS2o/41f89372526574c3b8cdac4d5ba38072/Machine_to_Machine_Flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### M2M / Client Credentials\n\nThe `credentials-exchange` trigger is a function executed before the access token is returned.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/event-object): Provides contextual information about the request for a client credentials exchange.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow/api-object): Provides methods for changing the behavior of the flow\n    \n\n## Common use cases\n\n### Access control\n\nA credentials-exchange Action can be used to deny an access token based on custom logic.\n\n```\n/**\n * @param {Event} event - Details about client credentials grant request.\n * @param {CredentialsExchangeAPI} api - Interface whose methods can be used to change the behavior of client credentials grant.\n */\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  if (event.request.geoip.continentCode === \"NA\") {\n    api.access.deny('invalid_request', \"Access from North America is not allowed.\");\n  }\n};\n```\n\n### Add custom claims to the access token\n\nA credentials-exchange Action can be used to add custom claims to an access token.\n\n```\n/**\n * @param {Event} event - Details about client credentials grant request.\n * @param {CredentialsExchangeAPI} api - Interface whose methods can be used to change the behavior of client credentials grant.\n */\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  api.accessToken.setCustomClaim(\"https://my-api.exampleco.com/request-ip\", event.request.ip);  \n};\n```",
    "title": "Machine to Machine Flow",
    "description": "Learn about the Actions Machine to Machine Flow and the credentials-exchange Action trigger, which runs as part of the Machine to Machine Flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/releases",
    "markdown": "# Releases\n\nFeatures and breaking changes released in versions of Triggers in the Login Flow are listed below.\n\n## v3 (GA)\n\n### Post-login\n\n#### Breaking changes\n\n*   `api.redirect.canRedirect()` marked as deprecated.\n    \n*   `api.redirect.sendUserTo()` will no longer skip redirecting when in a non-interactive flow. This means that calls to `api.redirect.sendUserTo()` should first check if the redirect is needed before issuing the redirect. Information like `event.authentication.methods` can be consulted to see if a redirect was successfully completed and recorded via `api.authentication.recordMethod()`. Attempting to trigger a redirect in a non-interactive flow will correctly trigger an `interaction_required` error.\n    \n\n#### New features\n\n*   `event.authentication.methods` may now also contain custom methods completed by users within that session and recorded using `api.authentication.recordMethod()` from the `onContinuePostLogin` handler.\n    \n*   `api.authentication.recordMethod()` is added as a way to store a record for the completion of a custom method in the user’s session. These APIs allow you to strictly require custom factors for certain scenarios. The user (on a specific device) will be required to complete the custom factor, regardless of whether or not an interactive login is happening. If the conditions are met for requiring the custom factor and the user’s session doesn’t have a record of its completion, the interactivity of the flow shouldn’t influence whether the factor is required or not. For example, if you wanted to implement a required custom factor, you would set up the following:\n    \n    1.  In `onExecutePostLogin`, search for a record in the `event.authentication.methods` array with the custom method’s identifier URL. If the method is there and has a current enough timestamp, allow the login to continue. Otherwise, trigger a redirect to the URL implementing the custom factor using `api.redirect.sendUserTo()`. Custom data can be encoded into a JWT and signed using `api.redirect.encodeToken()`.\n        \n    2.  When the user is redirected to `/continue`, the `onContinuePostLogin` handler will be invoked. Within that handler, validate any data coming back from the custom factor (if needed) and signal its completion by calling `api.authentication.recordMethod()`.\n        \n\n## v2 (GA)\n\n### Post-login\n\n#### Breaking changes\n\n##### Perform side effects\n\nIn the pre-GA version of the post-login trigger, side effects were performed by returning an object from an Action. In Actions GA, an `api` object is provided to encapsulate these changes and provide better in-editor type hints and inline documentation.\n\n**Update user user\\_metadata**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      userMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setUserMetadata('myParam', 'foo');\n}\n```\n\n**Update user app\\_metadata**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    user: {\n      appMetadata: {\n        myParam: \"foo\"\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.user.setAppMetadata('myParam', 'foo');\n}\n```\n\n**Deny a login**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  throw new Error(\"Access denied.\");\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.access.deny(\"Access denied.\");\n}\n```\n\n**Add Custom Claims to the Access Token**\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    accessToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.accessToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n**Add Custom Claims to the ID Token**\n\nPre-GA Trigger:\n\n```\nasync function myFunc(event, context) {\n  return {\n    idToken: {\n      customClaims: {\n        'https://example.com/custom/claim': 'Custom claim value',\n      }\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function myFunc(event, api) {\n  api.idToken.setCustomClaim('https://example.com/custom/claim', 'Custom claim value');\n}\n```\n\n**Dynamically enable multi-factor authentication**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"multifactor\",\n      provider: \"any\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.multifactor.enable(\"duo\");\n}\n```\n\n**Redirect the user**\n\nPre-GA Trigger:\n\n```\nasync function myFunction(event, context) {\n  return {\n    command: {\n      type: \"redirect\",\n      url: \"https://my-app.example.com\"\n    }\n  };\n}\n```\n\nGA Trigger:\n\n```\nasync function onExecutePostLogin(event, api) {\n  api.redirect.sendUserTo(\"https://my-app.example.com\");\n}\n```\n\nTo ensure parameters are being sent securely and to avoid replay attacks, passing data via redirects has changed significantly in Actions GA. For more information, see [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n##### Manipulate scopes\n\nAlthough we experimented with providing direct manipulation of ID and Access Token scopes during the Actions Beta, we do not support this functionality in Actions GA.",
    "title": "Releases",
    "description": "Learn about released versions of Triggers in the Actions Login Flow, including breaking changes and new features.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow",
    "markdown": "# Pre User Registration Flow\n\nThe Pre User Registration Flow runs before a user is added to a Database or Passwordless Connection.\n\n![Diagram showing the Actions Pre User Registration Flow.](https://images.ctfassets.net/cdy7uua7fh8z/2KtUcZhaBcT12GxjhBJZFG/9633b4454ac1c06c0deed6c97e70fe7d/pre-user-registration-flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Pre User Registration\n\nThe `pre-user-registration`  triggers runs when a user attempts to register through a Database or Passwordless connection. This trigger can be used to add metadata to the user profile before it is created or to deny a registration with custom logic.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/event-object): Provides contextual information about the request to register a new user.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow/api-object): Provides methods for changing the behavior of the flow\n    \n\n## Common use cases\n\n### Deny registration by location\n\nA pre-user-registration Action can be used to prevent a user from signing up.\n\n```\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  if (event.request.geoip.continentCode === \"NA\") {\n\n    // localize the error message \n    const LOCALIZED_MESSAGES = {\n      en: 'You are not allowed to register.',\n      es: 'No tienes permitido registrarte.'\n    };\n\n    const userMessage = LOCALIZED_MESSAGES[event.request.language] || LOCALIZED_MESSAGES['en'];\n    api.access.deny('no_signups_from_north_america', userMessage);\n  }\n};\n```\n\n### Set metadata in the user profile\n\nA pre-user-registration Action can be used to add metadata to the user profile before it is created. Currently, you cannot add metadata to Passwordless users with a pre-user-registration Action.\n\n```\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  api.user.setUserMetadata(\"screen_name\", \"username\");  \n};\n```\n\n### Store a user ID from another system in the user profile\n\nA pre-user-registration Action can be used to store a user ID from another system in the user profile.\n\n```\nconst axios = require(\"axios\");\n\n/**\n * @param {Event} event - Details about registration event.\n * @param {PreUserRegistrationAPI} api\n */\nexports.onExecutePreUserRegistration = async (event, api) => {\n  const remoteUser = await axios.get(\"https://my-api.exampleco.com/users\", { params: { email: event.user.email }});\n\n  if (remoteUser) {\n    api.user.setAppMetadata(\"my-api-user-id\", remoteUser.id); \n  }\n};\n```",
    "title": "Pre User Registration Flow",
    "description": "Learn about the Pre User Registration Flow, which runs when a user attempts to register through a Database or Passwordless connection. It can be used to add metadata to the user profile before it is created or to deny a registration.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow",
    "markdown": "# Post User Registration Flow\n\nThe Post User Registration Flow runs after a user is added to a Database or Passwordless Connection.\n\n![Diagram of the Actions Post User Registration Flow.](https://images.ctfassets.net/cdy7uua7fh8z/4bqF9YEPYQshnJGCx39pws/079798c354f4a83355a756a6a02650d5/post-user-registration-flow.png)\n\nActions in this flow are non-blocking (asynchronous), which means the Auth0 pipeline will continue to run without waiting for the Action to finish its execution. Thus, the Action's outcome does not affect the Auth0 transaction.\n\n## Triggers\n\n### Post User Registration\n\nThe `post-user-registration` triggers runs after a user has been created for a Database or Passwordless connection. This trigger can be used to notify another system that a user has registered for your application. Multiple actions can be bound to this trigger, and the actions will run in order. However, these actions will be run asynchronously and will not block the user registration process.\n\n### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/event-object): Provides contextual information about the newly-created user.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Notify Slack when a new user registers\n\n```\n/**\n* Handler that will be called during the execution of a PostUserRegistration flow.\n* \n * @param {Event} event - Details about the context and user that has registered.\n * @param {PostUserRegistrationAPI} api - Interface whose methods can be used to change the behavior of post user registration.\n */\n\nexports.onExecutePostUserRegistration = async (event, api) => {\n  const { IncomingWebhook } = require(\"@slack/webhook\");\n  const webhook = new IncomingWebhook(event.secrets.SLACK_WEBHOOK_URL);\n\n  const text = `New User: ${event.user.email}`;\n  const channel = '#some_channel';\n\n  webhook.send({ text, channel });\n};\n```\n\n### Store the Auth0 user id in a remote system\n\nA post-user-registration Action can be used to store the Auth0 user ID in a remote system.\n\n```\n/**\n* Handler that will be called during the execution of a PostUserRegistration flow.\n* \n* @param {Event} event - Details about the context and user that has registered.\n* @param {PostUserRegistrationAPI} api - Interface whose methods can be used to change the behavior of post user registration.\n*/\n\nconst axios = require(\"axios\");\n\nexports.onExecutePostUserRegistration = async (event, api) => {\n  await axios.post(\"https://my-api.exampleco.com/users\", { params: { email: event.user.email }});\n};\n```",
    "title": "Post User Registration Flow",
    "description": "Learn about the Post User Registration Flow and post-user-registration Action trigger, which runs after a user has been created for a Database or Passwordless connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa",
    "markdown": "# Embedded Passwordless Authentication for SPAs\n\n## Using Auth0's SDKs to implement Embedded Login\n\nYou can implement Passwordless Login using Auth0's Lock widget, or if you need complete control of the user experience, you can implement it using Auth0.js:\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n    \n*   [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js)\n    \n\n### Configure Cross-Origin Resource Sharing (CORS)\n\nFor security purposes, your app's origin URL must be listed as an approved URL. If you have not already added it to the **Allowed Callback URLS** for your application, you will need to add it to the list of **Allowed Origins (CORS)**.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the name of your application to see its settings.\n    \n2.  Locate **Allowed Origins (CORS)**, enter your application's [origin URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin), and select **Save Changes**.",
    "title": "Embedded Passwordless Authentication for SPAs",
    "description": "Describes implementing Passwordless authentication with embedded login in single-page applications (SPAs).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow",
    "markdown": "# Send Phone Message Flow\n\nThe Send Phone Message Flow allows you to execute code when using SMS/Voice as a factor for [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication). When using a [custom provider](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa#custom-phone-messaging-providers) to send the messages, this flow's `send-phone-message` trigger is required to configure your custom provider.\n\n![Diagram of the Actions Send Phone Message Flow.](https://images.ctfassets.net/cdy7uua7fh8z/FSkVXDdknDJq1hsK08EYu/e031ec0067a5460afae8d9ed5d462288/send-phone-message-flow.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Send Phone Message\n\nThe `send-phone-message` trigger will run for the enrollment process and the challenge process (`event.message_options.action`). It will also run for the `voice` message type when using the New experience for Universal Login (`event.message_options.message_type === 'voice'`).\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/event-object): Provides contextual information about the message to be sent and the user to be challenged or enrolled.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Use a custom SMS provider\n\n```\nconst AWS = require(\"aws-sdk\");\n\n/**\n * Handler that will be called during the execution of a SendPhoneMessage flow.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n */\nexports.onExecuteSendPhoneMessage = async (event) => {\n  const text = event.message_options.text;\n  const recipient = event.message_options.recipient;\n\n  const awsSNS = new AWS.SNS({\n    apiVersion: \"2010-03-31\",\n    region: event.secrets.AWS_REGION,\n    credentials: new AWS.Credentials(event.secrets.AWS_ACCESS_KEY_ID, event.secrets.AWS_SECRET_ACCESS_KEY)\n  });\n\n  const params = { Message: text, PhoneNumber: recipient };\n\n  return awsSNS\n    .publish(params)\n    .promise();\n};\n```",
    "title": "Send Phone Message Flow",
    "description": "Learn about Action's Send Phone Message flow and the send-phone-message Action trigger, which runs for the enrollment and challenge process if you have used SMS as a factor for Multi-factor Authentication (MFA).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native",
    "markdown": "# Embedded Passwordless Login in Native Applications\n\nTo use the Embedded Passwordless APIs in Native applications, make sure you enable the **Passwordless OTP** grant at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nPasswordless authentication for Native applications consists of two steps:\n\n*   Capture the user identifier in your application (the user's email or phone number) and invoke the `/passwordless/start` endpoint to initiate the passwordless flow. The user will get an email or an SMS with a one-time password.\n    \n*   Prompt the user for the one-time-use code, and call the `/oauth/token` endpoint to get authentication tokens.\n    \n\nBelow we list a few code snippets that can be used to call these API endpoints for different scenarios.\n\n**Send a one-time-use password via email**\n\n*   [cURL](#65f3faa6ebb44cbe93f1f45cff96fb91_shell)\n*   [C#](#65f3faa6ebb44cbe93f1f45cff96fb91_csharp)\n*   [Go](#65f3faa6ebb44cbe93f1f45cff96fb91_go)\n*   [Java](#65f3faa6ebb44cbe93f1f45cff96fb91_java)\n*   [Node.JS](#65f3faa6ebb44cbe93f1f45cff96fb91_node)\n*   [Obj-C](#65f3faa6ebb44cbe93f1f45cff96fb91_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",  \"connection\": \"email\",   \"email\": \"USER_EMAIL\",  \"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'email',\n    email: 'USER_EMAIL',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"USER_EMAIL\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"email\\\",   \\\"email\\\": \\\"USER_EMAIL\\\",  \\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"email\",\n  \"email\": \"USER_EMAIL\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a magic link via email**\n\n*   [cURL](#503a5ab9c6664791a92a38b9b227d423_shell)\n*   [C#](#503a5ab9c6664791a92a38b9b227d423_csharp)\n*   [Go](#503a5ab9c6664791a92a38b9b227d423_go)\n*   [Java](#503a5ab9c6664791a92a38b9b227d423_java)\n*   [Node.JS](#503a5ab9c6664791a92a38b9b227d423_node)\n*   [Obj-C](#503a5ab9c6664791a92a38b9b227d423_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"connection\": \"email\", \"email\": \"USER_EMAIL\", \"send\": \"link\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'email',\n    email: 'USER_EMAIL',\n    send: 'link'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"USER_EMAIL\",\n                              @\"send\": @\"link\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"USER_EMAIL\\\", \\\"send\\\": \\\"link\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"email\",\n  \"email\": \"USER_EMAIL\",\n  \"send\": \"link\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a one-time-use password via SMS**\n\n*   [cURL](#ad2f041ba0a94ba5992bfbb208223368_shell)\n*   [C#](#ad2f041ba0a94ba5992bfbb208223368_csharp)\n*   [Go](#ad2f041ba0a94ba5992bfbb208223368_go)\n*   [Java](#ad2f041ba0a94ba5992bfbb208223368_java)\n*   [Node.JS](#ad2f041ba0a94ba5992bfbb208223368_node)\n*   [Obj-C](#ad2f041ba0a94ba5992bfbb208223368_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\",  \"connection\": \"sms\",  \"phone_number\": \"USER_PHONE_NUMBER\", \"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    connection: 'sms',\n    phone_number: 'USER_PHONE_NUMBER',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"connection\": @\"sms\",\n                              @\"phone_number\": @\"USER_PHONE_NUMBER\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"connection\\\": \\\"sms\\\",  \\\"phone_number\\\": \\\"USER_PHONE_NUMBER\\\", \\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"sms\",\n  \"phone_number\": \"USER_PHONE_NUMBER\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an SMS user**\n\n*   [cURL](#f9da0850942e49eda8bd2bb8ddc50210_shell)\n*   [C#](#f9da0850942e49eda8bd2bb8ddc50210_csharp)\n*   [Go](#f9da0850942e49eda8bd2bb8ddc50210_go)\n*   [Java](#f9da0850942e49eda8bd2bb8ddc50210_java)\n*   [Node.JS](#f9da0850942e49eda8bd2bb8ddc50210_node)\n*   [Obj-C](#f9da0850942e49eda8bd2bb8ddc50210_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",  \"client_id\": \"{yourClientId}\",  \"username\": \"USER_PHONE_NUMBER\",  \"otp\": \"code\",  \"realm\": \"sms\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    username: 'USER_PHONE_NUMBER',\n    otp: 'code',\n    realm: 'sms',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"username\": @\"USER_PHONE_NUMBER\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"sms\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\",  \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"username\\\": \\\"USER_PHONE_NUMBER\\\",  \\\"otp\\\": \\\"code\\\",  \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USER_PHONE_NUMBER\",\n  \"otp\": \"code\",\n  \"realm\": \"sms\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an Email user**\n\n*   [cURL](#fec57df2255149c4bf86543d6d5e37ad_shell)\n*   [C#](#fec57df2255149c4bf86543d6d5e37ad_csharp)\n*   [Go](#fec57df2255149c4bf86543d6d5e37ad_go)\n*   [Java](#fec57df2255149c4bf86543d6d5e37ad_java)\n*   [Node.JS](#fec57df2255149c4bf86543d6d5e37ad_node)\n*   [Obj-C](#fec57df2255149c4bf86543d6d5e37ad_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"username\": \"USER_EMAIL\", \"otp\": \"code\", \"realm\": \"email\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    username: 'USER_EMAIL',\n    otp: 'code',\n    realm: 'email',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"username\": @\"USER_EMAIL\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"email\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"username\\\": \\\"USER_EMAIL\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USER_EMAIL\",\n  \"otp\": \"code\",\n  \"realm\": \"email\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf you prefer, you can use the Android or iOS SDKs, which wrap this APIs in a platform-friendly way:\n\n*   [Lock.Android Passwordless](https://auth0.com/docs/libraries/lock-android/lock-android-passwordless)\n    \n*   [Lock.swift Passwordless](https://auth0.com/docs/libraries/lock-swift/lock-swift-passwordless)\n    \n*   [Auth0.Android Passwordless](https://auth0.com/docs/libraries/auth0-android/auth0-android-passwordless)\n    \n*   [Auth0.swift Passwordless](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-passwordless)",
    "title": "Embedded Passwordless Login in Native Applications",
    "description": "Describes implementing Passwordless authentication with embedded login in native applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl",
    "markdown": "# TLS (SSL) Versions and Ciphers\n\nAuth0’s network edge has a secure set of allowed SSL/TLS version/cipher suite combinations. When connecting to Auth0 services using a reverse proxy with self-managed certificates, you **must** use a supported TLS version and cipher suite. During the TLS handshake, communication between the server and client specifies the TLS version and cipher suite. If you are not using a supported version, a failure could occur.\n\n## Supported Versions\n\nAuth requires using TLS version 1.2 or 1.3 with the supported ciphers.\n\n#### TLS 1.3 Supported Ciphers\n\nAEAD-AES128-GCM-SHA256  \nAEAD-AES256-GCM-SHA384  \nAEAD-CHACHA20-POLY1305-SHA256  \n\n#### TLS 1.2 Supported Ciphers\n\nECDHE-ECDSA-AES128-GCM-SHA256  \nECDHE-ECDSA-CHACHA20-POLY1305  \nECDHE-RSA-AES128-GCM-SHA256  \nECDHE-RSA-CHACHA20-POLY1305  \nECDHE-ECDSA-AES128-SHA256  \nECDHE-ECDSA-AES128-SHA  \nECDHE-RSA-AES128-SHA256  \nECDHE-RSA-AES128-SHA  \nAES128-GCM-SHA256  \nAES128-SHA256  \nAES128-SHA  \nECDHE-ECDSA-AES256-GCM-SHA384  \nECDHE-ECDSA-AES256-SHA384  \nECDHE-RSA-AES256-GCM-SHA384  \nECDHE-RSA-AES256-SHA384  \nECDHE-RSA-AES256-SHA  \nAES256-GCM-SHA384  \nAES256-SHA256  \nAES256-SHA  \n\n#### TLS RFCs\n\n[TLS 1.2](https://tools.ietf.org/html/rfc5246)[](https://tools.ietf.org/html/rfc8446)\n\n[TLS 1.3](https://tools.ietf.org/html/rfc8446)\n\n#### TLS Parameters\n\nTo learn more, read [Transport Layer Security (TLS) Parameters](https://www.iana.org/assignments/tls-parameters) for the Internet Assigned Numbers Authority (IANA) list of registered parameters including ciphers.\n\n## Learn more\n\n*   [Configure Cloudflare as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
    "title": "TLS (SSL) Versions and Ciphers",
    "description": "Check supported TLS versions and ciphers if you are using a reverse proxy configured for use with self-managed certificates",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps",
    "markdown": "# Embedded Passwordless Login in Regular Web Applications\n\nTo use the Embedded Passwordless APIs in Regular Web Applications, make sure you enable the **Passwordless OTP** grant at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nPasswordless authentication for Regular Web Applications consists of two steps:\n\n1.  Capture the user identifier in your application (the user's email or phone number) and invoke the `/passwordless/start` endpoint to initiate the passwordless flow. The user will get an email, an SMS with a one-time-use code, or a magic link.\n    \n2.  If you did not send a magic link, prompt the user for the one-time-use code, and call the `/oauth/token` endpoint to get authentication tokens.\n    \n\nNote that when using magic links, you don't need to call `/oauth/token`. The user will click the magic link and be redirected to the application's callback URL.\n\nBelow, we list a few code snippets that can be used to call these API endpoints for different scenarios. Auth0 SDKs for backend technologies (for example, Java, .NET, Ruby, PHP, Python, Node JS) haven't been updated to support these endpoints yet, so you will need to invoke them directly.\n\n**Send a one-time-use code via email**\n\n*   [cURL](#97124668b6ad4cfc81d4fba400d19c29_shell)\n*   [C#](#97124668b6ad4cfc81d4fba400d19c29_csharp)\n*   [Go](#97124668b6ad4cfc81d4fba400d19c29_go)\n*   [Java](#97124668b6ad4cfc81d4fba400d19c29_java)\n*   [Node.JS](#97124668b6ad4cfc81d4fba400d19c29_node)\n*   [Obj-C](#97124668b6ad4cfc81d4fba400d19c29_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"email\", \"email\": \"{userEmail}\",\"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'email',\n    email: '{userEmail}',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"{userEmail}\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"email\",\n  \"email\": \"{userEmail}\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a magic link via email**\n\nYou need to specify `send: link`.\n\n*   [cURL](#c36dd90867684513b1ec399f2132e12f_shell)\n*   [C#](#c36dd90867684513b1ec399f2132e12f_csharp)\n*   [Go](#c36dd90867684513b1ec399f2132e12f_go)\n*   [Java](#c36dd90867684513b1ec399f2132e12f_java)\n*   [Node.JS](#c36dd90867684513b1ec399f2132e12f_node)\n*   [Obj-C](#c36dd90867684513b1ec399f2132e12f_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"email\", \"email\": \"{userEmail}\",\"send\": \"link\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'email',\n    email: '{userEmail}',\n    send: 'link'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"email\",\n                              @\"email\": @\"{userEmail}\",\n                              @\"send\": @\"link\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"email\\\", \\\"email\\\": \\\"{userEmail}\\\",\\\"send\\\": \\\"link\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"email\",\n  \"email\": \"{userEmail}\",\n  \"send\": \"link\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Send a one-time-use password via SMS**\n\n*   [cURL](#37cf737d20734c27bf0b4c6ec73c32a0_shell)\n*   [C#](#37cf737d20734c27bf0b4c6ec73c32a0_csharp)\n*   [Go](#37cf737d20734c27bf0b4c6ec73c32a0_go)\n*   [Java](#37cf737d20734c27bf0b4c6ec73c32a0_java)\n*   [Node.JS](#37cf737d20734c27bf0b4c6ec73c32a0_node)\n*   [Obj-C](#37cf737d20734c27bf0b4c6ec73c32a0_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"connection\": \"sms\", \"phone_number\": \"{userPhoneNumber}\",\"send\": \"code\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/passwordless/start\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/passwordless/start\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/passwordless/start\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/passwordless/start',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    connection: 'sms',\n    phone_number: '{userPhoneNumber}',\n    send: 'code'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"connection\": @\"sms\",\n                              @\"phone_number\": @\"{userPhoneNumber}\",\n                              @\"send\": @\"code\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/passwordless/start\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/passwordless/start\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/passwordless/start\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/passwordless/start\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"connection\\\": \\\"sms\\\", \\\"phone_number\\\": \\\"{userPhoneNumber}\\\",\\\"send\\\": \\\"code\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"connection\": \"sms\",\n  \"phone_number\": \"{userPhoneNumber}\",\n  \"send\": \"code\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/passwordless/start\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an SMS user**\n\n*   [cURL](#169673888b234c1ba73be88b2a2e5641_shell)\n*   [C#](#169673888b234c1ba73be88b2a2e5641_csharp)\n*   [Go](#169673888b234c1ba73be88b2a2e5641_go)\n*   [Java](#169673888b234c1ba73be88b2a2e5641_java)\n*   [Node.JS](#169673888b234c1ba73be88b2a2e5641_node)\n*   [Obj-C](#169673888b234c1ba73be88b2a2e5641_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"username\": \"USER_PHONE_NUMBER\", \"otp\": \"code\", \"realm\": \"sms\", \"audience\": \"your-api-audience\",\"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    username: 'USER_PHONE_NUMBER',\n    otp: 'code',\n    realm: 'sms',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"YOUR_CLIENT_SECRET\",\n                              @\"username\": @\"USER_PHONE_NUMBER\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"sms\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"YOUR_CLIENT_SECRET\\\", \\\"username\\\": \\\"USER_PHONE_NUMBER\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"sms\\\", \\\"audience\\\": \\\"your-api-audience\\\",\\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"username\": \"USER_PHONE_NUMBER\",\n  \"otp\": \"code\",\n  \"realm\": \"sms\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate an Email user**\n\n*   [cURL](#29e5b9edd5ea424c9f94653526147838_shell)\n*   [C#](#29e5b9edd5ea424c9f94653526147838_csharp)\n*   [Go](#29e5b9edd5ea424c9f94653526147838_go)\n*   [Java](#29e5b9edd5ea424c9f94653526147838_java)\n*   [Node.JS](#29e5b9edd5ea424c9f94653526147838_node)\n*   [Obj-C](#29e5b9edd5ea424c9f94653526147838_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"username\": \"{userPhoneNumber}\", \"otp\": \"code\", \"realm\": \"email\", \"audience\": \"your-api-audience\", \"scope\": \"openid profile email\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/json'},\n  data: {\n    grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    username: '{userPhoneNumber}',\n    otp: 'code',\n    realm: 'email',\n    audience: 'your-api-audience',\n    scope: 'openid profile email'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"grant_type\": @\"http://auth0.com/oauth/grant-type/passwordless/otp\",\n                              @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"username\": @\"{userPhoneNumber}\",\n                              @\"otp\": @\"code\",\n                              @\"realm\": @\"email\",\n                              @\"audience\": @\"your-api-audience\",\n                              @\"scope\": @\"openid profile email\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"grant_type\\\": \\\"http://auth0.com/oauth/grant-type/passwordless/otp\\\", \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"username\\\": \\\"{userPhoneNumber}\\\", \\\"otp\\\": \\\"code\\\", \\\"realm\\\": \\\"email\\\", \\\"audience\\\": \\\"your-api-audience\\\", \\\"scope\\\": \\\"openid profile email\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"grant_type\": \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"username\": \"{userPhoneNumber}\",\n  \"otp\": \"code\",\n  \"realm\": \"email\",\n  \"audience\": \"your-api-audience\",\n  \"scope\": \"openid profile email\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n**Authenticate a user through a magic link**\n\nWhen you send a magic link, you don't need to call an API to authenticate the user. Users will click the link and be redirected to the callback URL.\n\nThe `/passwordless/start` endpoint has a [rate limit](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) of 50 requests per hour per IP. If you call the API from the server-side, your backend's IP may easily hit these rate limits. To learn how to address this issue, read the Rate Limiting in Passwordless Endpoints section of [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints).",
    "title": "Embedded Passwordless Login in Regular Web Applications",
    "description": "Describes implementing Passwordless authentication with embedded login in regular applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens",
    "markdown": "# Access Tokens with OIDC\n\nBecause applications and APIs (resources) are defined as separate Auth0 entities with the OIDC-conformant pipeline, you can get access tokens for your APIs. Consequently, all APIs should be secured with access tokens instead of ID tokens. To learn more, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens) and [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens).\n\n## Claims\n\nThe OIDC-conformant pipeline standardizes claims that you can add to ID and access tokens.\n\n### Standard claims\n\nThe OIDC specification defines a [](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims)set of standard claims about users, such as profile and email, that can be returned in ID tokens or in the response from the `/userinfo` endpoint.\n\nTo learn about the OIDC standard claim specification, read [Section 5.1 Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) in the [OpenID Specification](https://openid.net/).\n\n### Custom claims\n\nWith the OIDC-conformant pipeline, custom claims may still be added to ID tokens or access tokens, but they must conform to a namespaced format to avoid possible collisions with standard OIDC claims.\n\nTo learn how to add a custom claim in the OIDC-conformant pipeline, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Scopes\n\nIn the OIDC-conformant pipeline, you can configure your applications in Auth0 to use scopes to request that:\n\n*   Standard OIDC claims, such as `profile` and `email`, be included in the ID token (if the user consents to provide this information to the application).\n    \n*   Permissions supported by the API they want to access be included in the access token. For example, you can define your custom API's audience and required scopes, which will allow you to segregate access to different operations within your API.\n    \n\nTo learn more, read [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes).\n\n## Learn more\n\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
    "title": "Access Tokens with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects the tokens used to secure APIs, including scopes and claims.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis",
    "markdown": "# External APIs with OIDC\n\nWith the OIDC-conformant pipeline, you should define applications and APIs (resources) as separate Auth0 entities. Benefits include:\n\n*   Simpler API integration: APIs are no longer tied to applications that call them.\n    \n*   [Machine-to-machine (M2M)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) integration scenarios: Applications can authenticate as themselves (instead of acting on behalf of a user) to programmatically and securely get an Access Token.\n    \n\n## Architecture\n\nSuggested OIDC-conformant solutions for different scenarios include: \n\n*   **Multiple applications calling an API under a single client ID**: Represent each application with a single Auth0 application, each of which can interact with the API on which the applications depend.\n    \n*   **Exchange tokens obtained by one application for tokens for a different application with delegation**: Use a multi-application solution, with each application authenticating to the same resource server.\n    \n*   **Applications do not depend on external APIs; only used to authenticate users**: You do not need to define an API as long as ID tokens are:\n    \n    *   Processed only by the application.\n        \n    *   Not sent to any external services.\n        \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
    "title": "External APIs with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects your use of external APIs and the tokens used to secure them.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow",
    "markdown": "# Client Credentials Flow with OIDC\n\nThe OIDC-conformant pipeline enables the use of the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow), which allows applications to authenticate as themselves (rather than on behalf of a user) to programmatically and securely obtain access to an API.\n\nThis exchange does not exist in the legacy pipeline; instead, the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) is used to simulate it by creating a **service user**. We strongly discourage this approach in favor of using the Client Credentials Flow, which allows fine-grained permissions to be defined for each API app.\n\nTo learn how to execute a Client Credentials Flow, read [Call API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Resource Owner Password Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow)",
    "title": "Client Credentials Flow with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects the Client Credentials Flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow",
    "markdown": "# Authorization Code Flow with OIDC\n\nThe [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) is used by server-side applications that are capable of securely storing secrets, or by native applications through [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\nThe OIDC-conformant pipeline affects the Authorization Code Flow in the following areas:\n\n*   Authentication request\n    \n*   Authentication response\n    \n*   Code exchange request\n    \n*   Code exchange response\n    \n*   ID token structure\n    \n*   Access token structure\n    \n\n## Authentication request\n\n### Legacy\n\n```\nGET /authorize?\n    response_type=code\n    &scope=openid email favorite_color offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com/callback\n    &device=my-device-name\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope. To learn more, read, [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n### OIDC-conformant\n\n```\nGET /authorize?\n    response_type=code\n    &scope=openid email offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com/callback\n    &audience=https://api.example.com\n```\n\n*   `favorite_color` is no longer a valid scope value.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\n## Authentication response\n\nThe response from Auth0 is identical in both pipelines:\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/callback?\n    code=SplxlOBeZQQYbYS6WxSbIA\n    &state=af0ifjsldkj\n```\n\nAn authorization code can be exchanged in the same way in both pipelines:\n\n*   [cURL](#e9233abc9e9f4c4386baf7d018642d2a_shell)\n*   [C#](#e9233abc9e9f4c4386baf7d018642d2a_csharp)\n*   [Go](#e9233abc9e9f4c4386baf7d018642d2a_go)\n*   [Java](#e9233abc9e9f4c4386baf7d018642d2a_java)\n*   [Node.JS](#e9233abc9e9f4c4386baf7d018642d2a_node)\n*   [Obj-C](#e9233abc9e9f4c4386baf7d018642d2a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data code=YOUR_AUTHORIZATION_CODE \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    code: 'YOUR_AUTHORIZATION_CODE',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=YOUR_AUTHORIZATION_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=YOUR_AUTHORIZATION_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Code exchange request - Authorization Code flow with PKCE\n\nAn authorization code can be exchanged in the same way in both pipelines:\n\n*   [cURL](#6d9680d01c95404e9da638a6e11f91b6_shell)\n*   [C#](#6d9680d01c95404e9da638a6e11f91b6_csharp)\n*   [Go](#6d9680d01c95404e9da638a6e11f91b6_go)\n*   [Java](#6d9680d01c95404e9da638a6e11f91b6_java)\n*   [Node.JS](#6d9680d01c95404e9da638a6e11f91b6_node)\n*   [Obj-C](#6d9680d01c95404e9da638a6e11f91b6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data code_verifier=YOUR_GENERATED_CODE_VERIFIER \\\n  --data code=YOUR_AUTHORIZATION_CODE \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code_verifier: 'YOUR_GENERATED_CODE_VERIFIER',\n    code: 'YOUR_AUTHORIZATION_CODE',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code_verifier=YOUR_GENERATED_CODE_VERIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=YOUR_AUTHORIZATION_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code_verifier=YOUR_GENERATED_CODE_VERIFIER\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=YOUR_AUTHORIZATION_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Code exchange response\n\n### Legacy\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"SlAV32hkKG\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned Access Token is only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A refresh token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"eyJ...\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is valid for optionally calling the API specified in the `audience` parameter and the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API uses `RS256` as the [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms) and `openid` is used as a `scope` parameter). If you are not implementing your own Resource Server (API), then you can use `https://{$account.namespace}/userinfo` as the `audience` parameter, which will return an opaque Access Token.\n    \n*   A refresh token will be returned only if the `offline_access` scope was granted.\n    \n\n## ID token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\"\n}\n```\n\nThe `favorite_color` claim must be added through an Auth0 Action. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Access token structure (optional)\n\n### Legacy\n\nThe returned access token is opaque and only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\nThe returned access token is valid for optionally calling the API specified in the `audience` parameter and the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API uses `RS256` as the signing algorithm and `openid` is used as a `scope` parameter).\n\nIf you are not implementing your own resource server (API), then you can use `https://{$account.namespace}/userinfo` as the `audience` parameter, which will return an opaque access token.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Resource Owner Password Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow)",
    "title": "Authorization Code Flow with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects the Authorization Code Flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation",
    "markdown": "# Delegation with OIDC\n\nTraditionally, delegation is used to:\n\n*   Exchange an ID token issued to one application for a new one issued to a different application.\n    \n*   Get a fresh ID token using a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n    \n*   Exchange an ID token for a third-party (e.g., Firebase, AWS) API token.\n    \n\nBecause the OIDC-conformant pipeline requires that ID tokens no longer be used to secure APIs and refresh tokens be used only at the [`/oauth/token`](https://auth0.com/docs/api/authentication#refresh-token) endpoint; the [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint is deprecated.\n\nOIDC-conformant applications cannot be the source or target of delegation requests.\n\n## Third-party APIs\n\nBecause no OIDC-compliant mechanism exists to get third-party (e.g., Firebase, AWS) API tokens, delegation can still be used to obtain third-party API tokens.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)\n*   [Single Sign-On with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso)",
    "title": "Delegation with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects your use of delegation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow",
    "markdown": "# Implicit Flow with OIDC\n\nTraditionally, the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) was used by applications that were incapable of securely storing secrets. Using this flow is no longer considered a best practice for requesting access tokens; new implementations should use [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). However, when used with Form Post response mode, Implicit Flow does offer a streamlined workflow if the application needs only an ID token to perform user authentication; in these cases, it would be used as part of the [Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow).\n\nRefresh tokens will no longer be returned when using the Implicit Flow for authentication.\n\nIn addition, the OIDC-conformant pipeline affects the Implicit Flow in the following areas: authentication request, authentication response, ID token structure, and access token structure.\n\n## Authentication request\n\n### Legacy\n\n```\nGET /authorize?\n    response_type=token\n    &scope=openid email favorite_color offline_access\n    &client_id=123\n    &state=af0ifjsldkj\n    &redirect_uri=https://app.example.com\n    &device=my-device-name\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope. To learn more, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n### OIDC-conformant\n\n```\nGET /authorize?\n    response_type=token id_token\n    &scope=openid email\n    &client_id=123\n    &state=af0ifjsldkj\n    &nonce=jxdlsjfi0fa\n    &redirect_uri=https://app.example.com\n    &audience=https://api.example.com\n```\n\n*   `response_type` indicates that we want to receive both an access token and ID token.\n    \n*   Refresh tokens are not allowed in the implicit grant. Use `prompt=none` instead. To learn more read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n    \n*   `favorite_color` is no longer a valid scope.\n    \n*   `audience` is optional.\n    \n*   `nonce` must be a cryptographically secure random string. To learn more, read [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n    \n\n## Authentication response\n\n### Legacy\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/#\n    access_token=SlAV32hkKG\n    &expires_in=86400\n    &state=af0ifjsldk\n    &id_token=eyJ...\n    &refresh_token=8xLOxBtZp8\n    &token_type=Bearer\n```\n\n*   The returned access token is valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A refresh token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 302 Found\nLocation: https://app.example.com/#\n    access_token=eyJ...\n    &expires_in=86400\n    &state=af0ifjsldk\n    &id_token=eyJ...\n    &token_type=Bearer\n```\n\n*   The returned access token is valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms)) and optionally the resource server specified by the `audience` parameter.\n    \n*   If using `response_type=id_token`, Auth0 will only return an ID token. Refresh Tokens are not allowed in the implicit grant. Use `prompt=none` instead.\n    \n\n## ID token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\",\n    \"nonce\": \"jxdlsjfi0fa\"\n}\n```\n\n*   The `favorite_color` claim must be namespaced and added through a rule. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n*   After validating the ID token, the application must validate the nonce to mitigate replay attacks.\n    \n\n## Access token structure (optional)\n\n### Legacy\n\nThe returned Access Token is opaque and only valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoint[](https://auth0.com/docs/api/authentication#get-user-info).\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\n*   The returned access token is a JWT valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoint[](https://auth0.com/docs/api/authentication#get-user-info) (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms)) as well as the resource server specified by the `audience` parameter.\n    \n*   An opaque access token could still be returned if `/userinfo` is the only specified audience.\n    \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
    "title": "Implicit Flow with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects the Implicit Flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens",
    "markdown": "# Refresh Tokens with OIDC\n\nWith the OIDC-conformant pipeline, refresh tokens:\n\n*   Will no longer be returned when using the [implicit grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) for authentication.\n    \n*   Can be used by [confidential applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   Can be used with [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) by public applications when using the Authorization Code Flow with PKCE.\n    \n*   Should use the [`/oauth/token`](https://auth0.com/docs/api/authentication#refresh-token) endpoint to get new tokens because the [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint is deprecated.\n    \n\nIn addition, differences exist in the refresh token structure. To learn more, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Legacy (delegation)\n\n```\nPOST /delegation\nContent-Type: 'application/json'\n{\n  \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n  \"client_id\": \"...\",\n  \"refresh_token\": \"...\",\n  \"scope\": \"openid profile\"\n}\n```\n\nWas this helpful?\n\n/\n\n## OIDC-conformant (token endpoint)\n\n```\nPOST /oauth/token\nContent-Type: application/x-www-form-urlencoded\ngrant_type=refresh_token&refresh_token=123&client_id=123&client_secret=123&scope=openid+profile&audience=https%3A%2F%2Fapi.example.com\n```\n\nWas this helpful?\n\n/\n\n*   `audience` and `client_secret` parameters are optional.\n    \n*   `client_secret` is not needed when requesting a `refresh_token` for a public application.\n    \n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)",
    "title": "Refresh Tokens with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects your use of refresh tokens.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-akamai-for-use-as-reverse-proxy",
    "markdown": "# Configure Akamai as Reverse Proxy\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nTo set up an Akamai product as a reverse proxy, complete the following:\n\n1.  Verify the ownership of your custom domain. To learn more, read [Verify Ownership](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates#verify-ownership).\n    \n2.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) to gather the distribution, origin custom header, origin hostname, and default cache behavior settings. Then, use this information to update your Akamai custom domain settings to point to the reverse proxy server domain. To learn more, read [Configure reserve proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates#configure-reverse-proxy).\n    \n3.  Update the custom domain client IP header using the Management API PATCH  `/api/v2/custom-domains/{id}` endpoint as below:\n    \n    ```\n    { \n    \"custom_client_ip_header\": \"true-client-ip\" \n    }\n    ```\n    \n    To learn more, read [Update custom domain configuration](https://auth0.com/docs/api/management/v2#!/Custom_Domains/patch_custom_domains_by_id).\n\nFor details on how to configure Akamai as a reverse proxy using the information above, refer to Akamai documentation or customer support.\n\n## Learn more\n\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
    "title": "Configure Akamai as Reverse Proxy",
    "description": "Learn how to set up Akamai for use as the custom domain proxy for Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow",
    "markdown": "# Resource Owner Password Flow with OIDC\n\nThe [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) is used by highly-trusted applications to provide active authentication. Unlike the authorization code and implicit grants, this authentication mechanism does not redirect users to Auth0. It authenticates users with a single request, exchanging their password credentials for a token.\n\nThe OIDC-conformant pipeline affects the Resource Owner Password Flow in the following areas:\n\n*   Authentication request\n    \n*   Authentication response\n    \n*   ID token structure\n    \n*   Access token structure\n    \n\n## Authentication request\n\n### Legacy\n\n```\nPOST /oauth/ro HTTP 1.1\nContent-Type: application/json\n{\n  \"grant_type\": \"password\",\n  \"client_id\": \"123\",\n  \"username\": \"alice\",\n  \"password\": \"A3ddj3w\",\n  \"connection\": \"my-database-connection\",\n  \"scope\": \"openid email favorite_color offline_access\",\n  \"device\": \"my-device-name\"\n}\n```\n\nThe `device` parameter is only needed if requesting a refresh token by passing the `offline_access` scope.\n\n### OIDC-conformant\n\n```\nPOST /oauth/token HTTP 1.1\nContent-Type: application/x-www-form-urlencoded\ngrant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fpassword-realm&client_id=123&username=alice&password=A3ddj3w&realm=my-database-connection&scope=openid+email+offline_access&audience=https%3A%2F%2Fapi.example.com\n```\n\n*   The endpoint to execute credential exchanges is `/oauth/token`.\n    \n*   Auth0's own grant type is used to authenticate users from a specific connection (`realm`). The standard OIDC password grant is also supported, but it does not accept Auth0-specific parameters such as `realm`.\n    \n*   `favorite_color` is no longer a valid scope.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\n## Authentication response\n\n### Legacy\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"SlAV32hkKG\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is only valid for calling the [`/userinfo`](https://auth0.com/docs/api/authentication#get-user-info) endpoint.\n    \n*   A Refresh Token will be returned only if a `device` parameter was passed and the `offline_access` scope was requested.\n    \n\n### OIDC-conformant\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\nPragma: no-cache\n{\n    \"access_token\": \"eyJ...\",\n    \"token_type\": \"Bearer\",\n    \"refresh_token\": \"8xLOxBtZp8\",\n    \"expires_in\": 3600,\n    \"id_token\": \"eyJ...\"\n}\n```\n\n*   The returned access token is valid for calling the `/userinfo` endpoint (provided that the API specified by the `audience` param uses `RS256` as [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms)) and optionally the resource server specified by the `audience` parameter.\n    \n*   The ID token will be forcibly signed using `RS256` if requested by a public application. To learn more, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   A refresh token will be returned only if the `offline_access` scope was granted.\n    \n\n## ID Token structure\n\n### Legacy\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"favorite_color\": \"blue\"\n}\n```\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": \"123\",\n    \"exp\": 1482809609,\n    \"iat\": 1482773609,\n    \"email\": \"alice@example.com\",\n    \"email_verified\": true,\n    \"https://app.example.com/favorite_color\": \"blue\"\n}\n```\n\n*   The ID token will be forcibly signed using `RS256` if requested by a public application.\n    \n*   The `favorite_color` claim must be namespaced and added through a rule. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n\n## Access Token structure (optional)\n\n### Legacy\n\nThe returned Access token is opaque and only valid for calling the `/userinfo` endpoint.\n\n### OIDC-conformant\n\n```\n{\n    \"sub\": \"auth0|alice\",\n    \"iss\": \"https://{yourDomain}/\",\n    \"aud\": [\n        \"https://api.example.com\",\n        \"https://{yourDomain}/userinfo\"\n    ],\n    \"azp\": \"123\",\n    \"exp\": 1482816809,\n    \"iat\": 1482809609,\n    \"scope\": \"openid email\"\n}\n```\n\n*   The returned access token is a JWT valid for calling the [](https://auth0.com/docs/api/authentication#get-user-info)`/userinfo` endpoin (provided that the API specified by the `audience` parameter uses `RS256` as signing algorithm) as well as the resource server specified by the `audience` parameter.\n    \n*   Note that an opaque access token could still be returned if `/userinfo` is the only specified audience.\n    \n\n## Standard password grant requests\n\nThe Auth0 password realm grant is not defined by standard OIDC, but it is suggested as an alternative to the legacy resource owner endpoint because it supports the Auth0-specific `realm` parameter. The [standard OIDC flow is also supported](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) when using OIDC authentication.\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
    "title": "Resource Owner Password Flow with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects the Resource Owner Password (ROP) Flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso",
    "markdown": "# Single Sign-On with OIDC\n\nIn the context of the OIDC-conformant authentication pipeline, [](https://auth0.com/docs/authenticate/single-sign-on)single sign-on (SSO) must happen at the authorization server (i.e., Auth0) rather than the application, which means that you must employ Universal Login and redirect users to the login page. To learn more, read [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on).\n\nAt a general level, when performing SSO:\n\n1.  If the user is not logged in locally, you should redirect them to your Auth0 login page (`/authorize`) for authentication using a redirect-based flow, such as the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) or [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), depending on the type of application.\n    \n2.  If the user was already logged in through SSO, Auth0 will immediately authenticate them without needing to re-enter credentials.\n    \n\nTo determine whether users are logged in via SSO, use silent authentication, which either re-authenticates a user if they are already logged in or returns an error if they need to authenticate. In the legacy authentication pipeline, this could be achieved by using the `/ssodata` endpoint, which is deprecated in the OIDC-conformant pipeline. To learn more about how to configure silent authentication, read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n\n## Learn more\n\n*   [Access Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens)\n*   [External APIs with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis)\n*   [Authorization Code Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow)\n*   [Client Credentials Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow)\n*   [Delegation with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation)\n*   [Refresh Tokens with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens)",
    "title": "Single Sign-On with OIDC",
    "description": "Learn how the OIDC-conformant pipeline affects your use of Single Sign-On (SSO).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/custom-domains/get-custom-domains",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections",
    "markdown": "# Configure ADFS as SAML Identity Provider\n\nCreate a custom SAML connection to Microsoft's Active Directory Federation Services (ADFS) to get more flexibility when configuring your mappings. To create the custom connection, you will need to:\n\n1.  Configure ADFS.\n    \n2.  Create a SAML connection where Auth0 acts as the service provider.\n    \n3.  Edit the Relying Party Trust in ADFS.\n    \n4.  Enable and test your integration.\n    \n\n## Configure ADFS\n\n### Add Relying Party Trust\n\nTo learn how to add a relying party trust, read [Create a relying party trust](https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust) at [https://docs.microsoft.com](https://docs.microsoft.com/).\n\n#### Create using federation metadata\n\nFollow the steps on [Create a claims aware Relying Party Trust using federation metadata (MSDN)](https://docs.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust#to-create-a-claims-aware-relying-party-trust-using-federation-metadata). For the **Federation metadata address** in Step 4, the URL you enter should be in one of these formats:\n\nUS: `https://{yourTenantName}.auth0.com/samlp/metadata?connection={connectionName}`\n\nEU: `https://{yourTenantName}.eu.auth0.com/samlp/metadata?connection={connectionName}`\n\nAU: `https://{yourTenantName}.au.auth0.com/samlp/metadata?connection={connectionName}`\n\nJP: `https://{yourTenantName}.jp.auth0.com/samlp/metadata?connection=CONNECTION_NAME`\n\nCustom domain: `https://{yourTenantName}/samlp/metadata?connection={connectionName}`\n\nOnce you've finished creating the relying party trust, [continue to the next section](#edit-claim-issuance-policy).\n\n#### Create manually\n\n1.  Launch your instance of ADFS and start the **Add Relying Party Trust** wizard.\n    \n2.  On the **Welcome** page, choose **Claims aware** and click **Start**.\n    \n3.  On the **Select Data Source** page, select **Enter data about the relying party manually** and click **Next**.\n    \n4.  On the **Specify Display Name** page, provide a descriptive name for your relying party (the typical format is `urn:auth0:{yourTenant}:{yourConnectionName}`) and a brief description under **Notes**. Be sure to replace `{yourConnectionName}` with a unique name you will also use to create a connection in Auth0 in a later step. If you are unsure of the connection name at this time, you can always edit the connection name later. Click **Next**.\n    \n5.  On the **Configure Certificate** page, click **Next**. (We will come back to configure the certificate later.)\n    \n6.  On the **Configure URL** page, check the box for **Enable support for the SAML 2.0 WebSSO protocol**. The wizard then asks for a **Relying party SAML 2.0 SSO service URL**. For the time being, provide a placeholder URL; we will return to this step later. Click **Next**.\n    \n7.  On the **Configure Identifiers** page, indicate that the **Relying party trust identifier** is `urn:auth0:{yourTenant}:{yourConnectionName}` (or whatever value you used as the display name when you started using the wizard). Click **Next**.\n    \n8.  On the **Choose Access Control Policy** page, select **Permit everyone** and click **Next**.\n    \n9.  Review the settings you provided on the **Ready to Add Trust** page and click **Next** to save your information. If you were successful, you'll see a message indicating that on the **Finish** page.\n    \n10.  Make sure that the **Configure claims issuance policy for this application** checkbox is selected, and click **Close**.\n    \n\n### Edit Claim Issuance Policy\n\nAfter you close the **Add Relying Party Trust** wizard, the **Edit Claim Issuance Policy** window appears.\n\n1.  Click **Add Rule...** to launch the wizard.\n    \n2.  Select **Send LDAP Attributes as Claims** for your **Claim rule template**, and click **Next**.\n    \n3.  Provide a value for the **Claim rule name**, such as \"LDAP Attributes\" (it can be anything you want).\n    \n4.  Choose **Active Directory** as your **Attribute Store**.\n    \n5.  Map your LDAP attributes to the following outgoing claim types:\n    \n    | LDAP Attribute | Outgoing Claim |\n    | --- | --- |\n    | E-Mail-Addresses | E-Mail Address |\n    | Display-Name | Name |\n    | User-Principal-Name | Name ID |\n    | Given-Name | Given Name |\n    | Surname | Surname |\n    \n    The `Name ID` outgoing claim should always be present to ensure correct session handling. We strongly recommend adding all of the claims listed above, especially `E-Mail Address`, since they are the ones most commonly used. You can add additional claim mappings if necessary.\n    \n6.  Click **Finish**.\n    \n7.  In the **Edit Claim Issuance Policy** window, click **Apply**. You can now exit out of this window.\n    \n\n### Export Signing Certificate\n\nFinally, you'll need to export the signing certificate from the ADFS console to upload it to Auth0.\n\n1.  Using the left-hand navigation pane, go to **ADFS > Service > Certificates**. Select the **Token-signing** certificate, and right click to select **View Certificate**.\n    \n2.  On the **Details** tab, click **Copy to File...**. This launches the **Certificate Export Wizard**. Click **Next**.\n    \n3.  Choose **Base-64 encoded X.509 (.CER)** as the format you'd like to use. Click **Next**.\n    \n4.  Provide the location to where you want the certificate exported. Click **Next**.\n    \n5.  Verify that the settings for your certificate are correct and click **Finish**.\n    \n\n## Create SAML connection with Auth0 as service provider\n\n1.  Follow the tutorial on creating a SAML connection where [Auth0 acts as the service provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider). Where prompted, upload the signing certificate you exported from ADFS.\n    \n    The sign in and sign out URLs are usually in the form of `https://your.adfs.server/adfs/ls`.\n    \n2.  Click **Save**. A page with instructions for creating a new Relying Party Trust in ADFS appears displaying the exact values required for your Auth0 account/connection. Make a note of these values. Here is an example:\n    \n    | Parameter | Example Value |\n    | --- | --- |\n    | Post-back URL | `https://<YOUR CUSTOM DOMAIN>/login/callback?connection=YOUR_CONNECTION_NAME` if a custom domain is configured |\n    |     | `https://{yourDomain}/login/callback?connection=YOUR_CONNECTION_NAME` if not using custom domains |\n    | Entity ID | `urn:auth0:{yourTenant}:YOUR_CONNECTION_NAME` |\n    \n\n## Edit Relying Party Trust\n\n1.  In the ADFS console, go to **ADFS > Relying Party Trusts** using the left-hand navigation pane. Select the Relying Party Trust you created earlier and click **Properties** (located on the right-hand navigation pane).\n    \n2.  Select the **Identifiers** tab, and populate the **Relying Party Identifier** with the **Entity ID** value from the previous screen. Be sure to click **Add** to add the identifier to your list.\n    \n3.  Select the **Endpoints** tab, and select the placeholder URL you provided earlier. Click **Edit...**.\n    \n4.  Populate the **Trusted URL** with the **Post-back URL** value.\n    \n5.  Click **OK**. Finally, click **Apply** and exit the Properties window.\n    \n\n## Enable sign requests (optional)\n\nOptionally, you can sign your SAML requests to the ADFS server.\n\n1.  Go to the **Settings** page for your SAML-P Identity Provider in the Auth0 Dashboard.\n    \n2.  Enable **Sign Requests**.\n    \n3.  Just below the **Sign Requests** toggle is a link to download your certificate.\n    \n4.  Return to ADFS and load the downloaded certificate using the **Signatures** tab of the Relying Party properties dialog.\n    \n\n## Enable and test the integration\n\nBefore you test your integration, make sure that you've completed the following steps:\n\n*   Create a user on the identity provider that you can use to test your new connection.\n    \n*   Enable your Connection for at least one application.\n    \n\n1.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Select the connection that you want to test and click the ellipses (...) then click **Try**. The Microsoft Sign in screen will appear. Sign in and click **Next**.\n    \n\n## Learn more\n\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
    "title": "Configure ADFS as SAML Identity Provider",
    "description": "Learn how to configure a SAML connection against ADFS in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider",
    "markdown": "# Configure Okta as SAML Identity Provider\n\nYou can configure Okta as a SAML identity provider (IdP) in Auth0 by configuring a SAML Enterprise connection.\n\n## Configure Okta SAML app integration\n\nYou can create a SAML app integration in the Okta Developer Console.\n\n### Create app integration\n\n1.  Log in to the [Okta Developer Console](https://login.okta.com/).\n    \n2.  Go to **Create App Integration** and choose **SAML 2.0** from the options.\n    \n3.  Configure the following settings:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Single Sign-On URL | Auth0 tenant login callback URL. | `https://{yourAuth0Domain}/login/callback?connection={yourAuth0ConnectionName}` |\n    | Audience URI (SP Entity ID) | Auth0 connection audience value. | `urn:auth0:{yourAuth0TenantName}:{yourAuth0ConnectionName}` |\n    \n4.  Select **Next**, and then select **Finish** to complete the Okta app integration configuration.\n    \n\n### Record SSO URL and download certificate\n\nThe login flow is now directed to the **Sign On** page for the newly-created app.\n\n1.  Select **View SAML Setup Instructions**.\n    \n2.  Record the **Identity Provider Single Sign-On URL**.\n    \n3.  Download the **X.509 Certificate** in PEM or CER format.\n    \n4.  Navigate to **Assignments**, and then assign a user to the Okta application.\n    \n\n## Configure SAML connection in Auth0\n\nYou can create a SAML Enterprise connection in the Auth0 Dashboard.\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n3.  Select **Create** (**+** button) next to **SAML**.\n    \n4.  Configure the following settings:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Connection name | Auth0 connection name. | `myoktaconnection` |\n    | Sign In URL | Okta URL where user login requests are sent.<br><br>This is the **Identity Provider Single Sign-On URL** value you recorded previously. | `https://my_okta_tenant_name.okta.com/app/` `my_okta_tenant_namemy_okta_saml_app_integration_name/` `dakflkbzevu5i5zBi939/sso/saml` |\n    | X509 Signing Certificate | Okta tenant public key signing certificate.<br><br>Upload the **X509 Certificate** you downloaded previously. | `myOktaTenantSigningCertificate.pem` |\n    \n5.  Select **Create**.\n    \n\n## Enable SAML Enterprise connection in Auth0\n\nYou can enable your SAML Enterprise connection in the Auth0 Dashboard.\n\n### Enable SAML Enterprise connection when using Organizations\n\nIf you’re using Organizations:\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Organizations](https://manage.auth0.com/#/organizations), and select your Organization.\n    \n3.  Switch to the **Connections** view.\n    \n4.  Select **Enable Connections**.\n    \n5.  Select the SAML connection you created previously, and then select **Enable Connection**.\n    \n\n### Enable SAML Enterprise connection when not using Organizations\n\nIf you’re not using Organizations:\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp), and select the SAML connection you created previously.\n    \n3.  Switch to the **Applications** view, and enable the connection for your chosen application(s).\n    \n\n## Test connection\n\nYou can test your connection in the Auth0 Dashboard.\n\n1.  Log in to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n3.  Locate your connection in the list.\n    \n4.  Select **More Actions** (**...** button), and then select **Try**.\n    \n    *   If your connection is configured correctly, you'll see the **It works!** screen.\n        \n    *   If not, you’ll see an error message with details about what went wrong.",
    "title": "Configure Okta as SAML Identity Provider",
    "description": "Learn how to configure Okta as an SAML identity provider (IdP) in Auth0. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider",
    "markdown": "# Configure OneLogin as SAML Identity Provider\n\nConfigure OneLogin as a SAML identity provider by completing the following steps:\n\n1.  Configure OneLogin SAML integration\n    \n2.  Configure SAML connection in Auth0.\n    \n3.  Test connection.\n    \n\n## Prerequisite\n\nYou must have OneLogin developer account.\n\n## Configure OneLogin\n\n1.  Log in to the [OneLogin](https://www.onelogin.com/) Dashboard, and click **Apps** > **Add Apps**.\n    \n2.  Search for **SAML**, and select **SAML Test Connector (IdP w/attr)**.\n    \n3.  When prompted, change the **Display Name** of your app.\n    \n4.  Click **SAVE**.\n    \n5.  Go to the **SSO** tab, and copy the values for **SAML 2.0 Endpoint (HTTP)** and **SLO Endpoint (HTTP)**.\n    \n6.  Click on the **View Details** link at the **X.509 Certificate** field.\n    \n7.  Download the X.509 certificate **onelogin.pem**.\n    \n\n## Configure Auth0 connection\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#) and click the **plus** icon to be redirected to the page that allows you to create a new Connection.\n    \n2.  You will be prompted to provide the appropriate configuration settings for this Connection. The only mandatory fields are:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Sign In URL** | The SAML 2.0 Endpoint (HTTP) value you noted when setting up your OneLogin app. |\n    | **Sign Out URL** | The SLO Endpoint (HTTP) value you noted when setting up your OneLogin app. |\n    | **X509 Signing Certificate** | The certificate you downloaded from Onelogin. You will need to upload the certificate directly to Auth0. |\n    \n3.  Click **Save** to proceed.\n    \n4.  In the next window, you'll be provided two options.\n    \n    1.  If you are a domain administrator, you can click **Continue** for additional instructions on SAML Identity Provider Configuration.\n        \n    2.  If you are not, you can give your domain administrator the provided URL so that they can finish the configuration.\n        \n\n### Auth0 configuration values\n\nTo finish configuration of the SAML application, the admin will need the following information regarding Auth0:\n\n*   **SAML Consumer URL**: `https://{yourDomain}/login/callback`\n    \n*   **SAML Audience**: `urn:auth0:{yourTenant}:yourConnectionName`\n    \n\nAlso copy the values of the **post-back URL** and the **Entity ID** before heading back to the Configuration tab of your [OneLogin](https://www.onelogin.com/) app:\n\n| Auth0 value | OneLogin configuration field |\n| --- | --- |\n| Post-back URL | ACS (Consumer) URL and Recipient |\n| Entity ID | Audience |\n\nAlso provide a valid regular expression for the **ACS (Consumer) URL Validator**. For example:\n\n`[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)`\n\n## Test connection\n\nBefore testing your connection:\n\n*   Be sure that you have a OneLogin user that you can use for testing. If not, go to the **Users** tab on the OneLogin dashboard and add one\n    \n*   Be sure that your new Auth0 SAMLP connection has been associated with an application (otherwise you will get an `invalid_request: the connection was disabled` error)\n    \n\nNext to your **SAML** connection, click the **Try** button. If all goes well, you will be redirected to a page informing you that the connection works.\n\n## Identity provider-initiated SSO\n\nOneLogin offers an Application Portal/Launcher to its users. If you want to take advantage of this functionality, you will have to change the **SAML Consumer URL** in OneLogin dashboard to include the `connection` parameter (e.g., `https://{yourDomain}/login/callback?connection=onelogin-customer`). Be sure to replace `onelogin-customer` with the name of your Auth0 connection.\n\nFinally, be sure to enable IdP-initiated login for the connection and pick the application to which your user is redirected after the SAML assertion is consumed. To learn more, read [Configure Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).\n\n## Edit connection mappings\n\nIf you use OneLogin and Auth0 out of the box, users logging in using OneLogin and created in the Auth0 Dashboard will be missing some profile information you might like to have.\n\nTo collect additional user information, edit the appropriate parameters in the OneLogin dashboard, include the parameters in the SAML assertion, and create the mappings in the Auth0 connection.\n\n### User profile attributes\n\nSometimes the standard User Profile Attributes are not enough for the functionality you want to build. If this is the case, you can use custom attributes in order to enhance the SAML token. Let's work through a basic example.\n\nThe SAML token contains, among others, two attributes: `FirstName` and `LastName`. Let's add a new custom attribute, named `FullName`, that will contain the concatenation of first and last name.\n\n1.  Navigate to the OneLogin dashboard and edit your app.\n    \n2.  On the **Parameters** tab, click **Add Parameter**.\n    \n3.  In the pop-up, set a name for your new custom attribute using the **Field name** text box. Make sure you check the **Include in SAML assertion** flag. Click **Save**.\n    \n4.  The new attribute you created is displayed. Click on the **Value** field, which is currently displaying `- No default -`.\n    \n5.  Click the **Value** dropdown menu and select `- Macro -`.\n    \n6.  At the text box, set the value to `{firstname} {lastname}`. Click **Save**.\n    \n7.  Test our changes. Go back to [Auth0 dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise). On your **SAML** connection, click the **Try** button. The result should include the new attribute `FullName`.\n    \n\nYou can find more information on Attribute Macros at the [OneLogin Help Center](https://support.onelogin.com/hc/en-us/articles/201174464-Attribute-macros).\n\n### Add new parameter to SAML assertion\n\nFor the purposes of demonstration, let's see how we can add the `EmailAddress` information, which is more than the concatenation of two fields we're already sending, to our login.\n\n1.  Before you can map users' **EmailAddress**, you must add this field as a custom parameter to the OneLogin dashboard. Set **Field name** to `EmailAddress` and **Value** as `Email`.\n    \n2.  You can find details on the steps needed to customize the user profile in the section above.\n    \n3.  Once you've made your changes, save them, and test your connection once again.\n    \n4.  Review your Auth0 user, making sure that the `EmailAddress` information is now included and that the value is correct.\n    \n\nYou are now ready to proceed with mapping the user information fields in Auth0.\n\n1.  Go to the **Settings** of your [SAML](https://manage.auth0.com/#/connections/enterprise) and navigate to the tab **Mappings**. For the email addresses, copy the mapping below, and paste it into the text box.\n    \n2.  Save your changes, and try your connection again. Once you have successfully logged in, go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users), and check your login. You will see additional information for the appropriate user.",
    "title": "Configure OneLogin as SAML Identity Provider",
    "description": "Learn how to configure OneLogin as a SAML identity provider for use with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider",
    "markdown": "# Configure SiteMinder as SAML Identity Provider\n\nConfigure SiteMinder as a SAML identity provider by completing the following steps.\n\n## Prerequisite\n\nYou must have a [SiteMinder](https://www.siteminder.com/login/) account.\n\n## Configure SiteMinder settings\n\nWhen configuring SiteMinder, you will use the default values for most options. You will also need the following Auth0-related values in the configuration steps below:\n\n*   **EntityID:** `urn:auth0:{yourTenant}`\n    \n*   **Assertion Consumer Service URL:** `https://{yourDomain}/login/callback`\n    \n*   **Logout URL:** `https://{yourDomain}/logout`\n    \n*   **HTTP-Redirect** binding for SAML Request\n    \n*   **HTTP-POST** binding for SAML Response\n    \n\n1.  Log into [SiteMinder](https://www.siteminder.com/login/).\n    \n2.  Open the **SAML Service Provider Dialog**.\n    \n3.  Provide an appropriate name for this service provider.\n    \n4.  Define the `NameIdentifier`. There are many ways of generating this for users authenticating with SiteMinder. Typically you will map this value to one of the user properties in the User Directory as `uid`.\n    \n5.  Configure the service provider general SAML properties:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **SP ID** | `urn:auth0:{yourTenant}` |\n    | **SAML Version** | 2.0 |\n    | **Skew Time:** | 30 seconds |\n    \n6.  Configure the **Assertion Consumer Service URL** which is the location where SiteMinder will POST back the SAML token. This Service Provider ({yourTenant}) only supports the `HTTP-POST` binding for SAML Responses. Use: `https://{yourDomain}/login/callback`\n    \n7.  Check the **HTTP-Post** box.\n    \n8.  Configure additional user properties to send in the token. Add any other properties you wish to share about the authenticated user to this Service Provider. Common values are: `name`, `lastname`, `email address`, and so on. This Service Provider will use the `NameIdentifier` defined previously as a unique handle of the user. These attributes will be treated as reference information.\n    \n9.  Enter the **SLO Location URL:** `https://{yourDomain}/logout`\n    \n10.  (Optional) The service provider supports encryption of assertions. To use this option, do the following to download the Service Provider public key certificate.\n    \n    1.  In the Auth0 Dashboard, click on **Connections** and then **Enterprise.**\n        \n    2.  Click on SAMLP Identity Provider.\n        \n    3.  Click on the setup icon (pencil).\n        \n    4.  In the window which appears, the seventh (last) bullet gives you links to download the .pem or .cer format certificate.\n        \n    5.  Download the desired certificate and add it to the SiteMinder **Policy Server Keystore**.",
    "title": "Configure SiteMinder as SAML Identity Provider",
    "description": "Learn how to configure SiteMinder as a SAML identity provider for use with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider",
    "markdown": "# Configure Salesforce as SAML Identity Provider\n\nConfigure Salesforce as a SAML identity provider by completing the following steps:\n\n1.  Obtain Salesforce certificate and metadata.\n    \n2.  Set up Auth0 as a service provider.\n    \n3.  Configure the Salesforce identity provider (IdP).\n    \n4.  Grant privileges to users in Salesforce.\n    \n5.  Test the connection to the Salesforce IdP.\n    \n\n## Prerequisite\n\nRegister for a [Salesforce.com](http://salesforce.com/) account. You must select one of the account types that include identity provider support.\n\n## Obtain Salesforce certificate and metadata\n\n1.  Log in to your [Salesforce](http://salesforce.com/) account.\n    \n2.  Create your [Salesforce Domain](https://help.salesforce.com/apex/HTViewHelpDoc?id=domain_name_setup.htm&language=en_US).\n    \n3.  Log into your Salesforce domain `https://{yourDomain}.my.salesforce.com` and click on **Setup** on the top right.\n    \n4.  In the Quick Find box, enter Single Sign-On Settings, then select **Single Sign-On Settings**, and then click **Edit**.\n    \n5.  To view the SAML SSO settings, select **SAML Enabled**\n    \n6.  Select the default certificate and click **Save**.\n    \n7.  Click **Download Certificate** to download the identity provider certificate.\n    \n8.  Click **Download Metadata** to download the identity provider metadata.\n    \n\n## Set up Auth0 as a service provider\n\nConfigure Auth0 as a service provider to communicate with the Salesforce identity provider for SSO.\n\n1.  Go to the [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) and click **SAML**.\n    \n2.  Click **Create Connection**.\n    \n3.  In the configuration window, enter the following information:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Connection Name** | Name your connection. For example **SFIDP**. |\n    | **Email Domains** | Enter the email domain name that your users will be loggin in from. For example, if your users have an email domain of `abc-example.com`, enter that into this field. You can enter multiple domains. |\n    | **Sign In URL** | Open the metadata file you downloaded from Salesforce and locate the line that contains the `SingleSignOnService` binding. The value of the `location` attribute on this line is your Sign In URL. It will be something like: `https://{sf-account-name}.my.salesforce.com/idp/endpoint/HttpRedirect` where `{sf-account-name}` is your Salesforce domain name. |\n    | **Sign Out URL** | Enter the same URL you entered for Sign In URL. |\n    \n4.  For the **Certificate**, you convert the certificate downloaded from Salesforce to .pem format with the following command: `openssl x509 -in original.crt -out sfcert.pem -outform PEM` where `original.crt` is the filename of the downloaded .crt file.\n    \n    1.  Click **UPLOAD CERTIFICATE** and select the `.pem` file you just created. (`sfcert.pem` in the example above). You can ignore the rest of the fields for now.\n        \n    2.  Click **SAVE**.\n        \n    3.  Click **CONTINUE**. In the window that appears, SAML metadata for the Auth0 Service Provider will be displayed. Keep this window open since you will need to enter some of this information into Salesforce to finish the configuration.\n        \n\nYou can access the metadata for an Auth0 SAML connection with this URL syntax: `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`.\n\n## Configure Salesforce as an identity provider\n\nConfigure Salesforce with the metadata from Auth0 so it can receive and respond to SAML-based authentication requests from Auth0.\n\n1.  Open [**salesforce.com**](http://salesforce.com/).\n    \n2.  Go to **Setup** > **Manage Apps**. Click **Connected Apps**.\n    \n3.  Create a new Connected App and fill out the following fields:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Entity ID** | `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME` |\n    | **ACS URL** | `https://{yourDomain}/login/callback` |\n    | **Subject Type** | `Persistent ID` |\n    | **Name ID Format** | Choose the one with `emailAddress` |\n    | **Issuer** | `https://{your-saleforce-domain}.my.salesforce.com` |\n    \n4.  Click **Save** to complete the configuration.\n    \n\n## Grant privileges to users in Salesforce\n\n1.  Open [**salesforce.com**](http://salesforce.com/) and click **Setup**.\n    \n2.  Under **Manage Users**, click **Profiles**.\n    \n3.  Scroll down to find the profile called **Standard User** (on page 2).\n    \n4.  Click on **Edit** to edit the profile.\n    \n5.  Scroll down to the **Connected App Access** section.\n    \n6.  Check the box next to the name of your connected app to enable it for this profile.\n    \n7.  Click **Save**.\n    \n8.  Under **Manage Users**, click **Users**.\n    \n9.  Click **Edit** to edit your test user and set the profile to **Standard User**. To use a different Salesforce profile, enable the connected app for that profile and ensure that all users that login through the Salesforce Identity Provider have that profile.\n    \n\n## Test connection to Salesforce\n\n1.  Navigate to the [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise) section of the Auth0 dashboard. Select the **SAMLP Identity Provider**.\n    \n2.  Click the **Try** button for the SAML connection you created earlier. You should be redirected from Auth0 to the Salesforce login page.\n    \n3.  Once you are at the **Salesforce login screen**, login with the credentials you provided when you created the Salesforce account.\n    \n    1.  If the SAML configuration works, your browser will be redirected back to an Auth0 page that says **\"It works!!!\"**. This page will display the contents of the SAML authentication assertion sent by the Salesforce IDP to Auth0.\n        \n    2.  If it didn't work, double check the steps above and consult the **troubleshooting** section below.\n        \n\nWhen troubleshooting SSO, it is often helpful to capture an HTTP trace of the interaction and save it in a HAR file. To learn more, read [Generate and Analyze HAR Files](https://auth0.com/docs/troubleshoot/guides/generate-har-files).\n\nOnce you have an http trace tool, capture the login sequence from start to finish and analyze the trace for the sequence of GETs. You should see a redirect from your original site to the IDP, a post of credentials if you had to log in, and then a redirect back to the callback URL. The HAR file will also contain the SAML response.\n\nMake sure that cookies and JavaScript are enabled for your browser.\n\nMake sure that the user's profile in Salesforce has permission to login via the Salesforce IDP (See section 4 above).",
    "title": "Configure Salesforce as SAML Identity Provider",
    "description": "Describes how to Salesforce as SAML identity provider for use with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions",
    "markdown": "# Customize SAML Assertions\n\n`audience` string Audience of the SAML assertion. Default is issuer on SAMLRequest. `recipient` string Recipient of the SAML assertion (`SubjectConfirmationData`). Default is `AssertionConsumerUrl` on SAMLRequest or callback URL if no SAMLRequest was sent. `issuer` string Unique identifier of the SAML identity provider, formatted as a URL. `mappings` object Mappings between Auth0 profile and the output attributes on the SAML assertion. Default mapping is shown above. `createUpnClaim` boolean Whether or not a UPN claim should be created. Default is `true`. `passthroughClaimsWithNoMapping` boolean If `true` (default), for each claim that is not mapped to the common profile, Auth0 passes through those in the output assertion. If `false`, those claims won't be mapped. `mapUnknownClaimsAsIs` boolean If `passthroughClaimsWithNoMapping` is `true` and this is `false` (default), for each claim not mapped to the common profile Auth0 adds a prefix `http://schema.auth0.com`. If `true` it will pass through the claim as-is. `mapIdentities` boolean If `true` (default), it adds more information in the token such as the provider (Google, ADFS, AD, etc.) and the access token, if available. `signatureAlgorithm` string Signature algorithm to sign the SAML assertion or response. Default is `rsa-sha1`. `digestAlgorithm` string Digest algorithm to calculate digest of the SAML assertion or response. Default is `sha1`. `destination` object Destination of the SAML response. If not specified, it will be `AssertionConsumerUrl` of SAMLRequest or callback URL if there was no SAMLRequest. `lifetimeInSeconds` integer Expiration of the token. Default is `3600` seconds (1 hour). `signResponse` boolean Whether or not the SAML response should be signed. By default the SAML assertion will be signed, but not the SAML response. If `true`, SAML Response will be signed instead of SAML assertion. `nameIdentifierFormat` string Default is `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`. `nameIdentifierProbes` array Auth0 will try each of the attributes of this array in order. If one of them has a value, it will use that for the `Subject/NameID`. The order is: `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier (mapped from user_id)`, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress (mapped from email)`, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` (mapped from name). `authnContextClassRef` string Default is `urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified`. `typedAttributes` boolean Default is `true`. When set to `true`, we infer the `xs:type` of the element. Types are `xs:string`, `xs:boolean`, `xs:double` and `xs:anyType`. When set to `false` all `xs:type` are `xs:anyType`. `includeAttributeNameFormat` boolean Default is `true`. When set to `true`, we infer the `NameFormat` based on the attribute name. `NameFormat` values are `urn:oasis:names:tc:SAML:2.0:attrname-format:uri`, `urn:oasis:names:tc:SAML:2.0:attrname-format:basic` and `urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified`. If set to `false`, the attribute `NameFormat` is not set in the assertion. `logout` object Controls SAML logout. It can contain two properties:`callback` (string) that contains the service provider (client application) Single Logout Service URL, where Auth0 will send logout requests and responses, and `slo_enabled`(boolean) that controls whether Auth0 should notify service providers of session termination. The default value is`true` (notify service providers). `binding` string Optionally indicates the protocol binding used for SAML logout responses. By default Auth0 uses `HTTP-POST`, but you can switch to `HTTP-Redirect` by setting `\"binding\"` to `\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"`. `signingCert` string Optionally indicates the public key certificate used to validate SAML requests. If set, SAML requests will be required to be signed. A sample value would be `\"-----BEGIN CERTIFICATE-----\\nMIIC8jCCAdqgAwIBAgIJObB6jmhG0QIEMA0GCSqGSIb3DQEBBQUAMCAxHjAcBgNV\\n[..all the other lines..]-----END CERTIFICATE-----\\n\"`.",
    "title": "Customize SAML Assertions",
    "description": "Describes how to customize SAML assertions and the SAML and WS-Fed protocol parameters.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider",
    "markdown": "# Configure PingFederate as SAML Identity Provider\n\nPingFederate is a federation server that provides identity management, single sign-on, and API security for the enterprise. See the complete PingFederate instructions to [configure PingFederate as an identity provider](https://docs.pingidentity.com/r/en-us/pingfederate-120/pf_ident_provid_sso_config).\n\nTo configure Auth0 to use PingFederate as an identity provider, you will use primarily the default values and your Auth0 tenant metadata file to upload the required configuration parameter values for your Auth0 tenant. If the metadata upload fails for some reason, these are the most important configuration parameters:\n\n*   **EntityID:** `urn:auth0:{yourTenant}:{yourConnectionName}`\n    \n*   **Assertion Consumer Service URL:** `https://{yourDomain}/login/callback`\n    \n*   **Logout URL:** `https://{yourDomain}/logout`\n    \n*   **HTTP-Redirect** binding for SAML Request\n    \n*   **HTTP-POST** binding for SAML Response\n    \n\n1.  Download your Auth0 metadata file from `https://YOUR_DOMAIN/samlp/metadata?connection=YOUR_CONNECTION_NAME`. Make sure that you use your custom domain if you have one configured. You will upload this file to import your Auth0 tenant information into the PingFederate configuration.\n    \n2.  Sign on to your PingFederated account and select **Create New** from the **SP Connections** section.\n    \n3.  Configure the **SP Connection**.\n    \n    *   Select the **Browser SSO Profiles** as the **Connection Type**.\n        \n    *   Select **Browser SSO** as the **Connection Options**.\n        \n4.  Upload the metadata file that you downloaded in step 1. The **Entity ID**, **Connection Name**, and the **Base URL** will be automatically populated based on the information from the metadata file.\n    \n5.  Configure **Browser SSO**.\n    \n    *   Select **SP-Initiated SSO** and **SP-Initiated SLO** in **SAML Profiles**.\n        \n    *   Go to the **Assertion Creation** section and click **Configure Assertion**. Accept all defaults for the next two screens.\n        \n6.  Go to the **IdP Adapter Mapping** section. This is where users will be authenticated. Likely, you already have one configured in your PingFederate installation. Select one, or add a new one. Auth0 only requires the **NameIdentifier** claim. All other attributes will be passed further to the end application.\n    \n7.  Configure **Protocol Settings**. Values for **Protocol Settings** are imported from the metadata file. Next, you will see the **Assertion Consumer Service URL** and the Sign-Out URLs. Click **Next** to the **Allowable SAML Bindings** section.\n    \n8.  Leave **POST** and **Redirect** enabled. Make sure **SAML Assertion** is always signed.\n    \n9.  Configure **Credentials**. On **Digital Signature Settings**, select your signing certificate and make sure you check the option to include it in the `<KeyInfo>` element.\n    \n10.  Configure the certificate used to sign incoming requests. You can download the Auth0 certificate (use `https://{yourTenant}.auth0.com/pem`) and upload it here. Auth0 signs `SAMLRequests` by default; you can change that when you configure the connection.\n    \n11.  Review your settings and set them as **Active** or **Inactive**.\n    \n12.  Click **Save** at the bottom of the screen. You should see the new SP Connection on the **Main** screen.\n    \n\n## Identity provider-initiated SSO\n\nTo use IdP-Initiated SSO, make sure to include the `connection` parameter in the Assertion Consumer Service URL: `https://{yourDomain}/login/callback?connection={yourConnectionName}`.\n\nTo learn how to configure Auth0 to route the incoming SAML responses, read [Configure Identity Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on).",
    "title": "Configure PingFederate as SAML Identity Provider",
    "description": "Describes how to configure PingFederate as a SAML identity provider for use with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider",
    "markdown": "# Configure SSOCircle as SAML Identity Provider\n\nConfigure SSOCircle as an identity provider by completing the following steps:\n\n1.  Obtain SSOCircle metadata.\n    \n2.  Configure enterprise connection in Auth0.\n    \n3.  Configure SSOCircle as identity provider.\n    \n4.  Test connection.\n    \n\n## Prerequisite\n\nYou must have a [SSOCircle](https://idp.ssocircle.com/) account.\n\n## Obtain SSOCircle metadata\n\n1.  Navigate to [SSOCircle's IDP page](https://idp.ssocircle.com/) to see the metadata required for integration. You will be shown an XML file.\n    \n2.  From this page, you will need to save the following attributes:\n    \n    1.  The Location URL for the `SingleSignOnService` attribute with an `HTTP-Redirect` type.\n        \n    2.  The Location URL for the `SingleLogoutService` attribute with an `HTTP-Redirect` type.\n        \n3.  [Download](http://www.ssocircle.com/en/idp-tips-tricks/public-idp-configuration) and save the SSOCircle CA Certificate.\n    \n\n## Configure enterprise connection in Auth0\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#/connections) and click the **plus** icon to go to the page that allows you to create a new connection.\n    \n2.  Provide the appropriate configuration settings for this connection. The only mandatory fields are as follows:\n    \n    | **Setting** | **Description** | **Example** |\n    | --- | --- | --- |\n    | Connection name | Auth0 connection name. | `myoktaconnection` |\n    | Sign In URL | Okta URL where user login requests are sent.<br><br>This is the **Identity Provider Single Sign-On URL** value you recorded previously. | `https://my_okta_tenant_name.okta.com/app/` `my_okta_tenant_namemy_okta_saml_app_integration_name/` `dakflkbzevu5i5zBi939/sso/saml` |\n    | X509 Signing Certificate | Okta tenant public key signing certificate.<br><br>Upload the **X509 Certificate** you downloaded previously. | `myOktaTenantSigningCertificate.pem` |\n    \n3.  When setting up mappings, use the following JSON to properly map SAML attributes from SSO Circle:\n    \n    ```\n    {\n          \"email\": \"EmailAddress\",\n          \"given_name\": \"FirstName\",\n          \"family_name\": \"LastName\"\n        }\n    ```\n    \n4.  Click **Save**. In the next window, you'll be provided two options:\n    \n    1.  If you are a domain administrator, click **Continue** for additional instructions on SAML identity provider configuration.\n        \n    2.  If you are not, you can give your domain administrator the provided URL so that they can finish the configuration.\n        \n\nYou can access the metadata for an Auth0 SAML connection using a URL with the following format: `https://{yourDomain}/samlp/metadata?connection={yourConnectionName}`.\n\nYou will need to provide this metadata to SSOCircle in the next step.\n\n## Configure SSOCircle as identity provider\n\n1.  Log in to your [SSOCircle](http://ssocircle.com/) account. You will be directed to your user profile, and to the left of that is a navigation bar.\n    \n2.  Click **Manage Metadata**.\n    \n3.  Select **Add New Service Provider**, and provide the following information to configure the new service provider which, in this case, is Auth0:\n    \n    | Setting | Description |\n    | --- | --- |\n    | **FQDN of the ServiceProvider** | `auth0.com` |\n    | **Attributes to send in assertion** | Check the box for `EmailAddress` |\n    | **Insert your metadata information:** | Paste in the XML metadata that you downloaded after you configured your Auth0 connection. |\n    \n4.  Click **Submit**.\n    \n\n## Test connection\n\n### Create Auth0 application\n\n1.  Go to the **Applications** page on the [Auth0 Dashboard](https://manage.auth0.com/#) and click **\\+ New Application**.\n    \n2.  Provide some basic information about your new application. Choose **Regular Web Applications** as the application type.\n    \n3.  Click **Create** to finish configuration and begin the Application creation process. You will be directed to the application details page.\n    \n4.  Click **Settings**.\n    \n5.  In the **Allowed Callback URL** field, enter the list of allowed callback URLs includes those to which users will be redirected after authentication. The URL(s) entered here must match the **callback URL** in the HTML code you will create in a later step. Normally, you would enter a URL for your application, but to keep this example simple, users will simply be sent to the Auth0 JWT Tool.\n    \n6.  Click **SAVE CHANGES**.\n    \n7.  Return to the top of **Settings** and click **Connections**.\n    \n8.  Scroll to the **Enterprise** section. Find the row for the SAML connection you created above and turn on toggle to enable the SAML connection.\n    \n\n### Test enterprise connection\n\n1.  To test your connection, follow the steps in [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n    \n2.  During this process you will be asked to log in and consent.\n    \n3.  Additionally, if you see a message that says, \"Your session has timed out,\" click the **Return to Login page** link below the message.\n    \n\nIf logging in to your application doesn't work the first time, clear your browser's history and cookies before testing again. The browser may not be picking up the latest version of your HTML.\n\nWhen troubleshooting SSO, it is often helpful to capture an HTTP trace of the interaction. There are many tools that will capture the HTTP traffic from your browser for analysis (search for \"HTTP Trace\" to find one appropriate for your needs). Once you have an HTTP tracer, capture the login sequence from start to finish and analyze the trace to see the sequence of `GET` requests to see where the error occurs. You should see:\n\n*   A redirect from your original site to the IDP\n    \n*   A post of credentials (if you were asked to log in)\n    \n*   A redirect to the callback URL.\n    \n\nEnsure that your browser has enabled cookies and JavaScript.\n\nCheck to make sure that the callback URL specified in the HTML is also listed in the **Allowed Callback URLs** field in the **Settings** tab of the Auth0 Application.",
    "title": "Configure SSOCircle as SAML Identity Provider",
    "description": "Learn how to configure an application to use Auth0 for SAML Single Sign-on (SSO), authenticating users against SSOCircle.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-atlassian",
    "markdown": "# Configure Atlassian as SAML Service Provider\n\nUse the following SAML configuration for Atlassian.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** from **SP Assertion Consumer Service URL** in the [Atlassian Admin dashboard](https://admin.atlassian.com/).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n      \"mappings\": {\n        \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"given_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n        \"family_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"\n      },\n      \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n      ],\n      \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:email\"\n    }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Atlassian as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Atlassian. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-cisco-webex",
    "markdown": "# Configure Cisco WebEx as SAML Service Provider\n\nUse the following SAML configuration for Cisco WebEx.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL.** Note that Webex has an option to automatically provision new users. You will need to send that information as claims (`lastname`, and so on). If you integrate Auth0 with Cisco Spark services, read [Single Sign-On with Cisco Spark Services](https://collaborationhelp.cisco.com/article/en-us/lfu88u).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n           \"mappings\": {\n         \"email\": [\"email\", \"uid\", \"Name_ID\"]\n           },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n         \"email\",\n           ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider in Cisco WebEx.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Cisco WebEx as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Cisco WebEx.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-egencia",
    "markdown": "# Configure Egencia as SAML Service Provider\n\nUse the following SAML configuration for Egencia.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.egencia.com/auth/v1/artifactConsumer`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://{yourAccountName}.egencia.com\",\n           \"mappings\": {\n           },\n           \"createUpnClaim\":       false,\n           \"passthroughClaimsWithNoMapping\": false,\n           \"mapUnknownClaimsAsIs\": false,\n           \"mapIdentities\":        false,\n           \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n           \"nameIdentifierProbes\": [\n         \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n           ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the tab and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Egencia as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon  for Egencia.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-freshdesk",
    "markdown": "# Configure Freshdesk as SAML Service Provider\n\nUse the following SAML configuration for Freshdesk.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://{FD Domain}.freshdesk.com/login/saml`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n    1.  It can be found at: **Freshworks Dashboard > Security > SAML SSO > Assertion Consumer Service(ACS) URL**\n        \n    2.  The audience can be found at: **Freshworks Dashboard > Security > SAML SSO > Service Provider(SP) Entity ID URL**\n        \n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://{FD Domain}.freshworks.com/sp/SAML/{xxxxxxxxxxxxxxxxxxx}/metadata\",\n          \"mappings\": {\n        \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        \"given_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n        \"family_name\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"\n          },\n          \"createUpnClaim\": false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\": false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Freshdesk as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Freshdesk.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog",
    "markdown": "# Configure Datadog as SAML Service Provider\n\nUse the following SAML configuration for Datadog.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://app.datadoghq.com/account/saml/assertion`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://app.datadoghq.com/account/saml/metadata.xml\",\n           \"mappings\": {\n           },\n           \"createUpnClaim\":       false,\n           \"passthroughClaimsWithNoMapping\": false,\n           \"mapUnknownClaimsAsIs\": false,\n           \"mapIdentities\":        false,\n           \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n           \"nameIdentifierProbes\": [\n         \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n           ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Datadog as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Datadog. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-pluralsight",
    "markdown": "# Configure Pluralsight as SAML Service Provider\n\nUse the following SAML configuration for Pluralsight.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://prod-pf.pluralsight.com/sp/ACS.saml2`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\":  \"www.pluralsight.com\",\n          \"mappings\": {\n        \"user_id\":     \"id\",\n        \"email\":       \"email\",\n        \"given_name\":  \"firstName\",\n        \"family_name\": \"lastName\"\n          },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Pluralsight as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Pluralsight.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-litmos",
    "markdown": "# Configure Litmos as SAML Service Provider\n\nUse the following SAML configuration for Litmos.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://{yourDomain}.litmos.com/integration/samllogin`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"mappings\": {\n           \"user_id\":     \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n           \"email\":       \"Email\",\n           \"given_name\":  \"FirstName\",\n           \"family_name\": \"LastName\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha1\",\n         \"digestAlgorithm\":      \"sha1\",\n         \"destination\":          \"https://{yourDomain}.litmos.com/integration/samllogin\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Litmos as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Litmos.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-sprout-video",
    "markdown": "# Configure Sprout Video as SAML Service Provider\n\nUse the following SAML configuration for Sprout Video.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** that you can obtain from your Sprout Video settings. It will typically be something like: `https://app.sproutvideo.com/auth/sso/consumption`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"https://{yourSproutVideoAccount}.vids.io\",\n         \"mappings\": {  \n           \"user_id\":     \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n           \"email\":       \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n         ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Sprout Video as SAML Service Provider",
    "description": "Describes how to configure Auth0 to serve as an identity provider for Sprout Video.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-hosted-graphite",
    "markdown": "# Configure Hosted Graphite as SAML Service Provider\n\nUse the following SAML configuration for Hosted Graphite.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.hostedgraphite.com/complete/saml/{yourUserId}/`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://www.hostedgraphite.com/metadata/{yourUserId}/\",\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Hosted Graphite as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Hosted Graphite.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-idp-for-google-g-suite",
    "markdown": "# Configure Google Workspace as SAML Service Provider\n\nUse the following SAML configuration for Google Workspace.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://www.google.com/a/{YOUR-GOOGLE-DOMAIN}/acs`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://www.google.com/a/{yourGoogleDomain}/acs\",\n          \"mappings\": {\n        \"nickname\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n          },\n          \"createUpnClaim\": false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\": false,\n          \"signatureAlgorithm\": \"rsa-sha256\",\n          \"digestAlgorithm\": \"sha256\",\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:email\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"\n          ],\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider (IdP).\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Google Workspace as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App for Google Workspace.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-online",
    "markdown": "# Configure Tableau Online as SAML Service Provider\n\nUse the following SAML configuration for Tableau Online.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"https://sso.online.tableau.com/public/sp/metadata?alias={yourTableauAlias}\",\n         \"recipient\": \"https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}\",\n         \"mappings\": {\n        \"email\": \"Email\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha256\",\n         \"digestAlgorithm\":      \"sha256\",\n         \"destination\":          \"https://sso.online.tableau.com/public/sp/SSO/{yourTableauAlias}\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Tableau Online as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Tableau Online.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workday",
    "markdown": "# Configure Workday as SAML Service Provider\n\nUse the following SAML configuration for Workday.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://impl.workday.com/<tenant>/login-saml.htmld`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"http://www.workday.com\",\n          \"recipient\": \"https://www.myworkday.com/<tenant>/login-saml.htmld\",\n          \"mappings\": {\n          },\n          \"createUpnClaim\":       false,\n          \"passthroughClaimsWithNoMapping\": false,\n          \"mapUnknownClaimsAsIs\": false,\n          \"mapIdentities\":        false,\n          \"signResponse\":         true,\n          \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName\",\n          \"nameIdentifierProbes\": [\n        \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n          ],\n          \"authnContextClassRef\": \"urn:oasis:names:tc:SAML:2.0:ac:classes:X509\",\n        }\n    ```\n    \n    Change the subdomain `impl` depending on the Workday data center you are using.\n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Workday as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Workday.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-server",
    "markdown": "# Configure Tableau Server as SAML Service Provider\n\nUse the following SAML configuration for Tableau Server.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `http://{yourTableauServer}/wg/saml/SSO/index.html`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n         \"audience\":  \"{yourTableauAudience}\",\n         \"recipient\": \"http://{yourTableauServer}/wg/saml/SSO/index.html\",\n         \"mappings\": {\n        \"email\": \"username\"\n         },\n         \"createUpnClaim\":       false,\n         \"passthroughClaimsWithNoMapping\": false,\n         \"mapUnknownClaimsAsIs\": false,\n         \"mapIdentities\":        false,\n         \"signatureAlgorithm\":   \"rsa-sha1\",\n         \"digestAlgorithm\":      \"sha1\",\n         \"destination\":          \"http://{yourTableauServer}/wg/saml/SSO/index.html\",\n         \"lifetimeInSeconds\":    3600,\n         \"signResponse\":         false,\n         \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\",\n         \"nameIdentifierProbes\": [\n           \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n         ]\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Tableau Server as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using SAML2 Web App addon for Tableau Server.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security",
    "markdown": "# Custom Database Connection Security Best Practices\n\n## Access legacy identity storage via custom API\n\nWe recommend that you implement an API to provide least privilege to your legacy identity storage rather than simply opening up general access via the internet.\n\nProtecting legacy identity storage from general access is a recommended best practice. Exposing a (legacy identity) database directly to the internet, for example, can be extremely problematic: database interfaces for SQL and the like are extremely open in terms of functionality, which violates the principle of least privilege when it comes to security.\n\nThe alternative is to create a simple (custom) API—protected via use of an access token—that each action script can call. This would act as the interface to the legacy identity store. Client credentials grant flow can then be used to obtain an access token from within a script, and this can be subsequently cached for re-use within the `global` object to improve performance. The API can then provide a discrete number of protected endpoints that perform only the legacy (identity) management functionality required (e.g., read user, change password).\n\nBy default, Auth0 will give you a token for any API if you authenticate successfully and include the appropriate audience. Restricting access to the legacy identity store API by restricting access token allocation via the use of a rule will prevent unauthorized usage and will mitigate a number of attack vector scenarios, such as where redirect to `/authorize` is intercepted and the audience to the API is added.\n\n## Access to legacy identity storage\n\nWhether managing access to legacy identity storage via custom API or using the native interface provided, you should restrict access to the list of IP addresses associated with your Auth0 tenant. To see the list of IP addresses, read [Auth0 IP Addresses for AllowLists](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). Adding URLs to the AllowList constrains access to the legacy identity store and ensures that only custom database actions scripts defined in Auth0 are permitted.\n\n## Learn more\n\n*   [Secure](https://auth0.com/docs/secure)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
    "title": "Custom Database Connection Security Best Practices",
    "description": "Learn about best practices for custom database connection security.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workpath",
    "markdown": "# Configure Workpath as SAML Service Provider\n\nUse the following SAML configuration for Workpath.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to update.\n    \n2.  Go to the **Addons** tab and enable the **SAML2 Web App** toggle.\n    \n3.  On the **Settings** tab, set the **Application Callback URL** to: `https://api.workpath.com/v1/saml/assert/{yourWorkpathSubdomain}`.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n4.  Paste the following code into the **Settings** text box and click **Debug**.\n    \n    ```\n    {\n          \"audience\": \"https://api.workpath.com/v1/saml/metadata/{yourWorkpathSubdomain}\",\n          \"mappings\": {\n        \"email\": \"email\",\n        \"given_name\": \"first_name\",\n        \"family_name\": \"last_name\"\n          }\n        }\n    ```\n    \n5.  Scroll to the bottom of the page and click **Enable**.\n    \n6.  On the **Usage** tab, locate **Identity Provider Metadata**, and click **Download** to download the metadata file. You'll need this when you configure Auth0 as the identity provider.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)",
    "title": "Configure Workpath as SAML Service Provider",
    "description": "Learn how to configure Auth0 as an identity provider using the SAML2 Web App addon for Workpath.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension",
    "markdown": "# Install Single Sign-On Dashboard Extension\n\nUse the Single Sign-On (SSO) Dashboard Extension to manage SSO login for your users on multiple enterprise applications. To learn more, [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Install extension\n\nYou can install the SSO Dashboard extension through the Auth0 Dashboard:\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **SSO Dashboard** from the list of provided extensions. The **Install Extension** window will open:\n    \n    ![Dashboard - Extensions - SSO Dashboard - Install Extension](https://images.ctfassets.net/cdy7uua7fh8z/75heEyuJAN6FGSszXx06Hm/cf130fc22931cd351179ba08787f835a/dashboard-extensions-install_sso-dashboard.png)\n2.  Set the following configuration variables:\n    \n    | **Variable** | **Required** | **Description** |\n    | --- | --- | --- |\n    | `EXTENSION_CLIENT_ID` | Required | **Client ID** of the Auth0 application you created for the extension. |\n    | `TITLE` | Optional | Custom title that will appear at the top of the SSO Dashboard page. |\n    | `CUSTOM_CSS` | Optional | Path to a custom CSS file to style the look of your SSO Dashboard page. |\n    | `FAVICON_PATH` | Optional | Path to a custom favicon. |\n    | `AUTH0_CUSTOM_DOMAIN` | Optional | [Custom domain](https://auth0.com/docs/customize/custom-domains) configured with Auth0. |\n    \n3.  Select **Install**.\n    \n\nIf you navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), you'll notice that an application named `auth0-sso-dashboard` was created automatically. This application is used by the extension to authorize access to the Management API, and you must not modify it.\n\n## Use extension\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select the **Installed Extensions** view.\n    \n2.  Select **SSO Dashboard**. When you first select your installed extension, you will be asked to grant it the required permissions. Once you agree, you will be directed to your custom **SSO Dashboard**, which will display the **Title** you provided at the top of the page. If you provided a custom CSS file, that styling will also be applied.\n    \n3.  To log in to the SSO Dashboard:\n    \n    1.  For **Admins,** use: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/admins/login`\n        \n    2.  For **Users,** use: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/login`\n        \n        | **Region** | **Region Key** |\n        | --- | --- |\n        | US-1 | `us12` |\n        | US-3 | `us` |\n        | EU  | `eu12` |\n        | AU  | `au12` |\n        | JP-1 | `jp` |\n        \n\n## Learn more\n\n*   [Create Single Sign-on (SSO) Dashboard Application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application)\n*   [Add Applications to Single Sign-On Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard)\n*   [Update Applications in the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
    "title": "Install Single Sign-On Dashboard Extension",
    "description": "Learn how to install the Auth0 Single Sign-On (SSO) Dashboard Extension to enable SSO login for your applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login/customization-classic",
    "markdown": "# Customize Classic Login Pages\n\n[Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) is an Auth0-hosted login experience that relies on JavaScript for page customization.\n\nFrom the Auth0 Dashboard, you can configure basic customization options that apply to all login pages. For advanced customization, you can directly modify the HTML template of one or more pages.\n\nAdditionally, you can manage your page content using the [version control syste](https://auth0.com/docs/customize/login-pages/classic-login/version-control) of your choice.\n\n## Basic Customization\n\nYou can configure the following options from the Auth0 Dashboard under [Branding > Universal Login > Settings tab](https://manage.auth0.com/#/login_settings):\n\n*   Company Logo (recommended size: 150 x 150 pixels)\n    \n*   Primary Color\n    \n*   Background Color\n    \n\nBy default, these settings affect all Classic Login pages, such as the login screen or password reset page. If you directly modify the HTML template of one or more pages and edit any attributes related to these options, those attributes will supersede these settings.\n\n## Advanced Customization\n\nFor further customization, you can directly modify the HTML template of the following pages:\n\n*   Login (see below)\n    \n*   [Password reset](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page)\n    \n*   [Multi-factor authentication](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n    \n\n### Responsibility for updates\n\n**When you enable customization for a specific page, you assume responsibility for maintaining that page**, as it will no longer receive automatic updates from Auth0. Such maintenance includes updating the version numbers of any included Auth0 SDKs or widgets.\n\nAs sensitive security-related information often flows through the login page, introducing cross-site scripting (XSS) vulnerabilities is a point of concern. Additionally, if your organization uses [home realm discovery](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/authentication#home-realm-discovery) in conjunction with Classic Login, a list of available connections is publicly visible in the Auth0.setClient property. Considering this, Auth0 encourages you to exercise caution when using third-party JavaScript on your login page.\n\n### Enable page customization\n\nTo enable customization for a specific page, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login](https://manage.auth0.com/#/login_settings).\n    \n2.  Select one of the following tabs:\n    \n    *   **Login**\n        \n    *   **Password Reset**\n        \n    *   **Multi-Factor Authentication**\n        \n3.  Enable the **Customize Page** toggle located at the top of the tab.\n    \n4.  Repeat steps 2 and 3 as needed.\n    \n\nAfter enabling customization for a page, you can modify its HTML template through the code editor located below the toggle.\n\n### Customize the Login page\n\nTo customize the login page template, you must first choose a base template to work from.\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Login tab](https://manage.auth0.com/#/login_page).\n    \n2.  Enable the **Customize Login Page** toggle.\n    \n3.  Above the HTML code editor, select an option from the **Default Templates** menu.\n    \n\nThe available templates use the following libraries:\n\n*   [Lock](https://auth0.com/docs/libraries/lock)\n    \n*   [Lock (Passwordless Mode)](https://auth0.com/docs/libraries/lock)\n    \n*   [Auth0.js](https://auth0.com/docs/libraries/auth0js)\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication)\n    \n\nYou can use these libraries within Classic Login or embed them directly into an application. To better understand how you can customize your login experience, review the documentation for your preferred library.\n\n#### Lock template\n\nIf you plan on using the default login page and require only minimal changes, you can use the Lock template to modify the behavior of the Lock widget on the login page.\n\nFor example, you can configure the Lock widget to:\n\n*   Direct users to the signup page instead of the login page by default\n    \n*   Customize the login page with different colors, text, or default languages\n    \n*   Present users with only one or more specific login methods\n    \n\nTo learn more about customizing the Lock widget, review the [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration).\n\n#### Custom Login Form template\n\nIf you want to significantly modify the login page, you can use the Custom Login Form template as a guide. This template shows you how to get the values you need with the Auth0.js SDK. You can then modify the style and layout of the login page as desired. Any CSS customization **must** be inline, as you cannot host a separate CSS file in your Auth0 tenant.\n\n## Learn more\n\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Customize Classic Login Pages with Lock or SDK](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)",
    "title": "Customize Classic Login Pages",
    "description": "Learn how to customize the login page for the Classic Login experience.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk",
    "markdown": "# Customize Classic Login Pages with Lock or SDK\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for [advanced customization](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic). Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nBy default, the Classic Login page uses the Lock widget for user authentication. However, you can also customize templates for Lock in Passwordless Mode or a custom UI built with the Auth0.js SDK.\n\nTo customize your Classic Login page templates, you must first enable advanced customization. To do so, follow the steps below:\n\n1.  On the Auth0 Dashboard, navigate to [Branding > Universal Login > Login tab](https://manage.auth0.com/#/login_page).\n    \n2.  Enable the **Customize Login Page** toggle.\n    \n3.  Above the HTML code editor, select the Default Templates menu and choose the desired option.\n    \n\nThe templates available include:\n\n*   Lock\n    \n*   Lock (passwordless)\n    \n*   Custom Login Form\n    \n\nBoth Lock templates allow you to customize the Lock widget used for authentication. The Lock widget provides a standard set of behaviors and a customizable user interface. Alternatively, you can use the Custom Login Form template to customize your login page with the [Auth0 SDK for Web](https://auth0.com/docs/libraries/auth0js) or [Authentication API](https://auth0.com/docs/api/authentication).\n\nAuth0 SDKs are client-side libraries that **do not** offer a user interface but allow for expanded customization of the behavior and appearance of the login page. The Authentication API provides direct integration without the use of Auth0 SDKs.\n\nThe template you use to customize your login page will depend on the unique needs of your application. The sections below provide an overview of each option: Lock, Auth0 SDKs, or the Authentication API.\n\n## Using the Lock widget\n\n[Lock](https://auth0.com/docs/libraries/lock) is a login form that makes it easy for your users to authenticate using a selected connection. Lock automatically handles most of the details involved in creating and authenticating users.\n\nWith Lock, you will be implementing a UI that:\n\n*   Is robust and provides an excellent user experience on any device with any resolution\n    \n*   Has a simple design that fits in with most websites with just a few tweaks to its custom color\n    \n*   Adapts to your configuration, displaying the appropriate form controls for each available connection and only those that are allowed (such as signup or password reset)\n    \n*   Selects the correct connection automatically. You may specify a desired default behavior for ambiguous cases\n    \n*   Remembers the last used connection for a given user\n    \n*   Automatically accommodates internationalization\n    \n*   Provides instant password policy checking at signup\n    \n\nAlthough you cannot alter Lock's behavior significantly, you can configure several basic options to make Lock look and behave differently.\n\nConsider using Lock if:\n\n*   You like the structure, look, and feel of the widget.\n    \n*   You prefer a streamlined implementation of Classic Login with a ready-made responsive UI.\n    \n*   Your process includes many of the use cases that Lock handles out of the box:\n    \n    *   Enterprise logins\n        \n    *   Databases with password policies\n        \n    *   User signup and password reset\n        \n    *   Authentication using social providers\n        \n    *   Avatars\n        \n\n### Sample login customization scripts\n\n#### Customize the application logo\n\nThe example script below customizes the logo for each application, or you can set a default logo. The minimum recommended resolution is 200 pixels (width) by 200 pixels (height). Add the `logouturl` configuration to the `<scripts>` block:\n\n```\nvar logourl = \"https://example.com/defaultlogo1.png\"; //set default logo\nif(config.clientID === \"HUXwC72R3qr9JJo9ImPsdzJbtY8aD5kS\")\n{\n    logourl = \"https://example.com/defaultlogo2.png\";\n}\ntheme: {\n    logo: logourl,\n    primaryColor: colors.primary ? colors.primary : 'green'\n},\n```\n\n#### Customize the signup terms\n\nThe example below customizes the signup terms for your application. You can add custom language to display when users signup.\n\n```\nvar languageDictionary;\n\nlanguageDictionary = {\n    signUpTerms: \"I agree to the <a href='https://my-app-url.com/terms' target='_blank'>terms of service</a> and <a href='https://my-app-url.com/privacy' target='_blank'>privacy policy</a>.\"\n};\n```\n\n## Using the Auth0 SDK for Web\n\nIf the requirements of your app cannot be met by the standardized behavior of Lock, or if you have a complex custom authentication process, a custom user interface is needed. You may also prefer this option if you have an existing user interface that you wish to use.\n\nWith [Auth0's library for Web](https://auth0.com/docs/libraries/auth0js), you can customize the behavior and flow of the process used to trigger signup and authentication. You can also directly use the Authentication API, without any wrapper at all, if you so choose.\n\nUnlike with Lock, neither of these options includes a user interface. You will have complete control over the user experience for signup and authentication flow, and for the UI aspects of layout, look and feel, branding, internationalization, RTL support, and more.\n\nConsider implementing a custom user interface in conjunction with an Auth0 library or the Authentication API for your app if:\n\n*   You have strict requirements for the appearance of the user interface\n    \n*   You have strict requirements for file sizes - the Auth0 libraries are significantly smaller than Lock, and if you instead choose to deal with the API directly, that would not require any additional weight.\n    \n*   You are comfortable with HTML, CSS, and JavaScript - you'll be creating your own UI\n    \n*   You only need to handle username/password and social provider authentication\n    \n*   You have multiple database or Active Directory Connections\n    \n\nYou can also see specific examples of the usage of both Lock and Auth0 SDKs for a wide variety of programming languages and platforms in our [Quickstarts](https://auth0.com/docs/quickstart). These guides may further assist you in your decision about which to use for your specific app needs.\n\n## Learn more\n\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Add Bot Detection to Custom Login Pages](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-custom-login-pages)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)",
    "title": "Customize Classic Login Pages with Lock or SDK",
    "description": "Learn how to customize the Classic Login page with Lock or a custom UI built on top of an Auth0 SDK.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login/version-control",
    "markdown": "# Classic Login Page Version Control\n\nYou can use version control software to manage the source code of your Classic Login pages. Using version control for your content may be especially beneficial if you use a CI/CD flow for your tenant configuration and have customized the HTML of one or more Classic Login pages.\n\nTo implement version control, use the Auth0 Marketplace integration for your preferred method:\n\n*   [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline)\n    \n*   [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions)\n    \n*   [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline)\n    \n*   [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline)\n    \n\nThe general deployment process requires the following steps:\n\n1.  Create a folder in your version control repository with the appropriate name (`pages`).\n    \n2.  Create an HTML page (`login.html`, `password_reset.html`, `guardian_multifactor.html`, or `error_page.html`) within that folder.\n    \n3.  Create a JSON file with the same name as your HTML page for each hosted page that you wish to source control. To enable the page, the JSON file needs to contain the following:\n    \n\n`{ \"enabled\": true }`\n\nFor example: `your-repo/pages/error_page.html your-repo/pages/error_page.json`\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
    "title": "Classic Login Page Version Control",
    "description": "Learn how to back up your Classic Login pages using the Auth0 source control extensions",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard",
    "markdown": "# Add Applications to Single Sign-On Dashboard\n\nUse the [](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension)Single Sign-On (SSO) Dashboard Extension to manage SSO login for your users on multiple enterprise applications.\n\n## Prerequisites\n\n*   [Create the SSO Dashboard application](https://auth0.com/docs/dashboard/guides/extensions/sso-dashboard-create-app).\n    \n*   [Install the SSO Dashboard Extension](https://auth0.com/docs/dashboard/guides/extensions/sso-dashboard-install-extension).\n    \n\n## Add applications\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select your new SSO Dashboard extension. If you are an administrator, you can also log in to the SSO Dashboard using `https://{yourTenant}.<REGION>8.webtask.io/auth0-sso-dashboard/admins/login`.\n    \n2.  In the upper right corner, select **Settings** from the dropdown below your tenant name.\n    \n3.  Click **Create App** to add a new application.\n    \n    ![Dashboard - Extensions - SSO Dashboard - Administrator - Create App Settings](https://images.ctfassets.net/cdy7uua7fh8z/7qPSaWPOPPhQHfqW38mbxH/9c52a16f51d9941b3741043c36bba08e/settings.png)\n    \n    The **New Application** form appears.\n    \n    ![Dashboard - Extensions - SSO Dashboard - New App](https://images.ctfassets.net/cdy7uua7fh8z/6wAZQYT8xDqgKa0Fj9AuBQ/009cb704da2f138faf8fafea2c785f45/new-app.png)\n4.  Complete the following fields for the new application:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Type** | A dropdown where you select SAML, OpenID-Connect, or WS-Federation depending on the type of application. |\n    | **Application** | A dropdown where you select the application that you wish to add. |\n    | **Name** | The name is automatically populated based on the application you selected. You can change the name or use the default. |\n    | **Logo** | The url of the logo you wish to user as an icon for the application. |\n    | **Callback** | One of the **Allowed Callback URLs** under your [Application Settings](https://manage.auth0.com/#/applications) for the application. |\n    | **Connection** | (_Optional_) The connection type. You can add or edit your available connection types in the [Connections section of the Auth0 Management dashboard](https://manage.auth0.com/#/connections/database). If a connection is not set and the user is not logged, the user will see the Auth0 Login page. |\n    | **Custom URL** | (_Optional_) Checkbox to use a custom URL rather than the Auth0 URL. If you check the box, a field appears where you can enter your custom URL. |\n    | **Enabled** | Checkbox for this application to be visible (published) to your users. |\n    \n5.  Select **Create**. Your new application will then appear on the **Applications** page of the SSO dashboard with any other applications that have been created.\n    \n    ![Dashboard - Extensions - SSO Dashboard Applications](https://images.ctfassets.net/cdy7uua7fh8z/2W4AdIGU3nM7fp5900vS9x/de9cea49850bbfa7c8e45bac94cb783c/dashboard-apps.png)\n6.  Click on an application to test the connection.\n    \n\n## Learn more\n\n*   [Update Applications in the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard)\n*   [Create Single Sign-on (SSO) Dashboard Application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
    "title": "Add Applications to Single Sign-On Dashboard",
    "description": "Learn how to add applications to the Auth0 Single Sign-On (SSO) Dashboard Extension to enable SSO login for your applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms",
    "markdown": "# Configure Email or SMS for Passwordless Authentication\n\nAuth0 lets you configure Universal Login so users can authenticate with a magic link or one-time password (OTP) through email, or an OTP through SMS.\n\nTo enable Passwordless authentication with SMS or email, you need to define a [Passwordless connection](https://auth0.com/docs/authenticate/passwordless) for your application.\n\nOnce you've created the connection, you need to configure Universal Login to use it. You have three options:\n\n## Universal Login\n\nThis method uses the Universal Login Experience, which natively supports Passwordless connections. To learn more, read [Passwordless with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login).\n\n## Universal Login + Lock (passwordless)\n\nThis method uses a custom login page with the **Lock (passwordless)** template, and authenticates user with the [Lock for Web SDK](https://auth0.com/docs/libraries/lock):\n\n1.  Go to [Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings) and click the **Login** tab.\n    \n2.  Enable the **Custom Login Page** toggle, and select the **Lock (passwordless)** template. The HTML template will update with code using the Lock widget with Passwordless customization options.\n    \n3.  Customize the template, and click **Save Changes**.\n    \n\nYou can use HTML and CSS to customize the login form, and preview the changes within the Dashboard. To learn more about how to customize the **Lock (passwordless)** template, read the Passwordless section in [Lock for Web SDK](https://auth0.com/docs/libraries/lock).\n\n## Universal Login + Custom UI + Auth0.js\n\nThis method uses a custom login page with the **Custom Login Form** template, and authenticates users with the [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js). To learn more, read [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login).\n\n## Learn more\n\n*   [Configure Universal Login with Passwordless](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login)\n*   [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)",
    "title": "Configure Email or SMS for Passwordless Authentication",
    "description": "Learn how to configure email or SMS for Passwordless authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless",
    "markdown": "# Set Up Custom SMS Gateway for Passwordless Connections\n\nThis guide will show you how to use a custom SMS gateway to send out your one-time-use codes.\n\nBy default, [Passwordless SMS connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp) use [Twilio](https://www.twilio.com/) to send out one-time use codes. However, if you have a custom SMS gateway, you can modify your connection to use that instead.\n\n1.  Set up a SMS passwordless connection. To learn how, read the Implement Passwordless section in [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless).\n    \n2.  [Get an Access Token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens). You will need this to make calls to the Management API to update your Passwordless connection.\n    \n3.  Use the [GET Connections](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) endpoint to retrieve information about the connections associated with your tenant. More specifically, you need to get the ID for your Passwordless SMS connection so that you can use it in a later API call that updates the connection itself. Be sure to replace `ACCESS_TOKEN` with the token you obtained in step 1 before making the following call to the Management API:\n    \n    *   [cURL](#e283aeb8361840ae8b727a26f71f4f57_shell)\n    *   [C#](#e283aeb8361840ae8b727a26f71f4f57_csharp)\n    *   [Go](#e283aeb8361840ae8b727a26f71f4f57_go)\n    *   [Java](#e283aeb8361840ae8b727a26f71f4f57_java)\n    *   [Node.JS](#e283aeb8361840ae8b727a26f71f4f57_node)\n    *   [Obj-C](#e283aeb8361840ae8b727a26f71f4f57_objc)\n    *   [...](#)\n    \n    ```\n    curl --request GET \\\n      --url https://your-auth0-tenant.com/api/v2/connections \\\n      --header 'authorization: Bearer {yourAccessToken}'\n    ```\n    \n    ```\n    var client = new RestClient(\"https://your-auth0-tenant.com/api/v2/connections\");\n    var request = new RestRequest(Method.GET);\n    request.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\n    IRestResponse response = client.Execute(request);\n    ```\n    \n    ```\n    package main\n    \n    import (\n    \t\"fmt\"\n    \t\"net/http\"\n    \t\"io/ioutil\"\n    )\n    \n    func main() {\n    \n    \turl := \"https://your-auth0-tenant.com/api/v2/connections\"\n    \n    \treq, _ := http.NewRequest(\"GET\", url, nil)\n    \n    \treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n    \n    \tres, _ := http.DefaultClient.Do(req)\n    \n    \tdefer res.Body.Close()\n    \tbody, _ := ioutil.ReadAll(res.Body)\n    \n    \tfmt.Println(res)\n    \tfmt.Println(string(body))\n    \n    }\n    ```\n    \n    ```\n    HttpResponse<String> response = Unirest.get(\"https://your-auth0-tenant.com/api/v2/connections\")\n      .header(\"authorization\", \"Bearer {yourAccessToken}\")\n      .asString();\n    ```\n    \n    ```\n    var axios = require(\"axios\").default;\n    \n    var options = {\n      method: 'GET',\n      url: 'https://your-auth0-tenant.com/api/v2/connections',\n      headers: {authorization: 'Bearer {yourAccessToken}'}\n    };\n    \n    axios.request(options).then(function (response) {\n      console.log(response.data);\n    }).catch(function (error) {\n      console.error(error);\n    });\n    ```\n    \n    ```\n    #import <Foundation/Foundation.h>\n    \n    NSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\" };\n    \n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://your-auth0-tenant.com/api/v2/connections\"]\n                                                           cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                       timeoutInterval:10.0];\n    [request setHTTPMethod:@\"GET\"];\n    [request setAllHTTPHeaderFields:headers];\n    \n    NSURLSession *session = [NSURLSession sharedSession];\n    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                    if (error) {\n                                                        NSLog(@\"%@\", error);\n                                                    } else {\n                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                        NSLog(@\"%@\", httpResponse);\n                                                    }\n                                                }];\n    [dataTask resume];\n    ```\n    \n    ```\n    $curl = curl_init();\n    \n    curl_setopt_array($curl, [\n      CURLOPT_URL => \"https://your-auth0-tenant.com/api/v2/connections\",\n      CURLOPT_RETURNTRANSFER => true,\n      CURLOPT_ENCODING => \"\",\n      CURLOPT_MAXREDIRS => 10,\n      CURLOPT_TIMEOUT => 30,\n      CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n      CURLOPT_CUSTOMREQUEST => \"GET\",\n      CURLOPT_HTTPHEADER => [\n        \"authorization: Bearer {yourAccessToken}\"\n      ],\n    ]);\n    \n    $response = curl_exec($curl);\n    $err = curl_error($curl);\n    \n    curl_close($curl);\n    \n    if ($err) {\n      echo \"cURL Error #:\" . $err;\n    } else {\n      echo $response;\n    }\n    ```\n    \n    ```\n    import http.client\n    \n    conn = http.client.HTTPSConnection(\"your-auth0-tenant.com\")\n    \n    headers = { 'authorization': \"Bearer {yourAccessToken}\" }\n    \n    conn.request(\"GET\", \"/api/v2/connections\", headers=headers)\n    \n    res = conn.getresponse()\n    data = res.read()\n    \n    print(data.decode(\"utf-8\"))\n    ```\n    \n    ```\n    require 'uri'\n    require 'net/http'\n    require 'openssl'\n    \n    url = URI(\"https://your-auth0-tenant.com/api/v2/connections\")\n    \n    http = Net::HTTP.new(url.host, url.port)\n    http.use_ssl = true\n    http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n    \n    request = Net::HTTP::Get.new(url)\n    request[\"authorization\"] = 'Bearer {yourAccessToken}'\n    \n    response = http.request(request)\n    puts response.read_body\n    ```\n    \n    ```\n    import Foundation\n    \n    let headers = [\"authorization\": \"Bearer {yourAccessToken}\"]\n    \n    let request = NSMutableURLRequest(url: NSURL(string: \"https://your-auth0-tenant.com/api/v2/connections\")! as URL,\n                                            cachePolicy: .useProtocolCachePolicy,\n                                        timeoutInterval: 10.0)\n    request.httpMethod = \"GET\"\n    request.allHTTPHeaderFields = headers\n    \n    let session = URLSession.shared\n    let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n      if (error != nil) {\n        print(error)\n      } else {\n        let httpResponse = response as? HTTPURLResponse\n        print(httpResponse)\n      }\n    })\n    \n    dataTask.resume()\n    ```\n    \n    The response from the endpoint will be an array of objects. Each object represents one connection affiliated with your tenant.\n4.  Identify your connection ID. You can find the ID associated with your Passwordless connection by reviewing the array of objects you returned from the [GET Connections endpoint](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) in step 2. To find the specific object for your Passwordless connection, you can search for the `\"name\": \"sms\"` property. Notice that the connection currently displays the Twilio information you provided during the setup process.\n    \n    ```\n    [\n        {\n            \"id\": \"con_UX85K7K0N86INi9U\",\n            \"options\": {\n                \"disable_signup\": false,\n                \"name\": \"sms\",\n                \"twilio_sid\": \"TWILIO_SID\",\n                \"twilio_token\": \"TWILIO_AUTH_TOKEN\",\n                \"from\": \"+15555555555\",\n                \"syntax\": \"md_with_macros\",\n                \"template\": \"Your SMS verification code is: @@password@@\",\n                \"totp\": {\n                    \"time_step\": 300,\n                    \"length\": 6\n                },\n                \"messaging_service_sid\": null,\n                \"brute_force_protection\": true\n            },\n            \"strategy\": \"sms\",\n            \"name\": \"sms\",\n            \"is_domain_connection\": false,\n            \"realms\": [\n                \"sms\"\n            ],\n            \"enabled_clients\": []\n        }\n    ]\n    ```\n    \n5.  Update the connection. You can do this by making a PATCH call to the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). More specifically, you'll be updating the connections `options` object to provide information about the SMS Gateway.\n    \n    Make the following changes:\n    \n    *   Remove both the `twilio_sid` and `twilio_token` parameters\n        \n    *   Add the `provider` parameter, and set it to `sms_gateway`)\n        \n    *   Add the `gateway_url` parameter, and set it to the URL of your SMS gateway. Auth0 must be able to reach this URL for it to use your gateway to send messages on your behalf.\n        \n    \n    Your payload will look something like this:\n    \n    ```\n    {\n        \"options\": {\n          \"strategy\": \"sms\",\n          \"provider\": \"sms_gateway\",\n          \"gateway_url\": \"{urlOfYourGateway}\",\n          \"from\": \"+1 234 567\",\n          \"template\": \"Your verification code is: @@password@@\",\n          \"brute_force_protection\": true,\n          \"forward_req_info\": \"true\",\n          \"disable_signup\": false,\n          \"name\": \"sms\",\n          \"syntax\": \"md_with_macros\",\n          \"totp\": {\n            \"time_step\": 300,\n            \"length\": 6\n          }\n        },\n        \"is_domain_connection\": false,\n        \"enabled_clients\": []\n    }\n    ```\n    \n\n## Authenticated requests\n\nIf your SMS Gateway accepts authenticated requests that are token-based, you can add the following to your `options` object:\n\n```\n\"gateway_authentication\": {\n    \"method\": \"bearer\",\n    \"subject\": \"urn:Auth0\",\n    \"audience\": \"urn:MySmsGateway\",\n    \"secret\": \"MySecretToSignTheToken\",\n    \"secret_base64_encoded\": false\n}\n```\n\nWhen you include `gateway_authentication` in your `options` object, Auth0 adds a [JSON Web Token](https://auth0.com/docs/secure/tokens/json-web-tokens) to the `Authorization` header whenever it sends requests to your SMS gateway. The token contains the `gateway_authentication.subject` and `gateway_authentication.audience` values, and is signed with `gateway_authentication.secret`.\n\nIf your secret is base64-url-encoded, set `secret_base64_encoded` to `true`.\n\nOnce you have updated your connection, Auth0 will send the following to your SMS Gateway every time a user signs up or logs in with your Passwordless connection.\n\n```\n{\n  \"recipient\": \"+1 399 999\",\n  \"body\": \"Your verification code is: 12345\",\n  \"sender\": \"+1 234 567\"\n}\n```\n\nIf you set the `forward_req_info` property in the `options` object to `true`, the gateway will also receive information from the HTTP request that initiated the Passwordless process. This includes the IP address of the client calling `/passwordless/start` and its User Agent.\n\n```\n{\n  \"recipient\": \"+1 399 999\",\n  \"body\": \"Your verification code is: 12345\",\n  \"sender\": \"+1 234 567\",\n  \"req\" : { \n      \"ip\" : \"167.56.227.117\",\n      \"user-agent\" : \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36\"\n       }\n}\n```\n\n## Error handling\n\nAuth0 will only consider the HTTP code returned from the SMS Gateway; it ignores the rest of the response (e.g., response body and response type).\n\nIf the SMS Gateway returns an HTTP code other than 200, the `/passwordless/start` endpoint will return an HTTP 400 code and a response that looks like the following:\n\n```\n{\n \"error\":\"sms_provider_error\",\n \"error_description\":\"Unexpected response while calling the SMS gateway: <HTTP Code Returned by the SMS Gateway>\"}\n}\n```\n\nIf the SMS Gateway returns HTTP 401, the `error_description` will be **Authentication failed while calling the SMS gateway: 401**. (Please note that the error description verbiage is subject to change at any time.)\n\nAuth0 enforces a timeout of 30 seconds for HTTP calls to custom SMS Gateways. If the SMS Gateway fails to reply within this time frame, the `/passwordless/start` endpoint will also return an HTTP 400 code. The response will have the format shown above and the `error_description` field will be **Timeout while calling the SMS gateway: <Timeout Code>**. (Again, the error description verbiage is subject to change at any time.)",
    "title": "Set Up Custom SMS Gateway for Passwordless Connections",
    "description": "Learn how to set up a custom SMS gateway for Passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/update-applications-on-the-sso-dashboard",
    "markdown": "# Update Applications in the SSO Dashboard\n\nUse the [](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension)SSO Dashboard Extension to manage SSO login for your users on multiple enterprise applications.\n\nTo learn more, see [Single Sign-On Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension) or [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Prerequisites\n\n*   [Create the SSO Dashboard application](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application) in Auth0.\n    \n*   [Install the SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension).\n    \n*   [Add applications to the SSO Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard).\n    \n\n## Update application\n\n1.  Go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions) and select the **Installed Extensions** view.\n    \n2.  Select **SSO Dashboard**. If you are an administrator, you can also log in to the SSO Dashboard using `https://{yourTenant}.<REGION>8.webtask.io/auth0-sso-dashboard/admins/login`.\n    \n3.  Select **Settings** from the dropdown below your tenant name.\n    \n    ![Dashboard - Extensions - SSO Dashboard - Application Settings - Administrator](https://images.ctfassets.net/cdy7uua7fh8z/2YoQ3x6K6moMRHuz7GfaFT/295b09d3fa6cbf0d45cf025c27fe8bb1/change-settings.png)\n\n*   To specify whether users can see the application when it is enabled, select **Publish** or **Unpublish**.\n    \n*   To update an application's settings, select its gear icon.\n    \n*   To delete an application, select its **X**. A confirmation popup will confirm the deletion.\n    \n\n## Learn more\n\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Enable Single Sign-On for Tenants](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
    "title": "Update Applications in the SSO Dashboard",
    "description": "Describes how to update applications in the SSO Dashboard Extension to enable SSO login for your applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider",
    "markdown": "# Configure Mandrill as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding](https://manage.auth0.com/#/branding/email_provider) [\\>](https://manage.auth0.com/#/branding/email_provider) [Emails Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have a [Mandrill](https://www.mandrill.com/signup/) account.\n    \n\n## Configure Mandrill\n\n1.  Log in to [Mandrill](https://www.mandrill.com/signup/).\n    \n2.  Navigate to Mandrill [Settings](https://mandrillapp.com/settings), and click **Add API key**. Copy this key value.\n    \n3.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n4.  Activate the **Use my own email provider** toggle.\n    \n5.  Click the **Mandrill** logo.\n    \n6.  Provide a **From** email address, enter the Mandrill **API Key** you previously copied.\n    \n    ![Dashboard - Branding - Email Provider - Mandrill Settings](https://images.ctfassets.net/cdy7uua7fh8z/62q50dOHkUxzmTHYZKah2N/aa941549e5123d9a70e97319733ca10a/dashboard-email-providers_settings_mandrill.png)\n7.  Click **Save**.\n    \n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe Mandrill [Outbound Activity](https://mandrillapp.com/activity) page will now display delivery insights for all emails that have been sent to your users.",
    "title": "Configure Mandrill as External SMTP Email Provider",
    "description": "Describes how to configure Mandrill as an external SMTP email provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider",
    "markdown": "# Configure Amazon SES as External SMTP Email Provider\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only.\n\n## Prerequisites\n\n*   To ensure that emails can be sent from Auth0 to your SMTP, open ports and allow inbound connections from specific IP addresses. To update the list of IPs, navigate to [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider). See [Add IP Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) for details.\n    \n*   You must have an [Amazon AWS](http://aws.amazon.com/ses/) account.\n    \n*   Determine which credentials you want to use: API or SMTP. For more info about SES credentials, see Amazon's [Using Credentials With Amazon SES](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/using-credentials.html).\n    \n\n## Configure Amazon SES with API credentials\n\n1.  Log in to your [Amazon AWS](http://aws.amazon.com/ses/) account.\n    \n2.  [Verify your domain](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html).\n    \n3.  [Verify email addresses](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html)\n    \n4.  [Request production access](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html?icmpid=docs_ses_console).\n    \n5.  [Get your AWS access keys](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/get-aws-keys.html). Copy these keys; you will need to enter these values into Auth0.\n    \n6.  [Attach a policy with the proper permissions](http://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage.html). Attach a policy with the `ses:SendRawEmail` and `ses:SendEmail` permissions, as in this example:\n    \n    ```\n    {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Effect\": \"Allow\",\n                \"Action\": [\n                    \"ses:SendRawEmail\",\n                    \"ses:SendEmail\"\n                ],\n                \"Resource\": \"*\"\n            }\n        ]\n    }\n    ```\n    \n7.  Navigate to Auth0 [Dashboard > Branding > Email Provider](https://manage.auth0.com/#/branding/email_provider).\n    \n8.  Activate the **Use my own email provider** toggle.\n    \n9.  Click the **Amazon Web Services** logo.\n    \n10.  Provide a **From** email address, enter your AWS **Access Key Id** and **Secret Access Key**, select your **Region**.\n    \n    ![Dashboard - Branding - Email Provider - AWS SES Settings](https://images.ctfassets.net/cdy7uua7fh8z/5H5otPGIXAeRAVOfl95c3G/699d35584148a65727a1e04ef6291968/dashboard-email-providers_settings_amazon-ses.png)\n11.  Click **Save**.\n    \n\n### Configure Amazon SES with SMTP credentials\n\n1.  Sign up for an [Amazon AWS](http://aws.amazon.com/ses/) account, or log in.\n    \n2.  [Verify your domain](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html).\n    \n3.  [Request production access](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html?icmpid=docs_ses_console).\n    \n4.  [Get your SMTP credentials](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/smtp-credentials.html). Copy the security credentials; you will need to enter these values into Auth0.\n    \n5.  Navigate to [Dashboard > Emails > Custom Email Providers](https://manage.auth0.com/#/emails/provider).\n    \n6.  Activate the **Use my own email provider** toggle.\n    \n7.  Click the **SMTP** logo.\n    \n8.  Provide a **From** email address, then enter your SMTP server **Host**, **Port**, **Username**, and **Password**, and click **Save**. You can use `email-smtp.us-east-1.amazonaws.com` (using the appropriate region rather than `us-east-1`) for **Host** and `587` for **Port**.\n    \n\n![Auth0 Branding Email Provider SMTP Provider Settings](https://images.ctfassets.net/cdy7uua7fh8z/7jYUb6ktBllv6yr25f5zJK/b18e9f1812afb7dced38acb3823e10e4/Dashboard_-_Branding_-_Email_Provider_-_SMTP_Provider_Settings.png)\n\n## Test email\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nThe [Amazon SES console](https://console.aws.amazon.com/ses) will now display delivery insights for all emails that have been sent to your users.",
    "title": "Configure Amazon SES as External SMTP Email Provider",
    "description": "Describes how to configure Amazon Simple Email Service (SES) as an external email provider so you can manage, monitor, and troubleshoot your email communications.",
    "languageCode": null
  }
]