[
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb",
    "markdown": "# Add Prisma ORM to an existing MongoDB project using TypeScript (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n    \n*   Access to a MongoDB 4.2+ server with a replica set deployment. We recommend using [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).\n    \n    warning\n    \n    The MongoDB database connector uses transactions to support nested writes. Transactions **requires** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n    \n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\n## Set up Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb#set-up-prisma-orm \"Direct link to Set up Prisma ORM\")\n\nAs a first step, navigate into it your project directory that contains the `package.json` file.\n\nNext, add the Prisma CLI as a development dependency to your project:\n\n```\nnpm install prisma --save-dev\n```\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
    "title": "Add Prisma ORM to an existing MongoDB project using TypeScript (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your MongoDB database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/supabase",
    "markdown": "# Supabase | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Supabase, explains the commonalities and differences between Supabase and other database providers, and leads you through the process for configuring your application to integrate with Supabase.\n\n## What is Supabase?[​](https://www.prisma.io/docs/orm/overview/databases/supabase#what-is-supabase \"Direct link to What is Supabase?\")\n\n[Supabase](https://supabase.com/) is a PostgreSQL hosting service and open source Firebase alternative providing all the backend features you need to build a product. Unlike Firebase, Supabase is backed by PostgreSQL which can be accessed directly using Prisma ORM.\n\nTo learn more about Supabase, you can check out their architecture [here](https://supabase.com/docs/guides/getting-started/architecture) and features [here](https://supabase.com/docs/guides/getting-started/features)\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/supabase#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nMany aspects of using Prisma ORM with Supabase are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`postgresql` database connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) in your schema, along with the [connection string Supabase provides you](https://supabase.com/docs/guides/database/connecting-to-postgres#finding-your-connection-string)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a database schema in Supabase\n*   use [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to Supabase\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at Supabase\n\n## Specific considerations[​](https://www.prisma.io/docs/orm/overview/databases/supabase#specific-considerations \"Direct link to Specific considerations\")\n\nIf you'd like to use the [connection pooling feature](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler) available with Supabase, you will need to use the connection pooling connection string available via your [Supabase database settings](https://supabase.com/dashboard/project/_/settings/database) with `?pgbouncer=true` appended to the end of your `DATABASE_URL` environment variable:\n\n.env\n\n```\n# Connect to Supabase via connection pooling with Supavisor.DATABASE_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true\"\n```\n\nIf you would like to use the Prisma CLI in order to perform other actions on your database (e.g. migrations) you will need to add a `DIRECT_URL` environment variable to use in the `datasource.directUrl` property so that the CLI can bypass Supavisor:\n\n.env\n\n```\n# Connect to Supabase via connection pooling with Supavisor.DATABASE_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true\"# Direct connection to the database. Used for migrations.DIRECT_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:5432/postgres\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\ninfo\n\nWe strongly recommend using connection pooling with Supavisor in addition to `DIRECT_URL`. You will gain the great developer experience of the Prisma CLI while also allowing for connections to be pooled regardless of your deployment strategy. While this is not strictly necessary for every app, serverless solutions will inevitably require connection pooling.\n\n## Getting started with Supabase[​](https://www.prisma.io/docs/orm/overview/databases/supabase#getting-started-with-supabase \"Direct link to Getting started with Supabase\")\n\nIf you're interested in learning more, Supabase has a great guide for connecting a database provided by Supabase to your Prisma project available [here](https://supabase.com/docs/guides/integrations/prisma).\n\nIf you're running into issues integrating with Supabase, check out these [specific troubleshooting tips](https://supabase.com/docs/guides/integrations/prisma#troubleshooting) or [Prisma's GitHub Discussions](https://github.com/prisma/prisma/discussions) for more help.",
    "title": "Supabase | Prisma Documentation",
    "description": "Guide to Supabase",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/neon",
    "markdown": "# Neon | Prisma Documentation\n\nThis guide explains how to:\n\n*   [Connect Prisma ORM using Neon's connection pooling feature](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-connection-pooling)\n*   [Resolve connection timeout issues](https://www.prisma.io/docs/orm/overview/databases/neon#resolving-connection-timeouts)\n*   [Use Neon's serverless driver with Prisma ORM](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview)\n\n## What is Neon?[​](https://www.prisma.io/docs/orm/overview/databases/neon#what-is-neon \"Direct link to What is Neon?\")\n\n![Neon's logo](https://avatars.githubusercontent.com/u/77690634?s=200&v=4)\n\n[Neon](https://neon.tech/) is a fully managed serverless PostgreSQL with a generous free tier. Neon separates storage and compute, and offers modern developer features such as serverless, branching, bottomless storage, and more. Neon is open source and written in Rust.\n\nLearn more about Neon [here](https://neon.tech/docs).\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/neon#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nMany aspects of using Prisma ORM with Neon are just like using Prisma ORM with any other PostgreSQL database. You can:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's [`postgresql` database connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) in your schema, along with the [connection string Neon provides you](https://neon.tech/docs/connect/connect-from-any-app)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a database schema on Neon\n*   use [`prisma migrate dev`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production) to track schema migrations in your Neon database\n*   use [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to Neon\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to communicate with the database hosted by Neon\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/neon#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a few differences between Neon and PostgreSQL you should be aware of the following when deciding to use Neon with Prisma ORM:\n\n*   **Neon's serverless model** — By default, Neon scales a [compute](https://neon.tech/docs/introduction/compute-lifecycle) to zero after 5 minutes of inactivity. During this state, a compute instance is in _idle_ state. A characteristic of this feature is the concept of a \"cold start\". Activating a compute from an idle state takes from 500ms to a few seconds. Depending on how long it takes to connect to your database, your application may timeout. To learn more, see: [Connection latency and timeouts](https://neon.tech/docs/guides/prisma#connection-timeouts).\n*   **Neon's connection pooler** — Neon offers connection pooling using PgBouncer, enabling up to 10,000 concurrent connections. To learn more, see: [Connection pooling](https://neon.tech/docs/connect/connection-pooling).\n\n## How to use Neon's connection pooling[​](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-connection-pooling \"Direct link to How to use Neon's connection pooling\")\n\nIf you would like to use the [connection pooling](https://neon.tech/docs/guides/prisma#use-connection-pooling-with-prisma) available in Neon, you will need to add `-pooler` in the hostname of your `DATABASE_URL` environment variable used in the `url` property of the `datasource` block of your Prisma schema:\n\n.env\n\n```\n# Connect to Neon with Pooling.DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417-pooler.us-east-2.aws.neon.tech:5432/neondb?sslmode=require\n```\n\nIf you would like to use Prisma CLI in order to perform other actions on your database (e.g. for migrations) you will need to add a `DIRECT_URL` environment variable to use in the `directUrl` property of the `datasource` block of your Prisma schema so that the CLI will use a direct connection string (without PgBouncer):\n\n.env\n\n```\n# Connect to Neon with Pooling.DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417-pooler.us-east-2.aws.neon.tech/neondb?sslmode=require# Direct connection to the database used by Prisma CLI for e.g. migrations.DIRECT_URL=\"postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\ninfo\n\nWe strongly recommend using the pooled connection string in your `DATABASE_URL` environment variable. You will gain the great developer experience of the Prisma CLI while also allowing for connections to be pooled regardless of deployment strategy. While this is not strictly necessary for every app, serverless solutions will inevitably require connection pooling.\n\n## Resolving connection timeouts[​](https://www.prisma.io/docs/orm/overview/databases/neon#resolving-connection-timeouts \"Direct link to Resolving connection timeouts\")\n\nA connection timeout that occurs when connecting from Prisma ORM to Neon causes an error similar to the following:\n\n```\nError: P1001: Can't reach database server at `ep-white-thunder-826300.us-east-2.aws.neon.tech`:`5432`Please make sure your database server is running at `ep-white-thunder-826300.us-east-2.aws.neon.tech`:`5432`.\n```\n\nThis error most likely means that the connection created by Prisma Client timed out before the Neon compute was activated.\n\nA Neon compute has two main states: _Active_ and _Idle_. Active means that the compute is currently running. If there is no query activity for 5 minutes, Neon places a compute into an idle state by default. Refer to Neon's docs to [learn more](https://neon.tech/docs/introduction/compute-lifecycle).\n\nWhen you connect to an idle compute from Prisma ORM, Neon automatically activates it. Activation typically happens within a few seconds but added latency can result in a connection timeout. To address this issue, your can adjust your Neon connection string by adding a `connect_timeout` parameter. This parameter defines the maximum number of seconds to wait for a new connection to be opened. The default value is 5 seconds. A higher setting should provide the time required to avoid connection timeout issues. For example:\n\n```\nDATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb?connect_timeout=10\n```\n\ninfo\n\nA `connect_timeout` setting of 0 means no timeout.\n\nAnother possible cause of connection timeouts is Prisma ORM's [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool), which has a default timeout of 10 seconds. This is typically enough time for Neon, but if you are still experiencing connection timeouts, you can try increasing this limit (in addition to the `connect_timeout` setting described above) by setting the `pool_timeout` parameter to a higher value. For example:\n\n```\nDATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb?connect_timeout=15&pool_timeout=15\n```\n\n## How to use Neon's serverless driver with Prisma ORM (Preview)[​](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview \"Direct link to How to use Neon's serverless driver with Prisma ORM (Preview)\")\n\nThe [Neon serverless driver](https://github.com/neondatabase/serverless) is a low-latency Postgres driver for JavaScript and TypeScript that allows you to query data from serverless and edge environments over HTTP or WebSockets in place of TCP.\n\nYou can use Prisma ORM along with the Neon serverless driver using a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) . A driver adapter allows you to use a different database driver from the default Prisma ORM provides to communicate with your database.\n\ninfo\n\nThis feature is available in Preview from Prisma ORM versions 5.4.2 and later.\n\nTo get started, enable the `driverAdapters` Preview feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nGenerate Prisma Client:\n\nInstall the Prisma ORM adapter for Neon, Neon serverless driver and `ws` packages:\n\n```\nnpm install @prisma/adapter-neon @neondatabase/serverless wsnpm install --save-dev @types/ws\n```\n\nUpdate your Prisma Client instance:\n\n```\nimport { Pool, neonConfig } from '@neondatabase/serverless'import { PrismaNeon } from '@prisma/adapter-neon'import { PrismaClient } from '@prisma/client'import dotenv from 'dotenv'import ws from 'ws'dotenv.config()neonConfig.webSocketConstructor = wsconst connectionString = `${process.env.DATABASE_URL}`const pool = new Pool({ connectionString })const adapter = new PrismaNeon(pool)const prisma = new PrismaClient({ adapter })\n```\n\nYou can then use Prisma Client as you normally would with full type-safety. Prisma Migrate, introspection, and Prisma Studio will continue working as before, using the connection string defined in the Prisma schema.\n\n### Notes[​](https://www.prisma.io/docs/orm/overview/databases/neon#notes \"Direct link to Notes\")\n\n#### Specifying a PostgreSQL schema[​](https://www.prisma.io/docs/orm/overview/databases/neon#specifying-a-postgresql-schema \"Direct link to Specifying a PostgreSQL schema\")\n\nYou can specify a [PostgreSQL schema](https://www.postgresql.org/docs/current/ddl-schemas.html) by passing in the `schema` option when instantiating `PrismaNeon`:\n\n```\nconst adapter = new PrismaNeon(pool, {  schema: 'myPostgresSchema'})\n```",
    "title": "Neon | Prisma Documentation",
    "description": "Guide to Neon",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1",
    "markdown": "# Cloudflare D1 | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Cloudflare D1, explains the commonalities and differences between Cloudflare D1 and other database providers, and leads you through the process for configuring your application to integrate with Cloudflare D1.\n\nPrisma ORM support for Cloudflare D1 is currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview). We would appreciate your feedback [on GitHub](https://github.com/prisma/prisma/discussions/23646).\n\nIf you want to deploy a Cloudflare Worker with D1 and Prisma ORM, follow this [tutorial](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1).\n\n## What is Cloudflare D1?[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#what-is-cloudflare-d1 \"Direct link to What is Cloudflare D1?\")\n\nD1 is Cloudflare's native serverless database and was initially [launched in 2022](https://blog.cloudflare.com/introducing-d1). It's based on SQLite and can be used when deploying applications with Cloudflare.\n\nFollowing Cloudflare's principles of geographic distribution and bringing compute and data closer to application users, D1 supports automatic read-replication. It dynamically manages the number of database instances and locations of read-only replicas based on how many queries a database is getting, and from where.\n\nFor write-operations, queries travel to a single primary instance in order to propagate the changes to all read-replicas and ensure data consistency.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nD1 is based on SQLite.\n\nMany aspects of using Prisma ORM with D1 are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`sqlite` database connector](https://www.prisma.io/docs/orm/overview/databases/sqlite) in your schema\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at D1\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a number of differences between D1 and SQLite to consider. You should be aware of the following when deciding to use D1 and Prisma ORM:\n\n*   **Local and remote D1 (SQLite) databases**. Cloudflare provides local and remote versions of D1. The [local](https://developers.cloudflare.com/d1/configuration/local-development) version is managed using the `--local` option of the `wrangler d1` CLI and is located in `.wrangler/state`. The [remote](https://developers.cloudflare.com/d1/configuration/remote-development) version is managed by Cloudflare and is accessed via HTTP.\n*   **Making schema changes**. Since D1 uses HTTP to connect to the remote database, this makes it incompatible with some commands of Prisma Migrate, like `prisma migrate dev`. However, you can use D1's [migration system](https://developers.cloudflare.com/d1/reference/migrations/) and the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command for your migration workflows. See the [Migration workflows](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows) below for more information.\n\n## How to connect to D1 in Cloudflare Workers or Cloudflare Pages[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#how-to-connect-to-d1-in-cloudflare-workers-or-cloudflare-pages \"Direct link to How to connect to D1 in Cloudflare Workers or Cloudflare Pages\")\n\nWhen using Prisma ORM with D1, you need to use the `sqlite` database provider and the `@prisma/adapter-d1` [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters).\n\nIf you want to deploy a Cloudflare Worker with D1 and Prisma ORM, follow these [step-by-step instructions](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1).\n\n## Migration workflows[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows \"Direct link to Migration workflows\")\n\nCloudflare D1 comes with its own [migration system](https://developers.cloudflare.com/d1/reference/migrations/). We recommend that you use this migration system via the `wrangler d1 migrations` command to create and manage migration files on your file system.\n\nThis command doesn't help you in figuring out the SQL statements for creating your database schema that need to be put _inside_ of these migration files though. If you want to query your database using Prisma Client, it's important that your database schema maps to your Prisma schema, this is why it's recommended to generate the SQL statements from your Prisma schema.\n\nWhen using D1, you can use the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command for that purpose.\n\n### Creating an initial migration[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#creating-an-initial-migration \"Direct link to Creating an initial migration\")\n\nThe workflow for creating an initial migration looks as follows. Assume you have a fresh D1 instance without any tables.\n\n#### 1\\. Update your Prisma data model[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#1-update-your-prisma-data-model \"Direct link to 1. Update your Prisma data model\")\n\nThis is your initial version of the Prisma schema that you want to map to your D1 instance:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\n#### 2\\. Create migration file using `wrangler` CLI[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#2-create-migration-file-using-wrangler-cli \"Direct link to 2-create-migration-file-using-wrangler-cli\")\n\nNext, you need to create the migration file using the [`wrangler d1 migrations create`](https://developers.cloudflare.com/workers/wrangler/commands/#migrations-create) command:\n\n```\nnpx wrangler d1 migrations create __YOUR_DATABASE_NAME__ create_user_table\n```\n\nSince this is the very first migration, this command will prompt you to also create a `migrations` folder. Note that if you want your migration files to be stored in a different location, you can [customize it using Wrangler](https://developers.cloudflare.com/d1/reference/migrations/#wrangler-customizations).\n\nOnce the command has executed and assuming you have chosen the default `migrations` name for the location of your migration files, the command has created the following folder and file for you:\n\n```\nmigrations/└── 0001_create_user_table.sql\n```\n\nHowever, before you can apply the migration to your D1 instance, you actually need to put a SQL statement into the currently empty `0001_create_user_table.sql` file.\n\n#### 3\\. Generate SQL statements using `prisma migrate diff`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#3-generate-sql-statements-using-prisma-migrate-diff \"Direct link to 3-generate-sql-statements-using-prisma-migrate-diff\")\n\nTo generate the initial SQL statement, you can use the `prisma migrate diff` command which compares to _schemas_ (via its `--to-X` and `--from-X` options) and generates the steps that are needed to \"evolve\" from one to the other. These schemas can be either Prisma or SQL schemas.\n\nFor the initial migration, you can use the special `--from-empty` option though:\n\n```\nnpx prisma migrate diff \\  --from-empty \\  --to-schema-datamodel ./prisma/schema.prisma \\  --script \\  --output migrations/0001_create_user_table.sql\n```\n\nThe command above uses the following options:\n\n*   `--from-empty`: The source for the SQL statement is an empty schema.\n*   `--to-schema-datamodel ./prisma/schema.prisma`: The target for the SQL statement is the data model in `./prisma/schema.prisma`.\n*   `--script`: Output the result as SQL. If you omit this option, the \"migration steps\" will be generated in plain English.\n*   `--output migrations/0001_create_user_table.sql`: Store the result in `migrations/0001_create_user_table.sql`.\n\nAfter running this command, `migrations/0001_create_user_table.sql` will have the following contents:\n\nmigrations/0001\\_create\\_user\\_table.sql\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL,    \"name\" TEXT);-- CreateIndexCREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n```\n\n#### 4\\. Execute the migration using `wrangler d1 migrations apply`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#4-execute-the-migration-using-wrangler-d1-migrations-apply \"Direct link to 4-execute-the-migration-using-wrangler-d1-migrations-apply\")\n\nFinally, you can apply the migration against your D1 instances.\n\nFor the **local** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --local\n```\n\nFor the **remote** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --remote\n```\n\n### Evolve your schema with further migrations[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#evolve-your-schema-with-further-migrations \"Direct link to Evolve your schema with further migrations\")\n\nFor any further migrations, you can use the same workflow but instead of using `--from-empty`, you'll need to use `--from-local-d1` because your source schema for the `prisma migrate diff` command now is the current schema of that local D1 instance, while the target remains your (then updated) Prisma schema.\n\n#### 1\\. Update your Prisma data model[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#1-update-your-prisma-data-model-1 \"Direct link to 1. Update your Prisma data model\")\n\nAssume you have updated your Prisma schema with another model:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}model Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id])  authorId Int}\n```\n\n#### 2\\. Create migration file using `wrangler` CLI[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#2-create-migration-file-using-wrangler-cli-1 \"Direct link to 2-create-migration-file-using-wrangler-cli-1\")\n\nLike before, you first need to create the migration file:\n\n```\nnpx wrangler d1 migrations create __YOUR_DATABASE_NAME__ create_post_table\n```\n\nOnce the command has executed (again assuming you have chosen the default `migrations` name for the location of your migration files), the command has created a new file inside of the `migrations` folder:\n\n```\nmigrations/├── 0001_create_user_table.sql└── 0002_create_post_table.sql\n```\n\nAs before, you now need to put a SQL statement into the currently empty `0002_create_post_table.sql` file.\n\n#### 3\\. Generate SQL statements using `prisma migrate diff`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#3-generate-sql-statements-using-prisma-migrate-diff-1 \"Direct link to 3-generate-sql-statements-using-prisma-migrate-diff-1\")\n\nAs explained above, you now need to use `--from-local-d1` instead of `--from-empty` to specify a source schema:\n\n```\nnpx prisma migrate diff \\  --from-local-d1 \\  --to-schema-datamodel ./prisma/schema.prisma \\  --script \\  --output migrations/0002_create_post_table.sql\n```\n\nThe command above uses the following options:\n\n*   `--from-local-d1`: The source for the SQL statement is the local D1 database file.\n*   `--to-schema-datamodel ./prisma/schema.prisma`: The target for the SQL statement is the data model in `./prisma/schema.prisma`.\n*   `--script`: Output the result as SQL. If you omit this option, the \"migration steps\" will be generated in plain English.\n*   `--output migrations/0002_create_post_table.sql`: Store the result in `migrations/0002_create_post_table.sql`.\n\nAfter running this command, `migrations/0002_create_post_table.sql` will have the following contents:\n\nmigrations/0002\\_create\\_post\\_table.sql\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"title\" TEXT NOT NULL,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_authorId_fkey\" FOREIGN KEY (\"authorId\") REFERENCES \"User\" (\"id\") ON DELETE RESTRICT ON UPDATE CASCADE);\n```\n\n#### 4\\. Execute the migration using `wrangler d1 migrations apply`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#4-execute-the-migration-using-wrangler-d1-migrations-apply-1 \"Direct link to 4-execute-the-migration-using-wrangler-d1-migrations-apply-1\")\n\nFinally, you can apply the migration against your D1 instances.\n\nFor the **local** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --local\n```\n\nFor the **remote** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --remote\n```",
    "title": "Cloudflare D1 | Prisma Documentation",
    "description": "Guide to Cloudflare D1",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources",
    "markdown": "# Data sources (Reference) | Prisma Documentation\n\nA data source determines how Prisma ORM connects your database, and is represented by the [`datasource`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) block in the Prisma schema. The following data source uses the `postgresql` provider and includes a connection URL:\n\nA Prisma schema can only have _one_ data source. However, you can:\n\nSome data source `provider`s allow you to configure your connection with SSL/TLS, and provide parameters for the `url` to specify the location of certificates.\n\nPrisma ORM resolves SSL certificates relative to the `./prisma` directory. If your certificate files are located outside that directory, e.g. your project root directory, use relative paths for certificates:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public&sslmode=require&sslcert=../server-ca.pem&sslidentity=../client-identity.p12&sslpassword=<REDACTED>\"}\n```",
    "title": "Data sources (Reference) | Prisma Documentation",
    "description": "Data sources enable Prisma to connect to your database. This page explains how to configure data sources in your Prisma schema.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/turso",
    "markdown": "# Turso (Early Access) | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Turso, explains the commonalities and differences between Turso and other database providers, and leads you through the process for configuring your application to integrate with Turso.\n\nPrisma ORM support for Turso is currently in [Early Access](https://www.prisma.io/docs/orm/more/releases#early-access). We would appreciate your feedback in this [GitHub discussion](https://github.com/prisma/prisma/discussions/21345).\n\n## What is Turso?[​](https://www.prisma.io/docs/orm/overview/databases/turso#what-is-turso \"Direct link to What is Turso?\")\n\n![Turso's logo](https://avatars.githubusercontent.com/u/139391156?s=200&v=4)\n\n[Turso](https://turso.tech/) is an edge-hosted, distributed database that's based on [libSQL](https://turso.tech/libsql), an open-source and open-contribution fork of [SQLite](https://sqlite.org/), enabling you to bring data closer to your application and minimize query latency. Turso can also be hosted on a remote server.\n\nwarning\n\nSupport for Turso is available in [Early Access](https://www.prisma.io/docs/orm/more/releases#early-access) from Prisma ORM versions 5.4.2 and later.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/turso#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nlibSQL is 100% compatible with SQLite. libSQL extends SQLite and adds the following features and capabilities:\n\n*   Support for replication\n*   Support for automated backups\n*   Ability to embed Turso as part of other programs such as the Linux kernel\n*   Supports user-defined functions\n*   Support for asynchronous I/O\n\n> To learn more about the differences between libSQL and how it is different from SQLite, see [libSQL Manifesto](https://turso.tech/libsql-manifesto).\n\nMany aspects of using Prisma ORM with Turso are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`sqlite` database connector](https://www.prisma.io/docs/orm/overview/databases/sqlite) in your schema\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at Turso\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/turso#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a number of differences between Turso and SQLite to consider. You should be aware of the following when deciding to use Turso and Prisma ORM:\n\n*   **Remote and embedded SQLite databases**. libSQL uses HTTP to connect to the remote SQLite database. libSQL also supports remote database replicas and embedded replicas. Embedded replicas enable you to replicate your primary database inside your application.\n*   **Making schema changes**. Since libSQL uses HTTP to connect to the remote database, this makes it incompatible with Prisma Migrate. However, you can use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to create a schema migration and then apply the changes to your database using [Turso's CLI](https://docs.turso.tech/reference/turso-cli).\n\n## How to connect and query a Turso database[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-and-query-a-turso-database \"Direct link to How to connect and query a Turso database\")\n\nThe subsequent section covers how you can create a Turso database, retrieve your database credentials and connect to your database.\n\n### How to provision a database and retrieve database credentials[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-provision-a-database-and-retrieve-database-credentials \"Direct link to How to provision a database and retrieve database credentials\")\n\ninfo\n\nEnsure that you have the [Turso CLI](https://docs.turso.tech/reference/turso-cli) installed to manage your databases.\n\nIf you don't have an existing database, you can provision a database by running the following command:\n\n```\nturso db create turso-prisma-db\n```\n\nThe above command will create a database in the closest region to your location.\n\nRun the following command to retrieve your database's connection string:\n\n```\nturso db show turso-prisma-db\n```\n\nNext, create an authentication token that will allow you to connect to the database:\n\n```\nturso db tokens create turso-prisma-db\n```\n\nUpdate your `.env` file with the authentication token and connection string:\n\n.env\n\n```\nTURSO_AUTH_TOKEN=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\"TURSO_DATABASE_URL=\"libsql://turso-prisma-db-user.turso.io\"\n```\n\n### How to connect to a Turso database[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-to-a-turso-database \"Direct link to How to connect to a Turso database\")\n\nTo get started, enable the `driverAdapters` Preview feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\nGenerate Prisma Client:\n\nInstall the libSQL database client and Prisma ORM driver adapter for libSQL packages:\n\n```\nnpm install @libsql/client @prisma/adapter-libsql\n```\n\nUpdate your Prisma Client instance:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaLibSQL } from '@prisma/adapter-libsql'import { createClient } from '@libsql/client'const libsql = createClient({  url: `${process.env.TURSO_DATABASE_URL}`,  authToken: `${process.env.TURSO_AUTH_TOKEN}`,})const adapter = new PrismaLibSQL(libsql)const prisma = new PrismaClient({ adapter })\n```\n\nYou can use Prisma Client as you normally would with full type-safety in your project.\n\n## How to manage schema changes[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-manage-schema-changes \"Direct link to How to manage schema changes\")\n\nPrisma Migrate and Introspection workflows are currently not supported when working with Turso. This is because Turso uses HTTP to connect to your database, which Prisma Migrate doesn't support.\n\nTo update your database schema:\n\n1.  Generate a migration file using `prisma migrate dev` against a local SQLite database:\n    \n    ```\n    npx prisma migrate dev --name init\n    ```\n    \n2.  Apply the migration using Turso's CLI:\n    \n    ```\n    turso db shell turso-prisma-db < ./prisma/migrations/20230922132717_init/migration.sql\n    ```\n    \n    info\n    \n    Replace `20230922132717_init` with the name of your migration.\n    \n\nFor subsequent migrations, repeat the above steps to apply changes to your database. This workflow does not support track the history of applied migrations to your remote database.\n\n## Embedded Turso database replicas[​](https://www.prisma.io/docs/orm/overview/databases/turso#embedded-turso-database-replicas \"Direct link to Embedded Turso database replicas\")\n\nTurso supports [embedded replicas](https://blog.turso.tech/introducing-embedded-replicas-deploy-turso-anywhere-2085aa0dc242). Turso's embedded replicas enable you to have a copy of your primary, remote database _inside_ your application. Embedded replicas behave similarly to a local SQLite database. Database queries are faster because your database is inside your application.\n\n### How embedded database replicas work[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-embedded-database-replicas-work \"Direct link to How embedded database replicas work\")\n\nWhen your app initially establishes a connection to your database, the primary database will fulfill the query:\n\n![Embedded Replica: First remote read](https://www.prisma.io/docs/assets/images/embedded-replica-remote-read-b62442c05d07a6fe77394a8db44611b1.png)\n\nTurso will (1) create an embedded replica inside your application and (2) copy data from your primary database to the replica so it is locally available:\n\n![Embedded Replica: Remote DB Copy](https://www.prisma.io/docs/assets/images/embedded-replica-create-replica-ef2238fff13051650ffb56ca40c2dd44.png)\n\nThe embedded replica will fulfill subsequent read queries. The libSQL client provides a [`sync()`](https://docs.turso.tech/libsql/client-access/javascript-typescript-sdk#client-capability-summary:~:text=an%20interactive%20transaction-,sync(),-Synchronize%20the%20embedded) method which you can invoke to ensure the embedded replica's data remains fresh.\n\n![Embedded Replica: Local DB reads](https://www.prisma.io/docs/assets/images/embedded-replica-read-dc917586761e34261c4eb49fde47faf0.png)\n\nWith embedded replicas, this setup guarantees a responsive application, because the data will be readily available locally and faster to access.\n\nLike a read replica setup you may be familiar with, write operations are forwarded to the primary remote database and executed before being propagated to all embedded replicas.\n\n![Embedded Replica: Write operation propagation](https://www.prisma.io/docs/assets/images/embedded-replica-write-propagation-24051b004c8d48bae1ecf952576275b9.png)\n\n1.  Write operations propagation are forwarded to the database.\n2.  Database responds to the server with the updates from 1.\n3.  Write operations are propagated to the database replica.\n\nYour application's data needs will determine how often you should synchronize data between your remote database and embedded database replica. For example, you can use either middleware functions (e.g. Express and Fastify) or a cron job to synchronize the data.\n\n### How to synchronize data between your remote database and embedded replica[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-synchronize-data-between-your-remote-database-and-embedded-replica \"Direct link to How to synchronize data between your remote database and embedded replica\")\n\nTo get started using embedded replicas with Prisma ORM, add the `sync()` method from libSQL in your application. The example below shows how you can synchronize data using Express middleware.\n\n```\nimport express from 'express'const app = express()// ... the rest of your application codeapp.use(async (req, res, next) => {  await libsql.sync()  next()})app.listen(3000, () => console.log(`Server ready at http://localhost:3000`))\n```",
    "title": "Turso (Early Access) | Prisma Documentation",
    "description": "Guide to Turso",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer",
    "markdown": "# Configure Prisma Client with PgBouncer\n\nAn external connection pooler like PgBouncer holds a connection pool to the database, and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time.\n\nUsually, this works transparently, but some connection poolers only support a limited set of functionality. One common feature that external connection poolers do not support are named prepared statements, which Prisma ORM uses. For these cases, Prisma ORM can be configured to behave differently.\n\n## PgBouncer[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer \"Direct link to PgBouncer\")\n\n### Set PgBouncer to transaction mode[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#set-pgbouncer-to-transaction-mode \"Direct link to Set PgBouncer to transaction mode\")\n\nFor Prisma Client to work reliably, PgBouncer must run in [**Transaction mode**](https://www.pgbouncer.org/features.html).\n\nTransaction mode offers a connection for every transaction – a requirement for the Prisma Client to work with PgBouncer.\n\n### Add `pgbouncer=true` to the connection URL[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#add-pgbouncertrue-to-the-connection-url \"Direct link to add-pgbouncertrue-to-the-connection-url\")\n\nTo use Prisma Client with PgBouncer, add the `?pgbouncer=true` flag to the PostgreSQL connection URL:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true\n```\n\n> Note: `PORT` specified for PgBouncer pooling is sometimes different from the default `5432` port. Check your database provider docs for the correct port number.\n\nHow `pgbouncer` mode works in Prisma ORM\n\n*   Prisma ORM opens a transaction for every query – even when just reading data, allowing Prisma to use prepared statements.\n*   Prisma ORM does not try to set the `search_path`, which is not supported by PgBouncer.\n*   Prisma ORM cleans up already present prepared statements in the connection by running `DEALLOCATE ALL` before preparing and executing Prisma Client queries.\n*   Prisma ORM also disables any prepared statement or type query caches.\n\n### Prisma Migrate and PgBouncer workaround[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#prisma-migrate-and-pgbouncer-workaround \"Direct link to Prisma Migrate and PgBouncer workaround\")\n\nPrisma Migrate uses **database transactions** to check out the current state of the database and the migrations table. However, the Schema Engine is designed to use a **single connection to the database**, and does not support connection pooling with PgBouncer. If you attempt to run Prisma Migrate commands in any environment that uses PgBouncer for connection pooling, you might see the following error:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nTo work around this issue, you must connect directly to the database rather than going through PgBouncer. To achieve this, you can use the [`directUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields) field in your [`datasource`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) block.\n\nFor example, consider the following `datasource` block:\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = \"postgres://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true\"  directUrl = \"postgres://USER:PASSWORD@HOST:PORT/DATABASE\"}\n```\n\nThe block above uses a PgBouncer connection string as the primary URL using `url`, allowing Prisma Client to take advantage of the PgBouncer connection pooler.\n\nIt also provides a connection string directly to the database, without PgBouncer, using the `directUrl` field. This connection string will be used when commands that require a single connection to the database, such as `prisma migrate dev` or `prisma db push`, are invoked.\n\n### PgBouncer with different database providers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer-with-different-database-providers \"Direct link to PgBouncer with different database providers\")\n\nThere are sometimes minor differences in how to connect directly to a Postgres database that depend on the provider hosting the database.\n\nBelow are links to information on how to set up these connections with providers who have setup steps not covered here in our documentation:\n\n*   [Connecting directly to a PostgreSQL database hosted on Digital Ocean](https://github.com/prisma/prisma/issues/6157)\n*   [Connecting directly to a PostgreSQL database hosted on ScaleGrid](https://github.com/prisma/prisma/issues/6701#issuecomment-824387959)\n\n## Supabase Supavisor[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#supabase-supavisor \"Direct link to Supabase Supavisor\")\n\nSupabase's Supavisor behaves similarly to [PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer). You can add `?pgbouncer=true` to your connection pooled connection string available via your [Supabase database settings](https://supabase.com/dashboard/project/_/settings/database).\n\n## Other external connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#other-external-connection-poolers \"Direct link to Other external connection poolers\")\n\nAlthough Prisma ORM does not have explicit support for other connection poolers, if the limitations are similar to the ones of [PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer) you can usually also use `pgbouncer=true` in your connection string to put Prisma ORM in a mode that works with them as well.",
    "title": "Configure Prisma Client with PgBouncer | Prisma Documentation",
    "description": "An external connection pooler like PgBouncer holds a connection pool to the database, and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema",
    "markdown": "# Prototyping your schema | Prisma Documentation\n\nThe Prisma CLI has a dedicated command for prototyping schemas: [`db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push)\n\n`db push` uses the same engine as Prisma Migrate to synchronize your Prisma schema with your database schema. The `db push` command:\n\n1.  Introspects the database to infer and executes the changes required to make your database schema reflect the state of your Prisma schema.\n    \n2.  By default, after changes have been applied to the database schema, generators are triggered (for example, Prisma Client). You do not need to manually invoke `prisma generate`.\n    \n3.  If `db push` anticipates that the changes could result in data loss, it will:\n    \n    *   Throw an error\n    *   Require the `--accept-data-loss` option if you still want to make the changes\n\n> **Notes**:\n> \n> *   `db push` does not interact with or rely on migrations. The migrations table `_prisma_migrations` will not be created or updated, and no migration files will be generated.\n> *   When working with PlanetScale, we recommend that you use `db push` instead of `migrate`. For details refer to our Getting Started documentation, either [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale) or [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-planetscale) depending on your situation.\n\n## Choosing `db push` or Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#choosing-db-push-or-prisma-migrate \"Direct link to choosing-db-push-or-prisma-migrate\")\n\n`db push` works well if:\n\n*   You want to **quickly prototype and iterate** on schema design locally without the need to deploy these changes to other environments such as other developers, or staging and production environments.\n*   You are prioritizing reaching a **desired end-state** and not the changes or steps executed to reach that end-state (there is no way to preview changes made by `db push`)\n*   You do not need to control how schema changes impact data. There is no way to orchestrate schema and data migrations—if `db push` anticipates that changes will result in data loss, you can either accept data loss with the `--accept-data-loss` option or stop the process. There is no way to customize the changes.\n\nSee [Schema prototyping with `db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) for an example of how to use `db push` in this way.\n\n`db push` is **not recommended** if:\n\n*   You want to replicate your schema changes in other environments without losing data. You can use `db push` for prototyping, but you should use migrations to commit the schema changes and apply these in your other environments.\n*   You want fine-grained control over how the schema changes are executed - for example, [renaming a column instead of dropping it and creating a new one](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-rename-a-field).\n*   You want to keep track of changes made to the database schema over time. `db push` does not create any artifacts that allow you to keep track of these changes.\n*   You want the schema changes to be reversible. You can use `db push` again to revert to the original state, but this might result in data loss.\n\n## Can I use Prisma Migrate and `db push` together?[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#can-i-use-prisma-migrate-and-db-push-together \"Direct link to can-i-use-prisma-migrate-and-db-push-together\")\n\nYes, you can [use `db push` and Prisma Migrate together in your development workflow](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) . For example, you can:\n\n*   Use `db push` to prototype a schema at the start of a project and initialize a migration history when you are happy with the first draft\n*   Use `db push` to prototype a change to an existing schema, then run `prisma migrate dev` to generate a migration from your changes (you will be asked to reset)\n\n## Prototyping a new schema[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#prototyping-a-new-schema \"Direct link to Prototyping a new schema\")\n\nThe following scenario demonstrates how to use `db push` to synchronize a new schema with an empty database, and evolve that schema - including what happens when `db push` detects that a change will result in data loss.\n\n1.  Create a first draft of your schema:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id       Int      @id @default(autoincrement())  name     String  jobTitle String  posts    Post[]  profile  Profile?}model Profile {  id       Int    @id @default(autoincrement())  biograpy String // Intentional typo!  userId   Int    @unique  user     User   @relation(fields: [userId], references: [id])}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  content    String     @db.VarChar(500)  authorId   Int  author     User       @relation(fields: [authorId], references: [id])  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @db.VarChar(50)  posts Post[]  @@unique([name])}\n    ```\n    \n2.  Use `db push` to push the initial schema to the database:\n    \n3.  Create some example content:\n    \n    ```\n    const add = await prisma.user.create({  data: {    name: 'Eloise',    jobTitle: 'Programmer',    posts: {      create: {        title: 'How to create a MySQL database',        content: 'Some content',      },    },  },})\n    ```\n    \n4.  Make an additive change - for example, create a new required field:\n    \n    ```\n    // ... //model Post {  id          Int        @id @default(autoincrement())  title       String  description String  published   Boolean    @default(true)  content     String     @db.VarChar(500)  authorId    Int  author      User       @relation(fields: [authorId], references: [id])  categories  Category[]}// ... //\n    ```\n    \n5.  Push the changes:\n    \n    `db push` will prompt you to reset because you cannot add a required field to a table with existing content unless you provide a default value:\n    \n    ```\n    ⚠️ We found changes that cannot be executed:• Added the required column `description` to the `Post` table without a default value. There are 2 rows in this table, it is not possible to execute this.? To apply this step we need to reset the database, do you want to continue? All data will be lost. » (y/N)\n    ```\n    \n\ntip\n\nUse the `--accept-data-loss` flag to skip this warning, or `--force-reset` to ignore all warnings.\n\n6.  Confirm data loss and apply changes to your database (or revisit your schema):\n    \n    ```\n     There might be data loss when applying the changes: • Added the required column `description` to the `Post` table without a default value. ? Do you want to ignore the warning(s)? Some data will be lost. » (y/N)\n    ```\n    \n    > **Note**: Unlike Prisma Migrate, `db push` does not generate migrations that you can modify to preserve data, and is therefore best suited for prototyping in a development environment.\n    \n7.  Continue to evolve your schema until it reaches a relatively stable state.\n    \n8.  Initialize a migration history:\n    \n    ```\n    npx prisma migrate dev --name initial-state\n    ```\n    \n    The steps taken to reach the initial prototype are not preserved - `db push` does not generate a history.\n    \n9.  Push your migration history and Prisma schema to source control (e.g. Git).\n    \n\nAt this point, the final draft of your prototyping is preserved in a migration and can be pushed to other environments (testing, production, or other members of your team).\n\n## Prototyping with an existing migration history[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#prototyping-with-an-existing-migration-history \"Direct link to Prototyping with an existing migration history\")\n\nThe following scenario demonstrates how to use `db push` to prototype a change to a Prisma schema where a migration history already exists.\n\n1.  Check out the latest Prisma schema and migration history:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id       Int      @id @default(autoincrement())  name     String  jobTitle String  posts    Post[]  profile  Profile?}model Profile {  id       Int    @id @default(autoincrement())  biograpy String // Intentional typo!  userId   Int    @unique  user     User   @relation(fields: [userId], references: [id])}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  content    String     @db.VarChar(500)  authorId   Int  author     User       @relation(fields: [authorId], references: [id])  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @db.VarChar(50)  posts Post[]  @@unique([name])}\n    ```\n    \n2.  Prototype your new feature, which can involve any number of steps. For example, you might:\n    \n    *   Create a `tags String[]` field, then run `db push`\n    *   Change the field type to `tags Tag[]` and add a new model named `Tag`, then run `db push`\n    *   Change your mind and restore the original `tags String[]` field, then call `db push`\n    *   Make a manual change to the `tags` field in the database - for example, adding a constraint\n    \n    After experimenting with several solutions, the final schema change looks like this:\n    \n    ```\n    model Post {  id          Int        @id @default(autoincrement())  title       String  description String  published   Boolean    @default(true)  content     String     @db.VarChar(500)  authorId    Int  author      User       @relation(fields: [authorId], references: [id])  categories  Category[]  tags        String[]}\n    ```\n    \n3.  To create a migration that adds the new `tags` field, run the `migrate dev` command:\n    \n    ```\n    npx prisma migrate dev --name added-tags\n    ```\n    \n    Prisma Migrate will prompt you to reset because the changes you made manually and with `db push` while prototyping are not part of the migration history:\n    \n    ```\n    √ Drift detected: Your database schema is not in sync with your migration history.We need to reset the PostgreSQL database \"prototyping\" at \"localhost:5432\".Do you want to continue? All data will be lost. ... yes\n    ```\n    \n4.  Prisma Migrate replays the existing migration history, generates a new migration based on your schema changes, and applies those changes to the database.\n    \n\ntip\n\nWhen using `migrate dev`, if your schema changes mean that seed scripts will no longer work, you can use the `--skip-seed` flag to ignore seed scripts.\n\nAt this point, the final result of your prototyping is preserved in a migration, and can be pushed to other environments (testing, production, or other members of your team).",
    "title": "Prototyping your schema | Prisma Documentation",
    "description": "Prototyping your schema",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool",
    "markdown": "# Connection pool | Prisma Documentation\n\nThe query engine manages a **connection pool** of database connections. The pool is created when Prisma Client opens the _first_ connection to the database, which can happen in one of two ways:\n\n*   By [explicitly calling `$connect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#connect) _or_\n*   By running the first query, which calls `$connect()` under the hood\n\nRelational database connectors use Prisma ORM's own connection pool, and the MongoDB connectors uses the [MongoDB driver connection pool](https://github.com/mongodb/specifications/blob/master/source/connection-monitoring-and-pooling/connection-monitoring-and-pooling.rst).\n\n## Relational databases[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#relational-databases \"Direct link to Relational databases\")\n\nThe relational database connectors use Prisma ORM's connection pool. The connection pool has a **connection limit** and a **pool timeout**, which are controlled by connection URL parameters.\n\n### How the connection pool works[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#how-the-connection-pool-works \"Direct link to How the connection pool works\")\n\nThe following steps describe how the query engine uses the connection pool:\n\n1.  The query engine instantiates a connection pool with a [configurable pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size) and [pool timeout](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-timeout).\n2.  The query engine creates one connection and adds it to the connection pool.\n3.  When a query comes in, the query engine reserves a connection from the pool to process query.\n4.  If there are no idle connections available in the connection pool, the query engine opens additional database connections and adds them to the connection pool until the number of database connections reaches the limit defined by `connection_limit`.\n5.  If the query engine cannot reserve a connection from the pool, queries are added to a FIFO (First In First Out) queue in memory. FIFO means that queries are processed in the order they enter the queue.\n6.  If the query engine cannot process a query in the queue for **before the [time limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-pool-timeout)**, it throws an exception with error code `P2024` for that query and moves on to the next one in the queue.\n\nIf you consistently experience pool timeout errors, you need to [optimize the connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool) .\n\n### Connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#connection-pool-size \"Direct link to Connection pool size\")\n\n#### Default connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-connection-pool-size \"Direct link to Default connection pool size\")\n\nThe default number of connections (pool size) is calculated with the following formula:\n\n```\nnum_physical_cpus * 2 + 1\n```\n\n`num_physical_cpus` represents the number of physical CPUs on the machine your application is running on. If your machine has **four** physical CPUs, your connection pool will contain **nine** connections (`4 * 2 + 1 = 9`).\n\nAlthough the formula represents a good starting point, the [recommended connection limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size) also depends on your deployment paradigm - particularly if you are using serverless.\n\n#### Setting the connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size \"Direct link to Setting the connection pool size\")\n\nYou can specify the number of connections by explicitly setting the `connection_limit` parameter in your database connection URL. For example, with the following `datasource` configuration in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) the connection pool will have exactly five connections:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5\"}\n```\n\n#### Viewing the connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#viewing-the-connection-pool-size \"Direct link to Viewing the connection pool size\")\n\nThe number of connections Prisma Client uses can be viewed using [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) and [metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics).\n\nUsing the `info` [logging level](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-levels), you can log the number of connections in a connection pool that are opened when Prisma Client is instantiated.\n\nFor example, consider the following Prisma Client instance and invocation:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  log: ['info'],})async function main() {  await prisma.user.findMany()}main()\n```\n\nWhen the `PrismaClient` class was instantiated, the logging notified `stdout` that a connection pool with 21 connections was started.\n\nwarning\n\nNote that the output generated by `log: ['info']` can change in any release without notice. Be aware of this in case you are relying on the output in your application or a tool that you're building.\n\nIf you need even more insights into the size of your connection pool and the amount of in-use and idle connection, you can use the [metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) feature (which is currently in Preview).\n\nConsider the following example:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  await Promise.all([prisma.user.findMany(), prisma.post.findMany()])  const metrics = await prisma.$metrics.json()  console.dir(metrics, { depth: Infinity })}main()\n```\n\ninfo\n\nFor more details on what is available in the metrics output, see the [About metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics#about-metrics) section.\n\n### Connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#connection-pool-timeout \"Direct link to Connection pool timeout\")\n\n#### Default pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-pool-timeout \"Direct link to Default pool timeout\")\n\nThe default connection pool timeout is 10 seconds. If the Query Engine does not get a connection from the database connection pool within that time, it throws an exception and moves on to the next query in the queue.\n\n#### Setting the connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-timeout \"Direct link to Setting the connection pool timeout\")\n\nYou can specify the pool timeout by explicitly setting the `pool_timeout` parameter in your database connection URL. In the following example, the pool times out after `2` seconds:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=2\"}\n```\n\n#### Disabling the connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#disabling-the-connection-pool-timeout \"Direct link to Disabling the connection pool timeout\")\n\nYou disable the connection pool timeout by setting the `pool_timeout` parameter to `0`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=0\"}\n```\n\nYou can choose to [disable the connection pool timeout if queries **must** remain in the queue](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#disabling-the-pool-timeout) - for example, if you are importing a large number of records in parallel and are confident that the queue will not use up all available RAM before the job is complete.\n\n## MongoDB[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#mongodb \"Direct link to MongoDB\")\n\nThe MongoDB connector does not use the Prisma ORM connection pool. The connection pool is managed internally by the MongoDB driver and [configured via connection string parameters](https://docs.mongodb.com/manual/reference/connection-string/#connection-pool-options).\n\n## External connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#external-connection-poolers \"Direct link to External connection poolers\")\n\nYou cannot increase the `connection_limit` beyond what the underlying database can support. This is a particular challenge in serverless environments, where each function manages an instance of `PrismaClient` - and its own connection pool.\n\nConsider introducing [an external connection pooler like PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#pgbouncer) to prevent your application or functions from exhausting the database connection limit.\n\n## Manual database connection handling[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#manual-database-connection-handling \"Direct link to Manual database connection handling\")\n\nWhen using Prisma ORM, the database connections are handled on an [engine](https://github.com/prisma/prisma-engines)\\-level. This means they're not exposed to the developer and it's not possible to manually access them.",
    "title": "Connection pool | Prisma Documentation",
    "description": "Prisma ORM's query engine creates a connection pool to store and manage database connections.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features",
    "markdown": "# Prisma schema: Unsupported database features\n\nNot all database functions and features of Prisma ORM's supported databases have a Prisma Schema Language equivalent. Refer to the [database features matrix](https://www.prisma.io/docs/orm/reference/database-features) for a complete list of supported features.\n\n## Native database functions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#native-database-functions \"Direct link to Native database functions\")\n\nPrisma Schema Language supports several [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions) that you can use to set the default value of a field. The following example uses the Prisma ORM-level `uuid()` function to set the value of the `id` field:\n\n```\nmodel Post {  id String @id @default(uuid())}\n```\n\nHowever, you can also use **native database functions** to define default values with [`dbgenerated(...)`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated) on relational databases (MongoDB does not have the concept of database-level functions). The following example uses the PostgreSQL `gen_random_uuid()` function to populate the `id` field:\n\n```\nmodel User {  id String @id @default(dbgenerated(\"gen_random_uuid()\")) @db.Uuid}\n```\n\n### When to use a database-level function[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#when-to-use-a-database-level-function \"Direct link to When to use a database-level function\")\n\nThere are two reasons to use a database-level function:\n\n*   There is no equivalent Prisma ORM function (for example, `gen_random_bytes` in PostgreSQL).\n    \n*   You cannot or do not want to rely on functions such `uuid()` and `cuid()`, which are only implemented at a Prisma ORM level and do not manifest in the database.\n    \n    Consider the following example, which sets the `id` field to a randomly generated `UUID`:\n    \n    ```\n    model Post {  id String @id @default(uuid())}\n    ```\n    \n    The UUID is _only_ generated if you use Prisma Client to create the `Post`. If you create posts in any other way, such as a bulk import script written in plain SQL, you must generate the UUID yourself.\n    \n\n### Enable PostgreSQL extensions for native database functions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#enable-postgresql-extensions-for-native-database-functions \"Direct link to Enable PostgreSQL extensions for native database functions\")\n\nIn PostgreSQL, some native database functions are part of an extension. For example, in PostgreSQL versions 12.13 and earlier, the `gen_random_uuid()` function is part of the [`pgcrypto`](https://www.postgresql.org/docs/10/pgcrypto.html) extension.\n\nTo use a PostgreSQL extension, you must first install it on the file system of your database server.\n\nIn Prisma ORM versions 4.5.0 and later, you can then activate the extension by declaring it in your Prisma schema with the [`postgresqlExtensions` preview feature](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions):\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"postgresqlExtensions\"]}datasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [pgcrypto]}\n```\n\nIn earlier versions of Prisma ORM, you must instead run a SQL command to activate the extension:\n\n```\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n```\n\nIf your project uses [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you must [install the extension as part of a migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions) . Do not install the extension manually, because it is also required by the shadow database.\n\nPrisma Migrate returns the following error if the extension is not available:\n\n```\nMigration `20210221102106_failed_migration` failed to apply cleanly to a temporary database.Database error: Error querying the database: db error: ERROR: type \"pgcrypto\" does not exist\n```\n\n## Unsupported field types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-field-types \"Direct link to Unsupported field types\")\n\nSome database types of relational databases, such as `polygon` or `geometry`, do not have a Prisma Schema Language equivalent. Use the [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) field type to represent the field in your Prisma schema:\n\n```\nmodel Star {  id       Int                    @id @default(autoincrement())  position Unsupported(\"circle\")? @default(dbgenerated(\"'<(10,4),11>'::circle\"))}\n```\n\nThe `prisma migrate dev` and `prisma db push` command will both create a `position` field of type `circle` in the database. However, the field will not be available in the generated Prisma Client.\n\n## Unsupported database features[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-database-features \"Direct link to Unsupported database features\")\n\nSome features, like SQL views or partial indexes, cannot be represented in the Prisma schema. If your project uses [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you must [include unsupported features as part of a migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/unsupported-database-features) .",
    "title": "Prisma schema: Unsupported database features | Prisma Documentation",
    "description": "How to support database features that do not have an equivalent syntax in Prisma Schema Language.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/under-the-hood/engines",
    "markdown": "# Engines | Prisma Documentation\n\nFrom a technical perspective, Prisma Client consists of three major components:\n\n*   JavaScript client library\n*   TypeScript type definitions\n*   A query engine\n\nAll of these components are located in the [generated `.prisma/client` folder](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) after you ran `prisma generate`.\n\nThis page covers relevant technical details about the query engine.\n\n## Prisma engines[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#prisma-engines \"Direct link to Prisma engines\")\n\nAt the core of each module, there typically is a [Prisma engine](https://github.com/prisma/prisma-engines) that implements the core set of functionality. Engines are implemented in [Rust](https://www.rust-lang.org/) and expose a low-level API that is used by the higher-level interfaces.\n\nA Prisma engine is the **direct interface to the database**, any higher-level interfaces always communicate with the database _through_ the engine-layer.\n\nAs an example, Prisma Client connects to the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) in order to read and write data in a database:\n\n![Prisma engine](https://www.prisma.io/docs/assets/images/typical-flow-query-engine-at-runtime-73ffdee4acc20a853bbd431dc12fb64f.png)\n\n### Using custom engine libraries or binaries[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#using-custom-engine-libraries-or-binaries \"Direct link to Using custom engine libraries or binaries\")\n\nBy default, all engine files are automatically downloaded into the `node_modules/@prisma/engines` folder when you install or update `prisma`, the Prisma CLI package. The [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) is also copied to the generated Prisma Client when you call `prisma generate`. You might want to use a [custom library or binary](https://github.com/prisma/prisma-engines) file if:\n\n*   Automated download of engine files is not possible.\n*   You have created your own engine library or binary for testing purposes, or for an OS that is not officially supported.\n\nUse the following environment variables to specify custom locations for your binaries:\n\n*   [`PRISMA_QUERY_ENGINE_LIBRARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_library) (Query engine, library)\n*   [`PRISMA_QUERY_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_binary) (Query engine, binary)\n*   [`PRISMA_SCHEMA_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_schema_engine_binary) (Schema engine)\n*   [`PRISMA_MIGRATION_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_migration_engine_binary) (Migration engine)\n*   [`PRISMA_INTROSPECTION_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_introspection_engine_binary) (Introspection engine)\n\nwarning\n\n*   `PRISMA_MIGRATION_ENGINE_BINARY` variable is deprecated in [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0).\n*   The Introspection Engine is served by the Migration Engine from [4.9.0](https://github.com/prisma/prisma/releases/tag/4.9.0). Therefore, the `PRISMA_INTROSPECTION_ENGINE` environment variable will not be used.\n*   The `PRISMA_FMT_BINARY` variable is used in versions [4.2.0](https://github.com/prisma/prisma/releases/tag/4.2.0) or lower.\n\n#### Setting the environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#setting-the-environment-variable \"Direct link to Setting the environment variable\")\n\nYou can define environment variables globally on your machine or in the `.env` file.\n\n##### a) The `.env` file[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#a-the-env-file \"Direct link to a-the-env-file\")\n\nAdd the environment variable to the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files).\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nPRISMA_QUERY_ENGINE_BINARY=custom/my-query-engine-unix\n```\n\n> **Note**: It is possible to [use an `.env` file in a location outside the `prisma` folder](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables).\n\n##### b) Global environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#b-global-environment-variable \"Direct link to b) Global environment variable\")\n\nRun the following command to set the environment variable globally (in this example, `PRISMA_QUERY_ENGINE_BINARY`):\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nexport PRISMA_QUERY_ENGINE_BINARY=/custom/my-query-engine-unix\n```\n\n#### Test your environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#test-your-environment-variable \"Direct link to Test your environment variable\")\n\nRun the following command to output the paths to all binaries:\n\nThe output shows that the query engine path comes from the `PRISMA_QUERY_ENGINE_BINARY` environment variable:\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nCurrent platform     : darwinQuery Engine         : query-engine d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /custom/my-query-engine-unix)Migration Engine     : migration-engine-cli d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /myproject/node_modules/@prisma/engines/migration-engine-unix)Introspection Engine : introspection-core d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /myproject/node_modules/@prisma/engines/introspection-engine-unix)\n```\n\n### Hosting engines[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#hosting-engines \"Direct link to Hosting engines\")\n\nThe [`PRISMA_ENGINES_MIRROR`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_engines_mirror) environment variable allows you to host engine files via a private server, AWS bucket or other cloud storage. This can be useful if you have a custom OS that requires custom-built engines.\n\n```\nPRISMA_ENGINES_MIRROR=https://my-aws-bucket\n```\n\n## The query engine file[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-file \"Direct link to The query engine file\")\n\nThe **query engine file** is different for each operating system. It is named `query-engine-PLATFORM` or `libquery_engine-PLATFORM` where `PLATFORM` corresponds to the name of a compile target. Query engine file extensions depend on the platform as well. As an example, if the query engine must run on a [Darwin](https://en.wikipedia.org/wiki/Darwin_(operating_system)) operating system such as macOS Intel, it is called `libquery_engine-darwin.dylib.node` or `query-engine-darwin`. You can find an overview of all supported platforms [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options).\n\nThe query engine file is downloaded into the `runtime` directory of the generated Prisma Client when `prisma generate` is called.\n\nNote that the query engine is implemented in Rust. The source code is located in the [`prisma-engines`](https://github.com/prisma/prisma-engines/) repository.\n\n## The query engine at runtime[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime \"Direct link to The query engine at runtime\")\n\nBy default, Prisma Client loads the query engine as a [Node-API library](https://nodejs.org/api/n-api.html). You can alternatively [configure Prisma to use the query engine compiled as an executable binary](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine), which is run as a sidecar process alongside your application. The Node-API library approach is recommended since it reduces the communication overhead between Prisma Client and the query engine.\n\n![Diagram showing the query engine and Node.js at runtime](https://www.prisma.io/docs/assets/images/query-engine-node-js-at-runtime-462396e7623f826c6b070819fd061c92.png)\n\nThe query engine is started when the first Prisma Client query is invoked or when the [`$connect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) method is called on your `PrismaClient` instance. Once the query engine is started, it creates a [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool) and manages the physical connections to the database. From that point onwards, Prisma Client is ready to send [queries](https://www.prisma.io/docs/orm/prisma-client/queries/crud) to the database (e.g. `findUnique()`, `findMany`, `create`, ...).\n\nThe query engine is stopped and the database connections are closed when [`$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) is invoked.\n\nThe following diagram depicts a \"typical flow\":\n\n1.  `$connect()` is invoked on Prisma Client\n2.  The query engine is started\n3.  The query engine establishes connections to the database and creates connection pool\n4.  Prisma Client is now ready to send queries to the database\n5.  Prisma Client sends a `findMany()` query to the query engine\n6.  The query engine translates the query into SQL and sends it to the database\n7.  The query engine receives the SQL response from the database\n8.  The query engine returns the result as plain old JavaScript objects to Prisma Client\n9.  `$disconnect()` is invoked on Prisma Client\n10.  The query engine closes the database connections\n11.  The query engine is stopped\n\n![Typical flow of the query engine at run time](https://www.prisma.io/docs/assets/images/typical-flow-query-engine-at-runtime-73ffdee4acc20a853bbd431dc12fb64f.png)\n\n## Responsibilities of the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#responsibilities-of-the-query-engine \"Direct link to Responsibilities of the query engine\")\n\nThe query engine has the following responsibilities in an application that uses Prisma Client:\n\n*   manage physical database connections in connection pool\n*   receive incoming queries from the Prisma Client Node.js process\n*   generate SQL queries\n*   send SQL queries to the database\n*   process responses from the database and send them back to Prisma Client\n\n## Debugging the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#debugging-the-query-engine \"Direct link to Debugging the query engine\")\n\nYou can access the logs of the query engine by setting the [`DEBUG`](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) environment variable to `engine`:\n\nYou can also get more visibility into the SQL queries that are generated by the query engine by setting the [`query` log level](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-levels) in Prisma Client:\n\n```\nconst prisma = new PrismaClient({  log: ['query'],})\n```\n\nLearn more about [Debugging](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) and [Logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging).\n\n## Configuring the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine \"Direct link to Configuring the query engine\")\n\n### Defining the query engine type for Prisma Client[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#defining-the-query-engine-type-for-prisma-client \"Direct link to Defining the query engine type for Prisma Client\")\n\n[As described above](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime) the default query engine is a Node-API library that is loaded into Prisma Client, but there is also an alternative implementation as an executable binary that runs in its own process. You can configure the query engine type by providing the `engineType` property to the Prisma Client `generator`:\n\n```\ngenerator client {  provider   = \"prisma-client-js\"  engineType = \"binary\"}\n```\n\nValid values for `engineType` are `binary` and `library`. You can also use the environment variable [`PRISMA_CLIENT_ENGINE_TYPE`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_client_engine_type) instead.\n\ninfo\n\n*   Until Prisma 3.x the default and only engine type available was `binary`, so there was no way to configure the engine type to be used by Prisma Client and Prisma CLI.\n*   From versions [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) to 3.x the `library` engine type was available and used by default by [activating the preview feature flag](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) \"`nApi`\" or using the `PRISMA_FORCE_NAPI=true` environment variable.\n\n### Defining the query engine type for Prisma CLI[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#defining-the-query-engine-type-for-prisma-cli \"Direct link to Defining the query engine type for Prisma CLI\")\n\nPrisma CLI also uses its own query engine for its own needs. You can configure it to use the binary version of the query engine by defining the environment variable [`PRISMA_CLI_QUERY_ENGINE_TYPE=binary`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_cli_query_engine_type).",
    "title": "Engines | Prisma Documentation",
    "description": "Prisma's query engine manages the communication with the database when using Prisma Client. Learn how it works on this page.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/connection-pooling",
    "markdown": "# Accelerate: Connection Pooling | Prisma Documentation\n\nA [connection pool](https://en.wikipedia.org/wiki/Connection_pool#:~:text=In%20software%20engineering%2C%20a%20connection,executing%20commands%20on%20a%20database.) is a storage of database connections that can be reused for future requests to the database. When a new connection is requested, it is retrieved from the pool if one is available. Once the connection is no longer needed, it is returned to the pool for reuse.\n\n[Connection pooling](https://www.prisma.io/dataguide/database-tools/connection-pooling) is important as it allows you to reuse existing connections instead of creating new ones, which can be an expensive operation.\n\nThe efficient management of database connections allows the database to process more queries without exhausting the available database connections, making your application more scalable.\n\nAccelerate provides built-in connection pooling by default. By simply using Accelerate, you get the benefits of connection pooling without having to configure anything. However, you can also configure the connection pool to suit your needs.\n\ninfo\n\nFor more information about connection pooling in Prisma, see the documentation [here](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool).\n\n### Default connection pool size[​](https://www.prisma.io/docs/accelerate/connection-pooling#default-connection-pool-size \"Direct link to Default connection pool size\")\n\nAccelerate has a default `connection_limit` set to `10`.\n\n### Configuring the connection pool size[​](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-size \"Direct link to Configuring the connection pool size\")\n\nThe connection pool size can be configured via the _database connection string_ in your Platform project (_not_ the Accelerate connection string in your Prisma schema) via the `connection_limit` parameter. For example, set a connection pool size of `10` like this: `postgresql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=10`.\n\nIf nothing is configured, a default value will be used.\n\nTo change the size of the connection pool:\n\n1.  Open the [Console](https://console.prisma.io/).\n2.  Select the _project_ in which you're using Accelerate. You might need to select a different _workspace_ if you can't see your project.\n3.  Select the _environment_ where you want to configure Accelerate's connection pool size.\n4.  Update the connection string by appending the `connection_limit` argument.\n\n![Update database connection string in Accelerate](https://www.prisma.io/docs/assets/images/accelerate-update-database-connection-string-634414bdbfa0f5e505ab8eb614d960ea.png)\n\n### Configuring the connection pool timeout[​](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-timeout \"Direct link to Configuring the connection pool timeout\")\n\nThe connection pool timeout is the maximum number of seconds that a query will block while waiting for a connection from Accelerate's internal connection pool. This occurs if the number of concurrent requests exceeds the connection limit, resulting in queueing of additional requests until a free connection becomes available. An exception is thrown if a free connection does not become available within the pool timeout. The connection pool timeout can be disabled by setting the value to 0.\n\nSimilar to the connection pool size, you may also configure the connection pool timeout via the _database connection string_. To adjust this value, you may add the `pool_timeout` parameter to the database connection string.\n\nFor example:\n\n```\npostgresql://user:password@localhost:5432/db?connection_limit=10&pool_timeout=20\n```\n\ninfo\n\nThe default value for `pool_timeout` is `10` seconds.",
    "title": "Accelerate: Connection Pooling | Prisma Documentation",
    "description": "Learn about everything you need to know to use Accelerate's connection pooling.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/limitations",
    "markdown": "# Accelerate: Limitations | Prisma Documentation\n\nBelow are descriptions of known limitations when using Accelerate. If you encounter any additional ones, please share them with us via [Discord](https://pris.ly/discord).\n\n## Query timeout limit[​](https://www.prisma.io/docs/accelerate/limitations#query-timeout-limit \"Direct link to Query timeout limit\")\n\nAccelerate has a global timeout of `10s` for each query. Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a greater timeout value.\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6004-querytimeout) for more information.\n\n## Interactive transactions query timeout limit[​](https://www.prisma.io/docs/accelerate/limitations#interactive-transactions-query-timeout-limit \"Direct link to Interactive transactions query timeout limit\")\n\nAccelerate has a global timeout of `15s` for each [interactive transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions). Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a greater timeout value.\n\n## Response size limit[​](https://www.prisma.io/docs/accelerate/limitations#response-size-limit \"Direct link to Response size limit\")\n\nAccelerate has a global response size limit of `5MB`. Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a larger response size.\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6009-responsesizelimitexceeded) for more information.\n\n## Cannot cache raw queries[​](https://www.prisma.io/docs/accelerate/limitations#cannot-cache-raw-queries \"Direct link to Cannot cache raw queries\")\n\nAt the moment, it is not possible to cache the responses of [raw queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries).\n\n## Not compatible with the fluent API[​](https://www.prisma.io/docs/accelerate/limitations#not-compatible-with-the-fluent-api \"Direct link to Not compatible with the fluent API\")\n\nClient Extensions (which are used in Accelerate) currently do not correctly forward the [fluent API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api) types. We hope to get a fix into Client Extensions soon.",
    "title": "Accelerate: Limitations | Prisma Documentation",
    "description": "Learn about limitations of Accelerate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/caching",
    "markdown": "# Accelerate: Caching | Prisma Documentation\n\n## Cache strategies[​](https://www.prisma.io/docs/accelerate/caching#cache-strategies \"Direct link to Cache strategies\")\n\nFor all read queries in Prisma Client, you can define the `cacheStrategy` parameter that configures cache behavior. The cache strategy allows you to define two main characteristics of the cache:\n\n*   **Time-to-live (TTL):** Duration in seconds a cached response is considered _fresh_.\n*   **Stale-while-Revalidating (SWR):** Duration in seconds a stale cache response is considered acceptable while the cache is refreshed in the background\n\n## Time-to-live (TTL)[​](https://www.prisma.io/docs/accelerate/caching#time-to-live-ttl \"Direct link to Time-to-live (TTL)\")\n\nTime-to-Live (TTL) determines how long cached data is considered fresh. By specifying the `ttl` in seconds, you can control the duration for which data in the cache remains valid. When a read query is executed, if the cached response is within the `ttl` limit, Prisma Client retrieves the data from the cache without querying the database. If the cached data is not available or has expired, Prisma Client queries the database and stores the results in the cache for future requests.\n\nUse `ttl` in `cacheStrategy` and specify the TTL of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    ttl: 60,  },});\n```\n\nWith a specified TTL of 60 seconds, the majority of requests will result in a cache hit throughout the TTL duration:\n\n![TTL](https://www.prisma.io/docs/assets/images/ttl-dafc2425fa18173f433138b62b89d656.png)\n\nTTL is useful for reducing database load and latency for data that does not require frequent updates.\n\n## Stale-While-Revalidate (SWR)[​](https://www.prisma.io/docs/accelerate/caching#stale-while-revalidate-swr \"Direct link to Stale-While-Revalidate (SWR)\")\n\nStale-While-Revalidate (SWR) allows you to control how long Accelerate can serve stale cache data while fetching fresh data in the background. When a read query is executed, Accelerate checks the age of the cached response against the `swr` duration. If the cache data is within the `swr` limit, Accelerate serves the stale data while simultaneously refreshing the cache by fetching the latest data from the database.\n\nUse `swr` in `cacheStrategy` and specify the SWR of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    swr: 60,  },});\n```\n\nWhen specifying a SWR of 60 seconds, the cache serves stale data until the cache refreshes itself in the background after each request:\n\n![SWR](https://www.prisma.io/docs/assets/images/swr-0543c25ba2ca4064175a4d4b67b74465.png)\n\n## Selecting a cache strategy[​](https://www.prisma.io/docs/accelerate/caching#selecting-a-cache-strategy \"Direct link to Selecting a cache strategy\")\n\nCaching helps you improve query response times and reduce database load. However, it also means you might serve stale data to the client. Whether or not serving stale data is acceptable and to what extent depends on your use case. `ttl` and `swr` are parameters you can use the tweak the cache behavior.\n\n### Cache strategy using TTL[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-ttl \"Direct link to Cache strategy using TTL\")\n\nUse TTL to reduce database load when stale cached data is acceptable.\n\n#### Use case: Product catalog in e-commerce applications[​](https://www.prisma.io/docs/accelerate/caching#use-case-product-catalog-in-e-commerce-applications \"Direct link to Use case: Product catalog in e-commerce applications\")\n\nConsider an e-commerce application with a product catalog that doesn't frequently change. By setting a `ttl` of, let's say, 1 hour, Prisma Client can serve cached product data for subsequent user requests within that hour without hitting the database. This significantly reduces the database load and improves the response time for product listing pages.\n\n### Cache strategy using SWR[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-swr \"Direct link to Cache strategy using SWR\")\n\nUse SWR to respond quickly to requests with minimal stale data. While it does not reduce database load, it can improve response times significantly.\n\nImagine a social media platform where user profiles are frequently accessed. By leveraging `swr` with a duration of, let's say, 5 minutes, Accelerate can serve the cached user profile information quickly, reducing the latency for profile pages. Meanwhile, in the background, it refreshes the cache after every request, ensuring that any updates made to the profile are eventually reflected for subsequent requests.\n\n### Cache strategy using TTL + SWR[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-ttl--swr \"Direct link to Cache strategy using TTL + SWR\")\n\nFor very fast response times and reduced database load, use both TTL and SWR. You can use this strategy to fine-tune your application’s tolerance for stale data.\n\nUse `ttl` and `swr` in `cacheStrategy` and specify the TTL and SWR of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    ttl: 30,    swr: 60,  },});\n```\n\nWhen specifying a TTL of 30 seconds and SWR of 60 seconds, the cache serves fresh data for the initial 30 seconds. Subsequently, it serves stale data until the cache refreshes itself in the background after each request:\n\n![ttl_and_swr.png](https://www.prisma.io/docs/assets/images/ttl_and_swr-2d64d0651978cd2b10ddf89149941179.png)\n\n#### Use case: News articles[​](https://www.prisma.io/docs/accelerate/caching#use-case-news-articles \"Direct link to Use case: News articles\")\n\nConsider a news application where articles are frequently accessed but don't require real-time updates. By setting a `ttl` of 2 hours and an `swr` duration of 5 minutes, Prisma Client can serve cached articles quickly, reducing latency for readers. As long as the articles are within the `ttl`, users get fast responses. After the `ttl` expires, Prisma Client serves the stale articles for an additional 5 minutes while fetching the latest news from the database, maintaining a balance between performance and freshness.\n\n## Default cache strategy [​](https://www.prisma.io/docs/accelerate/caching#default-cache-strategy \"Direct link to Default cache strategy \")\n\nAccelerate defaults to **no cache** to avoid counterintuitive issues. Caching can be a powerful tool for improving performance but can also be dangerous if not used correctly.\n\nFor example, consider writing a query on a critical path without explicitly defining a cache strategy. If you run the code, you might receive incorrect data without explanation. This could be caused by someone forgetting to disable the default _implicit_ cache behavior. Implicit caching allows these counterintuitive issues to arise, leading to undesirable results.\n\nYou must explicitly opt-in to caching if you want to use it. This makes it clear to developers that caching is not enabled by default and helps prevent counterintuitive issues from occurring.\n\n> When no cache strategy is specified or during a cache miss, a Prisma Client with the Accelerate extension routes all queries to the database through a connection pool instance near the database region.",
    "title": "Accelerate: Caching | Prisma Documentation",
    "description": "Learn everything you need to know to use Accelerate's global database caching.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/faq",
    "markdown": "# Accelerate: FAQ | Prisma Documentation\n\nBelow are frequently asked questions about Accelerate.\n\n## When should I enable static IP for Prisma Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#when-should-i-enable-static-ip-for-prisma-accelerate \"Direct link to When should I enable static IP for Prisma Accelerate?\")\n\nA static IP address is an IPv4 or an IPv6 address that is fixed. Unlike dynamic IP addresses, which can change unpredictably, traffic from static IP addresses can be easily identified. Enable static IP for Accelerate when your security setup requires IP allowlisting or if you're implementing firewalls that only permit access from trusted IPs, ensuring controlled and secure database connections.\n\n![What is a static IP](https://www.prisma.io/docs/assets/images/static-ip-c2016839d1d8658cfa5e1247b3e12de1.png)\n\nFor databases using IP allowlisting, enable static IP for Accelerate in your specified project environment, and add the obtained IP address to your database's allowlist to ensure authorized access from Accelerate.\n\n![](https://www.prisma.io/docs/assets/images/result-of-adding-static-ip-to-accelerate-273e29209a502217bf625879f59c7a56.png)\n\n> ℹ️ To enable static IP support for Accelerate within your existing or new project environment, your workspace will need to be on our **Pro** or **Business** plans. Take a look at the [pricing page](https://www.prisma.io/pricing) for more information.\n\n## Why do I sometimes see unexpected cache behavior?[​](https://www.prisma.io/docs/accelerate/faq#why-do-i-sometimes-see-unexpected-cache-behavior \"Direct link to Why do I sometimes see unexpected cache behavior?\")\n\nAccelerate's cache performs best when it observes a higher load from a project. Many cache operations, such as committing data to cache and refreshing stale data, happen asynchronously. When benchmarking Accelerate, we recommend doing so with loops or a load testing approach. This will mimic higher load scenarios better and reduce outliers from low frequency operations.\n\nPrisma operations are sent to Accelerate over HTTP. As a result, the first request to Accelerate must establish an HTTP handshake and may have additional latency as a result. We're exploring ways to reduce this initial request latency in the future.\n\n## What is the pricing of Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#what-is-the-pricing-of-accelerate \"Direct link to What is the pricing of Accelerate?\")\n\nYou can find more details on our [Accelerate pricing page](https://www.prisma.io/pricing)\n\n## VS Code does not recognize the `$extends` method[​](https://www.prisma.io/docs/accelerate/faq#vs-code-does-not-recognize-the-extends-method \"Direct link to vs-code-does-not-recognize-the-extends-method\")\n\nIf you add the Prisma Client extension for Accelerate to an existing project that is currently open in VS Code, the editor might not immediately recognize the `$extends` method.\n\nThis might be an issue with the TypeScript server not yet recognizing the regenerated Prisma Client. To resolve this, you need to restart TypeScript.\n\n1.  In VS Code, open the Command Palette. You can do so when you press F1 or select **View** > **Command Palette**.\n2.  Enter `typescript` and select and run the **TypeScript: Restart TS server** command.\n\nVS Code should now recognize the `$extends` method.\n\n## What regions are Accelerate's cache nodes available in?[​](https://www.prisma.io/docs/accelerate/faq#what-regions-are-accelerates-cache-nodes-available-in \"Direct link to What regions are Accelerate's cache nodes available in?\")\n\nAccelerate runs on Cloudflare's network and cache hits are served from Cloudflare's 300+ locations. You can find the regions where Accelerate's cache nodes are available here: [https://www.cloudflare.com/network/](https://www.cloudflare.com/network/).\n\n## What regions is Accelerate's connection pool available in?[​](https://www.prisma.io/docs/accelerate/faq#what-regions-is-accelerates-connection-pool-available-in \"Direct link to What regions is Accelerate's connection pool available in?\")\n\nWhen no cache strategy is specified or in the event of a cache miss, the Prisma Client query is routed through Accelerate's connection pool. Currently, queries can be routed through any chosen region among the 16 available locations.\n\nCurrently, the list of available regions are:\n\n*   Asia Pacific, Mumbai (`ap-south-1`)\n*   Asia Pacific, Seoul (`ap-northeast-2`)\n*   Asia Pacific, Singapore (`ap-southeast-1`)\n*   Asia Pacific, Sydney (`ap-southeast-2`)\n*   Asia Pacific, Tokyo (`ap-northeast-1`)\n*   Canada, Central (`ca-central-1`)\n*   Europe, Frankfurt (`eu-central-1`)\n*   Europe, Ireland (`eu-west-1`)\n*   Europe, London (`eu-west-2`)\n*   Europe, Paris (`eu-west-3`)\n*   Europe, Stockholm (`eu-north-1`)\n*   South America, Sao Paulo (`sa-east-1`)\n*   US East, N. Virginia (`us-east-1`)\n*   US East, Ohio (`us-east-2`)\n*   US West, N. California (`us-west-1`)\n*   US West, Oregon (`us-west-2`)\n\nYou can also view the available regions when you're about to set up Accelerate or by visiting the **Settings** tab for Accelerate under the **Region** section in the Prisma Cloud Platform [dashboard](https://pris.ly/pdp).\n\n## How does Accelerate know what region to fetch the cache from?[​](https://www.prisma.io/docs/accelerate/faq#how-does-accelerate-know-what-region-to-fetch-the-cache-from \"Direct link to How does Accelerate know what region to fetch the cache from?\")\n\nUnder the hood, Accelerate uses Cloudflare, which uses [Anycast](https://www.cloudflare.com/learning/cdn/glossary/anycast-network/) for network addressing and routing. An incoming request will be routed to the nearest data center or \"node\" in their network that has the capacity to process the request efficiently. To learn more about how this works, we recommend looking into [Anycast](https://www.cloudflare.com/learning/cdn/glossary/anycast-network/).\n\n## How can I invalidate a cache on Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#how-can-i-invalidate-a-cache-on-accelerate \"Direct link to How can I invalidate a cache on Accelerate?\")\n\nYou can invalidate your cache on a project level up to five times a day. This can be done via the Accelerate configuration page.\n\n## What is Accelerate's consistency model?[​](https://www.prisma.io/docs/accelerate/faq#what-is-accelerates-consistency-model \"Direct link to What is Accelerate's consistency model?\")\n\nAccelerate does not have a consistency model. It is not a distributed system where nodes need to reach a consensus (because data is only stored in the cache node(s) closest to the user). However, the data cached in Accelerate's cache nodes doesn't propagate to other nodes, so Accelerate by design doesn't need a consistency model.\n\nAccelerate implements a [read-through caching strategy](https://www.prisma.io/dataguide/managing-databases/introduction-database-caching#read-through) particularly suitable for read-heavy workloads.\n\nThe freshness of the data served by the cache depends on the cache strategy defined in your query. Refer to [this section](https://www.prisma.io/docs/accelerate/caching#selecting-a-cache-strategy) for more information on selecting the right cache strategy for your query.\n\n*   Accelerate is a _specialized_ cache that allows you to optimize data access in code at the query level with a cache strategy. On the other hand, tools such as Redis and Memcached are _general-purpose_ caches designed to be adaptable and flexible.\n*   Accelerate is a managed service that reduces the time, risk, and engineering effort of building and maintaining a cache service.\n*   By default, Accelerate is globally distributed, reducing the latency of your queries. Other cache tools would require additional configuration to make them available globally.\n\n## When should I not use Accelerate's caching features?[​](https://www.prisma.io/docs/accelerate/faq#when-should-i-not-use-accelerates-caching-features \"Direct link to When should I not use Accelerate's caching features?\")\n\nAccelerate is a global data cache and connection pool that allows you to optimize data access in code at the query level. While caching with Accelerate can greatly boost the performance of your app, it may not always the best choice for your use case.\n\nAccelerate's global cache feature may not be a good fit for your app if:\n\n*   Your app is exclusively used within a specific region and both your application server and database are situated in that same region on the same network. For example, database queries will likely be much faster if your application server and database are in the same region and network. However, If your application server is in different regions or networks from your database, Accelerate will speed up your queries because the data will be cached in the closest data center to your application.\n    \n*   You _only_ need a general-purpose cache. Accelerate is a connection pooler and a _specialized cache_ that only caches your database query responses in code. A general-purpose cache, such as Redis, would allow you to cache data from multiple sources, such as external APIs, which Accelerate currently doesn't support. If general-purpose caching interests you, please share your feedback with us via our [Discord](https://pris.ly/discord).\n    \n*   Your application data _always_ needs to be up-to-date on retrieval, which would be difficult to set a reasonable cache strategy.\n    \n\nEven without using Accelerate's global cache, you can still greatly benefit from Accelerate by using its connection pool, especially in serverless or edge functions, where it is difficult to manage and scale database connections. You can learn more about the serverless challenge [here](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge).\n\n## Can I use Accelerate with other ORMs/query builders/drivers?[​](https://www.prisma.io/docs/accelerate/faq#can-i-use-accelerate-with-other-ormsquery-buildersdrivers \"Direct link to Can I use Accelerate with other ORMs/query builders/drivers?\")\n\nNo. We currently do not have any plans for supporting other ORMs/query builders or drivers. However, if you're interested in support for other libraries, feel free to reach out and let us know in our [Discord](https://pris.ly/discord) community in the `#help-and-questions` channel.\n\n## What is the maximum allowed value for the `ttl` parameter when configuring `cacheStrategy`?[​](https://www.prisma.io/docs/accelerate/faq#what-is-the-maximum-allowed-value-for-the-ttl-parameter-when-configuring-cachestrategy \"Direct link to what-is-the-maximum-allowed-value-for-the-ttl-parameter-when-configuring-cachestrategy\")\n\nThe [Time-to-live](https://www.prisma.io/docs/accelerate/caching#time-to-live-ttl) (`ttl`) parameter can be set for up to a _year_. However, it's important to note that items within the cache may be evicted if they are not frequently accessed.\n\nBased on our experimentation, we’ve seen cache items persist for around 18 hours. While items may remain in the cache for an extended period if they are actively accessed, there is no guarantee.\n\n> **Note**: Even frequently accessed items may occasionally be evicted from the cache. It's unlikely for an item to survive for up to or longer than a month, regardless of its activity level.\n\n## Why doesn’t Accelerate fall back to the direct connection string during a service disruption?[​](https://www.prisma.io/docs/accelerate/faq#why-doesnt-accelerate-fall-back-to-the-direct-connection-string-during-a-service-disruption \"Direct link to Why doesn’t Accelerate fall back to the direct connection string during a service disruption?\")\n\nIn the rare event of a service disruption, falling back to a direct connection would bypass the connection pool. This could potentially deplete the database's available connections and cause other issues on the database level.\n\nIf there is a service disruption, it's recommended to verify on the [status page](https://pris.ly/data-platform-status). You can reach out to one of Prisma's [support channels](https://www.prisma.io/docs/platform/support) for assistance.\n\n> **Note:** Additionally, it's worth noting that some edge function runtime environments may not support direct connections with Prisma ORM. For further details, refer to our [Edge functions documentation](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview).\n\n## Are each of the queries within an interactive transaction counted separately for billing?[​](https://www.prisma.io/docs/accelerate/faq#are-each-of-the-queries-within-an-interactive-transaction-counted-separately-for-billing \"Direct link to Are each of the queries within an interactive transaction counted separately for billing?\")\n\nYes, [interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions) are billed based on the individual operations within the transaction. There is no charge for the start, commit, or rollback of the transaction itself. For example, in the following query, there are two billable queries:\n\n```\nawait prisma.$transaction(async (tx) => {  await tx.user.deleteMany({ where: { name: 'John Doe' } });  await tx.user.createMany({ data });});\n```\n\nHowever, when using the [`$transaction` API for sequential client operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations), regardless of the number of queries within the array, it counts as only one billable query. For example:\n\n```\nawait prisma.$transaction([  prisma.user.deleteMany({ where: { name: 'John Doe' } }),  prisma.user.createMany({ data }),]);\n```\n\nIf you don't need [interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions), you can save costs and improve performance by using [sequential operations transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations). Sequential operations transactions perform better on Accelerate because they execute in one round-trip to the database, while interactive transactions require separate round-trips for start, commit, and each individual operation on the transaction.",
    "title": "Accelerate: FAQ | Prisma Documentation",
    "description": "Frequently asked questions about Accelerate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/evaluating",
    "markdown": "# Accelerate: Evaluating | Prisma Documentation\n\nPrisma Accelerate optimizes database interactions through advanced connection pooling and global edge caching. Its connection pooler is available in 16 regions and helps applications load-balance and scale database requests based on demand.\n\nConsidering the information above, we recommend evaluating Accelerate with high volume to see it perform under load.\n\nPrisma Accelerate employs a dynamic, serverless connection pooling infrastructure. When a request is made, a connection pool is quickly provisioned for the project in the region assigned while configuring Prisma Accelerate. This connection pool remains active, serving many additional requests while reusing established database connections. The connection pool will disconnect after a period of inactivity, so it’s important to evaluate Prisma Accelerate with a consistent stream of traffic.\n\nBy understanding and harnessing this mechanism, you can ensure that your database queries perform consistently and efficiently at scale.\n\nBelow you will find an example of how to evaluate Prisma Accelerate using a sample model:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())function calculateStatistics(numbers: number[]): {  average: number  p50: number  p75: number  p99: number} {  if (numbers.length === 0) {    throw new Error('The input array is empty.')  }  // Sort the array in ascending order  numbers.sort((a, b) => a - b)  const sum = numbers.reduce((acc, num) => acc + num, 0)  const count = numbers.length  const average = sum / count  const p50 = getPercentile(numbers, 50)  const p75 = getPercentile(numbers, 75)  const p99 = getPercentile(numbers, 99)  return { average, p50, p75, p99 }}function getPercentile(numbers: number[], percentile: number): number {  if (percentile <= 0 || percentile >= 100) {    throw new Error('Percentile must be between 0 and 100.')  }  const index = (percentile / 100) * (numbers.length - 1)  if (Number.isInteger(index)) {    // If the index is an integer, return the corresponding value    return numbers[index]  } else {    // If the index is not an integer, interpolate between two adjacent values    const lowerIndex = Math.floor(index)    const upperIndex = Math.ceil(index)    const lowerValue = numbers[lowerIndex]    const upperValue = numbers[upperIndex]    const interpolationFactor = index - lowerIndex    return lowerValue + (upperValue - lowerValue) * interpolationFactor  }}async function main() {  const timings = []  // fire a query before going to the loop  await prisma.notes.findMany({    take: 20,  })  // we recommend evaluationg Prisma Accelerate with a large loop  const LOOP_LENGTH = 10000  for (let i = 0; i < LOOP_LENGTH; i++) {    const start = Date.now()    await prisma.notes.findMany({      take: 20,    })    timings.push(Date.now() - start)  }  const statistics = calculateStatistics(timings)  console.log('Average:', statistics.average)  console.log('P50:', statistics.p50)  console.log('P75:', statistics.p75)  console.log('P99:', statistics.p99)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch((e) => {    await prisma.$disconnect()    process.exit(1)  })\n```\n\nPrisma Accelerate’s edge cache is also optimized for a high volume of queries. The cache automatically optimizes for repeated queries. As a result, the cache hit rate will increase as the query frequency does. Adding a query result to the cache is also non-blocking, so a short burst of queries might not utilize the cache or a sustained load.\n\nTo evaluate Accelerate’s edge caching, you can modify the above script with the below:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())function calculateStatistics(numbers: number[]): {  average: number  p50: number  p75: number  p99: number} {  if (numbers.length === 0) {    throw new Error('The input array is empty.')  }  // Sort the array in ascending order  numbers.sort((a, b) => a - b)  const sum = numbers.reduce((acc, num) => acc + num, 0)  const count = numbers.length  const average = sum / count  const p50 = getPercentile(numbers, 50)  const p75 = getPercentile(numbers, 75)  const p99 = getPercentile(numbers, 99)  return { average, p50, p75, p99 }}function getPercentile(numbers: number[], percentile: number): number {  if (percentile <= 0 || percentile >= 100) {    throw new Error('Percentile must be between 0 and 100.')  }  const index = (percentile / 100) * (numbers.length - 1)  if (Number.isInteger(index)) {    // If the index is an integer, return the corresponding value    return numbers[index]  } else {    // If the index is not an integer, interpolate between two adjacent values    const lowerIndex = Math.floor(index)    const upperIndex = Math.ceil(index)    const lowerValue = numbers[lowerIndex]    const upperValue = numbers[upperIndex]    const interpolationFactor = index - lowerIndex    return lowerValue + (upperValue - lowerValue) * interpolationFactor  }}async function main() {  const timings = []  // fire a query before going to the loop  await prisma.notes.findMany({    take: 20,    cacheStrategy: {      ttl: 30,    },  })  // we recommend evaluating Prisma Accelerate with a large loop  const LOOP_LENGTH = 10000  for (let i = 0; i < LOOP_LENGTH; i++) {    const start = Date.now()    await prisma.notes.findMany({      take: 20,      cacheStrategy: {        ttl: 30,      },    })    timings.push(Date.now() - start)  }  const statistics = calculateStatistics(timings)  console.log('Average:', statistics.average)  console.log('P50:', statistics.p50)  console.log('P75:', statistics.p75)  console.log('P99:', statistics.p99)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch((e) => {    await prisma.$disconnect()    process.exit(1)  })\n```",
    "title": "Accelerate: Evaluating | Prisma Documentation",
    "description": "Learn about evaluating Prisma Accelerate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/local-development",
    "markdown": "# Accelerate: Local development | Prisma Documentation\n\nPrisma Accelerate efficiently scales production traffic with integrated connection pooling and a global database cache.\n\nIn development environments, you may want to use a local database to minimize expenses. Furthermore, you may consider extending Prisma Client with the Accelerate client extension once so that you can use a local database in development and a hosted database with Accelerate’s connection pooling and caching enabled. This eliminates the need for conditional logic to switch clients between development and production.\n\nThis guide will explain how to use Prisma Accelerate client extension in a development environment with a local database.\n\n## Using Prisma Accelerate client extension in development and production[​](https://www.prisma.io/docs/accelerate/local-development#using-prisma-accelerate-client-extension-in-development-and-production \"Direct link to Using Prisma Accelerate client extension in development and production\")\n\n![](https://www.prisma.io/docs/assets/images/accelerate-in-dev-23954395536c6d2aabcfddf57b9fff16.png)\n\nAccelerate does not work with a local database. However, in a development environment, you can still use Prisma Client with the Accelerate client extension. This setup will not provide Accelerate's connection pooling and caching features.\n\nThe following steps outline how to use Prisma ORM and Prisma Accelerate with a local PostgreSQL database.\n\n1.  Update the `DATABASE_URL` environment variable with your local database's connection string:\n    \n    ```\n    DATABASE_URL=\"postgres://username:password@127.0.0.1:5432/localdb\"\n    ```\n    \n2.  Generate a Prisma Client:\n    \n    > Note: The `--no-engine` flag should only be used in preview and production environments. The command generates Prisma Client artifacts without a [Query Engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) file, which requires an Accelerate connection string.\n    \n3.  Set up Prisma Client with the Accelerate client extension:\n    \n    ```\n    import { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())\n    ```\n    \n    > The extended instance of Prisma Client will use the local database. Hence, Prisma Accelerate will not be used in your development environment to respond to your Prisma Client queries.\n    \n\n![](https://www.prisma.io/docs/assets/images/accelerate-in-prod-5561d88bf69c7127d34450eba963a5af.png)\n\nIf an Accelerate connection string is used as the `DATABASE_URL` environment variable, Prisma Client will route your queries through Accelerate.\n\n## Using Prisma Accelerate locally in an edge function[​](https://www.prisma.io/docs/accelerate/local-development#using-prisma-accelerate-locally-in-an-edge-function \"Direct link to Using Prisma Accelerate locally in an edge function\")\n\nWhen using an edge function, e.g., [Vercel's edge functions](https://vercel.com/docs/functions/edge-functions), for your development environment, update your Prisma Client import as follows:\n\n```\nimport { PrismaClient } from '@prisma/client/edge'\n```\n\nGenerally, edge function environments lack native support for existing APIs enabling TCP-based database connections. Prisma Accelerate provides a connection string that allows querying your database over HTTP, a protocol supported in all edge runtimes.",
    "title": "Accelerate: Local development | Prisma Documentation",
    "description": "Learn how to use Prisma Accelerate in a development environment.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/troubleshoot",
    "markdown": "# Troubleshooting: Prisma Accelerate | Prisma Documentation\n\nWhen working with Prisma Accelerate, you may encounter errors often highlighted by specific error codes during development and operations. It is important to understand the meaning of these errors, why they occur, and how to resolve them in order to ensure the smooth operation of your applications. This guide aims to provide insights and steps to troubleshoot specific error codes encountered with Prisma Accelerate.\n\n## [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded) (`ResponseSizeLimitExceeded`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6009-responsesizelimitexceeded \"Direct link to p6009-responsesizelimitexceeded\")\n\nThis error is triggered when the response size from a database query exceeds the 5MB limit. We've implemented this restriction to safeguard your application performance, as retrieving data over 5MB can significantly slow down your application due to multiple network layers. Typically, transmitting more than 5MB of data is common when conducting ETL (Extract, Transform, Load) operations. However, for other scenarios such as transactional queries, real-time data fetching for user interfaces, bulk data updates, or aggregating large datasets for analytics outside of ETL contexts, it should generally be avoided. These use cases, while essential, can often be optimized to work within the 5MB limit, ensuring smoother performance and a better user experience.\n\n### Possible causes for [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6009 \"Direct link to possible-causes-for-p6009\")\n\n#### Transmitting images/files in response[​](https://www.prisma.io/docs/accelerate/troubleshoot#transmitting-imagesfiles-in-response \"Direct link to Transmitting images/files in response\")\n\nThis error may arise if images or files stored within your table are being fetched, resulting in a large response size. Storing assets directly in the database is generally discouraged because it significantly impacts database performance and scalability. In addition to performance, it makes database backups slow and significantly increases the cost of storing routine backups.\n\n**Suggested solution:** Store the image/file in a BLOB store like [Cloudflare R2](https://developers.cloudflare.com/r2/), [AWS S3](https://aws.amazon.com/pm/serv-s3/), [Cloudinary](https://cloudinary.com/), etc. These services would allow you to store the assets optimally and return a URL through which you should be able to access the asset. You can store this URL in your table instead of storing the asset directly in database. This would substantially reduce the size of your response.\n\n#### Over-fetching of data[​](https://www.prisma.io/docs/accelerate/troubleshoot#over-fetching-of-data \"Direct link to Over-fetching of data\")\n\nIn certain cases, a large number of records or fields are unintentionally fetched, which results in exceeding the 5MB limit. This could happen when the [`where`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#where) clause in the query is incorrect or entirely missing.\n\n**Suggested solution:** Double-check if the `where` clause is filtering the data as you expect. Consider using [pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) to prevent a large number of records from being fetched. Additionally, use the [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) clause to return only the fields that are being consumed to further reduce the response size.\n\n#### Fetching a large volume of data[​](https://www.prisma.io/docs/accelerate/troubleshoot#fetching-a-large-volume-of-data \"Direct link to Fetching a large volume of data\")\n\nIn many data processing workflows, especially those involving ETL (Extract-Transform-Load) processes or scheduled CRON jobs, there's a need to extract large amounts of data from data sources (like databases, APIs, or file systems) for analysis, reporting, or further processing. If you are running an ETL/CRON workload that fetches a huge chunk of data for analytical processing then you might run into this limit.\n\n**Suggested solution:** Consider splitting your query to fetch data in batches to prevent the 5MB limit from being reached. By splitting your query to retrieve data in batches, you ensure that each operation fetches only a portion of the total data volume, thereby not exceeding the size limit for a single fetch operation.\n\n## [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout) (`QueryTimeout`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6004-querytimeout \"Direct link to p6004-querytimeout\")\n\nThis error occurs when a database query fails to return a response within 10 seconds. The 10-second limit includes the duration of waiting for a connection from the pool, network latency to the database, and the execution time of the query itself. We enforce this limit to prevent unintentional long-running queries that can overload system resources.\n\n> The time for Accelerate's cross-region networking is excluded from the 10-second limit.\n\n### Possible causes for [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6004 \"Direct link to possible-causes-for-p6004\")\n\nThis error could be caused by numerous reasons. Some of the prominent ones are:\n\n#### High traffic and insufficient connections[​](https://www.prisma.io/docs/accelerate/troubleshoot#high-traffic-and-insufficient-connections \"Direct link to High traffic and insufficient connections\")\n\nIf the application is receiving very high traffic and there are not a sufficient number of connections available to the database, then the queries would need to wait for a connection to become available. This situation can lead to queries waiting longer than 10 seconds for a connection, ultimately triggering a timeout error if they do not get serviced within this duration.\n\n**Suggested solution**: Review and possibly increase the `connection_limit` specified in the connection string parameter when setting up Accelerate in a platform environment ([reference](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-size)). This limit should align with your database's maximum number of connections.\n\nBy default, the connection limit is set to 10 unless a different `connection_limit` is specified in your database connection string.\n\n#### Long-running queries[​](https://www.prisma.io/docs/accelerate/troubleshoot#long-running-queries \"Direct link to Long-running queries\")\n\nQueries may be slow to respond, hitting the 10-second timeout even when connections are available. This could happen if a very large amount of data is being fetched in a single query or if appropriate indexes are missing from the table.\n\n**Suggested solution**: Identify the slow-running queries and fetch only the required data. If you only need to use specific fields from the table, then you can use the select clause in your queries to prevent unnecessary data from being fetched. Additionally, you could consider adding appropriate indexes based on the query to ensure that data is fetched efficiently. You can also consider isolating long running queries into separate environments, so that these long running queries would not affect the transactional queries.\n\n#### Database resource contention[​](https://www.prisma.io/docs/accelerate/troubleshoot#database-resource-contention \"Direct link to Database resource contention\")\n\nA common yet challenging issue is when other services operating on the same database perform heavy analytics or data processing tasks, significantly consuming database resources. These operations can monopolize database connections and processing power, leading to a scenario where even simple queries cannot be executed in a timely manner. This \"busy\" or \"noisy\" database environment can cause queries that are typically fast to run slowly or even timeout, particularly during periods of high activity from other services.\n\nUsers often rely on CPU and memory usage metrics to gauge database load, which can be misleading. While these are important indicators, they might not fully represent the database's operational state. Direct metrics like the number of reads, writes, and wait times offer a clearer view of the database's performance and should be monitored closely. A noticeable degradation in these metrics, especially in the absence of changes to the queries or data model, suggests that external pressures are affecting database performance.\n\n**Suggestion solution**: If normally quick queries are intermittently slow or timing out without any modifications to them, it's probable that competing queries are exerting pressure on the same database tables. To diagnose this, adopt monitoring tools or leverage your database's inherent capabilities to observe reads, writes, and wait times. Such monitoring will unveil activity patterns or spikes that align with the observed performance dips.\n\nMoreover, it's crucial to periodically scrutinize and refine essential queries and verify that tables are properly indexed. This proactive approach minimizes the vulnerability of these queries to slowdowns caused by competing workloads.\n\n### Considerations for [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded) and [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout) errors[​](https://www.prisma.io/docs/accelerate/troubleshoot#considerations-for-p6009-and-p6004-errors \"Direct link to considerations-for-p6009-and-p6004-errors\")\n\nFor runtimes that support Prisma ORM natively, you could consider creating two `PrismaClient` Instances. One with the Accelerate connection string (prefixed with `prisma://`) and the other one with the direct database connection string (prefixed with `postgres://`, `mysql://` etc). The main idea behind this approach is to bypass Accelerate for certain specific queries.\n\nHowever, please note that the available connections would be split between both of your `PrismaClient` Instances. It's crucial to understand the implications of managing multiple instances, particularly in regards to direct database connections. Utilizing a `PrismaClient` instance with a direct database connection string means that this connection will interact directly with your database.\n\nThis approach requires careful consideration because the direct connections and those managed by Accelerate share the same underlying database connection pool. This can lead to competition for resources, potentially affecting the performance and availability of your database services.\n\nAdditionally, direct connections could have a significant impact on your database's performance and availability. Operations that consume a considerable amount of resources could potentially degrade the service for other users or processes that rely on the same database.\n\nIf your application's runtime environment supports Prisma ORM natively and you're considering this strategy to circumvent P6009 and P6004 errors, you might create two `PrismaClient` instances:\n\n1.  An instance using the Accelerate connection string (prefixed with `prisma://`) for general operations.\n2.  Another instance with the direct database connection string (e.g., prefixed with `postgres://`, `mysql://`, etc.) for specific operations anticipated to exceed 10 seconds in execution time or to result in responses larger than 5MB.\n\n```\nexport const prisma = new PrismaClient({  datasourceUrl: process.env.DIRECT_DB_CONNECTION,})export const prismaAccelerate = new PrismaClient({  datasourceUrl: process.env.ACCELERATE_CONNECTION,}).$extends(withAccelerate())\n```\n\nThis setup allows you to strategically direct certain operations through the direct connection, mitigating the risk of encountering the aforementioned errors. However, this decision should be made with a comprehensive understanding of the potential consequences and an assessment of whether your database infrastructure can support this additional load without compromising overall performance and availability.\n\n> Also see [**why doesn’t Accelerate fall back to the direct connection string during a service disruption?**](https://www.prisma.io/docs/accelerate/faq#why-doesnt-accelerate-fall-back-to-the-direct-connection-string-during-a-service-disruption)\n\n## [`P6008`](https://www.prisma.io/docs/orm/reference/error-reference#p6008-connectionerrorenginestarterror) (`ConnectionError|EngineStartError`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6008-connectionerrorenginestarterror \"Direct link to p6008-connectionerrorenginestarterror\")\n\nThis error indicates that Prisma Accelerate cannot establish a connection to your database, potentially due to several reasons.\n\n### Possible causes for [`P6008`](https://www.prisma.io/docs/orm/reference/error-reference#p6008-connectionerrorenginestarterror)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6008 \"Direct link to possible-causes-for-p6008\")\n\n#### Database Not Publicly accessible[​](https://www.prisma.io/docs/accelerate/troubleshoot#database-not-publicly-accessible \"Direct link to Database Not Publicly accessible\")\n\nPrisma Accelerate currently requires the database to be publicly accessible. If your database is behind a VPC, or access is restricted to specific IP addresses, this error may occur.\n\n**Suggested solution:** Ensure your database is publicly accessible, if not, allow public access. Please note this is only an interim requirement, Static IPs are coming soon and will alleviate the need for complete public access if that’s not desirable.\n\n#### Unreachable Database Host/Port[​](https://www.prisma.io/docs/accelerate/troubleshoot#unreachable-database-hostport \"Direct link to Unreachable Database Host/Port\")\n\nIf the database’s server address (hostname) and port are incorrect or unreachable then you may encounter this error.\n\n**Suggested solution:** Verify the hostname/port of the database connection string that was provided while creating the Prisma Accelerate project. Additionally, attempt to connect to the database using a Database GUI tool (e.g., [Prisma Studio](https://www.prisma.io/studio), [TablePlus](https://tableplus.com/), or [DataGrip](https://www.jetbrains.com/datagrip/)) for further investigation.\n\n#### Incorrect username/password/database name[​](https://www.prisma.io/docs/accelerate/troubleshoot#incorrect-usernamepassworddatabase-name \"Direct link to Incorrect username/password/database name\")\n\nThis error can happen when the wrong credentials are provided to Prisma Accelerate, preventing it from establishing a connection to your database.\n\n**Suggested solution:** Verify the correctness of your database's username, password, and name in the connection string provided to Prisma Accelerate. Ensure that these credentials match those required by your database. Testing the connection using a direct database GUI tool can also help in confirming if the provided credentials are correct.",
    "title": "Troubleshooting: Prisma Accelerate | Prisma Documentation",
    "description": "Troubleshooting Prisma Accelerate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/accelerate/feedback",
    "markdown": "# Accelerate: Feedback | Prisma Documentation\n\nYou can submit any feedback about Accelerate in our [Discord server](https://pris.ly/discord).",
    "title": "Accelerate: Feedback | Prisma Documentation",
    "description": "Learn where to submit feedback about Accelerate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local",
    "markdown": "# SQL Server on Windows | Prisma Documentation\n\nTo run a Microsoft SQL Server locally on a Windows machine:\n\n1.  If you do not have access to an instance of Microsoft SQL Server, download and set up [SQL Server 2019 Developer](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).\n    \n2.  Download and install [SQL Server Management Studio](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver15).\n    \n3.  Use Windows Authentication to log in to Microsoft SQL Server Management Studio (expand the **Server Name** dropdown and click **<Browse for more...>** to find your database engine):\n    \n\n![The New Query button in SQL Server Management Studio](https://www.prisma.io/docs/assets/images/connect-sql-server-a007f9ba700b683d87d627a8bee86c57.png)\n\n## Enable TCP/IP[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-tcpip \"Direct link to Enable TCP/IP\")\n\nPrisma Client requires TCP/IP to be enabled. To enable TCP/IP:\n\n1.  Open SQL Server Configuration Manager. (Search for \"SQL Server Configuration Manager\" in the Start Menu, or open the Start Menu and type \"SQL Server Configuration Manager\".)\n    \n2.  In the left-hand panel, click **SQL Server Network Configuration** > **Protocols for MSSQLSERVER**\n    \n3.  Right-click **TCP/IP** and choose **Enable**.\n    \n\n## Enable authentication with SQL logins (Optional)[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-authentication-with-sql-logins-optional \"Direct link to Enable authentication with SQL logins (Optional)\")\n\nIf you want to use a username and password in your connection URL rather than integrated security, [enable mixed authentication mode](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/change-server-authentication-mode?view=sql-server-ver15) as follows:\n\n1.  Right-click on your database engine in the Object Explorer and click **Properties**.\n    \n2.  In the Server Properties window, click **Security** in the left-hand list and tick the **SQL Server and Windows Authentication Mode** option, then click **OK**.\n    \n3.  Right-click on your database engine in the Object Explorer and click **Restart**.\n    \n\n### Enable the `sa` login[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-the-sa-login \"Direct link to enable-the-sa-login\")\n\nTo enable the default `sa` (administrator) SQL Server login:\n\n1.  In SQL Server Management Studio, in the Object Explorer, expand **Security** > **Logins** and double-click **sa**.\n    \n2.  On the **General** page, choose a password for the `sa` account (untick **Enforce password policy** if you do not want to enforce a policy).\n    \n3.  On the **Status** page, under **Settings** > **Login**, tick **Enabled**, then click **OK**.\n    \n\nYou can now use the `sa` account in a connection URL and when you log in to SQL Server Management Studio.\n\n> **Note**: The `sa` user has extensive permissions. You can also [create your own login with fewer permissions](https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/create-a-login?view=sql-server-ver15).",
    "title": "SQL Server on Windows | Prisma Documentation",
    "description": "Set up and configure SQL Server on Windows.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-docker",
    "markdown": "# SQL Server on Docker | Prisma Documentation\n\nCreate an instance of the container image, replacing the value of `SA_PASSWORD` with a password of your choice:\n\n```\ndocker run --name sql_container -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=myPassword' -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest\n```",
    "title": "SQL Server  on Docker | Prisma Documentation",
    "description": "Download and use the Microsoft SQL Server Docker image.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql",
    "markdown": "# Building GraphQL servers with Prisma ORM\n\n[GraphQL](https://graphql.org/) is a query language for APIs. It is often used as an alternative to RESTful APIs, but can also be used as an additional \"gateway\" layer on top of existing RESTful services.\n\nWith Prisma ORM, you can build GraphQL servers that connect to a database. Prisma ORM is completely agnostic to the GraphQL tools you use. When building a GraphQL server, you can combine Prisma ORM with tools like Apollo Server, GraphQL Yoga, TypeGraphQL, GraphQL.js, or pretty much any tool or library that you're using in your GraphQL server setup.\n\n## GraphQL servers under the hood[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#graphql-servers-under-the-hood \"Direct link to GraphQL servers under the hood\")\n\nA GraphQL server consists of two major components:\n\n*   GraphQL schema (type definitions + resolvers)\n*   HTTP server\n\nNote that a GraphQL schema can be written code-first or SDL-first. Check out this [article](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) to learn more about these two approaches. If you like the SDL-first approach but still want to make your code type-safe, check out [GraphQL Code Generator](https://graphql-code-generator.com/) to generate various type definitions based on SDL.\n\nThe GraphQL schema and HTTP server are typically handled by separate libraries. Here is an overview of current GraphQL server tools and their purpose:\n\n| Library (npm package) | Purpose | Compatible with Prisma ORM | Prisma integration |\n| --- | --- | --- | --- |\n| `graphql` | GraphQL schema (code-first) | Yes | No  |\n| `graphql-tools` | GraphQL schema (SDL-first) | Yes | No  |\n| `type-graphql` | GraphQL schema (code-first) | Yes | [`typegraphql-prisma`](https://www.npmjs.com/package/typegraphql-prisma) |\n| `nexus` | GraphQL schema (code-first) | Yes | [`nexus-prisma`](https://graphql-nexus.github.io/nexus-prisma) _Early Preview_ |\n| `apollo-server` | HTTP server | Yes | n/a |\n| `express-graphql` | HTTP server | Yes | n/a |\n| `fastify-gql` | HTTP server | Yes | n/a |\n| `graphql-yoga` | HTTP server | Yes | n/a |\n\nIn addition to these standalone and single-purpose libraries, there are several projects building integrated _application frameworks_:\n\n| Framework | Stack | Built by | Prisma ORM | Description |\n| --- | --- | --- | --- | --- |\n| [Redwood.js](https://redwoodjs.com/) | Fullstack | [Tom Preston-Werner](https://github.com/mojombo/) | Built on top of Prisma ORM | _Bringing full-stack to the JAMstack._ |\n\n> **Note**: If you notice any GraphQL libraries/frameworks missing from the list, please let us know.\n\n## Prisma ORM & GraphQL examples[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#prisma-orm--graphql-examples \"Direct link to Prisma ORM & GraphQL examples\")\n\nIn the following section will find several ready-to-run examples that showcase how to use Prisma ORM with different combinations of the tools mentioned in the table above.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#typescript \"Direct link to TypeScript\")\n\n| Example | HTTP Server | GraphQL schema | Description |\n| --- | --- | --- | --- |\n| [GraphQL API (Pothos)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql) | `graphql-yoga` | `pothos` | GraphQL server based on [`graphql-yoga`](https://the-guild.dev/graphql/yoga-server) |\n| [GraphQL API (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-sdl-first) | `graphql-yoga` | n/a | GraphQL server based on the SDL-first approach |\n| [GraphQL API -- NestJs](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nestjs) | `@nestjs/apollo` | n/a | GraphQL server based on [NestJS](https://nestjs.com/) |\n| [GraphQL API -- NestJs (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nestjs-sdl-first) | `@nestjs/apollo` | n/a | GraphQL server based on [NestJS](https://nestjs.com/) |\n| [GraphQL API (Nexus)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nexus) | `@apollo/server` | `nexus` | GraphQL server based on [`@apollo/server`](https://www.apollographql.com/docs/apollo-server) |\n| [GraphQL API (TypeGraphQL)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-typegraphql) | `apollo-server` | `type-graphql` | GraphQL server based on the code-first approach of [TypeGraphQL](https://typegraphql.com/) |\n| [GraphQL API (Auth)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-auth) | `apollo-server` | `nexus` | GraphQL server with email-password authentication & permissions |\n| [Fullstack app](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nextjs) | `graphql-yoga` | `pothos` | Fullstack app with Next.js (React), Apollo Client, GraphQL Yoga and Pothos |\n| [GraphQL subscriptions](https://github.com/prisma/prisma-examples/tree/latest/typescript/subscriptions-pubsub) | `apollo-server` | `nexus` | GraphQL server implementing realtime GraphQL subscriptions |\n| [GraphQL API -- Hapi](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-hapi) | `apollo-server-hapi` | `nexus` | GraphQL server based on [Hapi](https://hapi.dev/) |\n| [GraphQL API -- Hapi (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-hapi-sdl-first) | `apollo-server-hapi` | `graphql-tools` | GraphQL server based on [Hapi](https://hapi.dev/) |\n| [GraphQL API -- Fastify](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-fastify) | `fastify` & `mercurius` | n/a | GraphQL server based on [Fastify](https://fastify.io/) and [Mercurius](https://mercurius.dev/) |\n| [GraphQL API -- Fastify (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-fastify-sdl-first) | `fastify` | `Nexus` | GraphQL server based on [Fastify](https://fastify.io/) and [Mercurius](https://mercurius.dev/) |\n\n### JavaScript (Node.js)[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#javascript-nodejs \"Direct link to JavaScript (Node.js)\")\n\n| Demo | HTTP Server | GraphQL schema | Description |\n| --- | --- | --- | --- |\n| [GraphQL API (Apollo Server)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql) | `apollo-server` | `nexus` | GraphQL server based on [`apollo-server`](https://www.apollographql.com/docs/apollo-server/) |\n| [GraphQL API (Auth)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql-auth) | `apollo-server` | `nexus` | GraphQL server with email-password authentication & permissions |\n| [GraphQL API (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql-sdl-first) | `apollo-server` | `graphql-tools` | GraphQL server based on the SDL-first approach of [`graphql-tools`](https://www.apollographql.com/docs/graphql-tools/) (Apollo) |\n\n## FAQ[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#faq \"Direct link to FAQ\")\n\n### What is Prisma ORM's role in a GraphQL server?[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#what-is-prisma-orms-role-in-a-graphql-server \"Direct link to What is Prisma ORM's role in a GraphQL server?\")\n\nNo matter which of the above GraphQL tools/libraries you use, Prisma ORM is used inside your GraphQL resolvers to connect to your database. It has the same role that any other ORM or SQL query builder would have inside your resolvers.\n\nIn the resolver of a GraphQL query, Prisma ORM typically reads data from the database to return it in the GraphQL response. In the resolver of a GraphQL mutation, Prisma ORM typically also writes data to the database (e.g. creating new or updating existing records).\n\n## Other GraphQL Resources[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#other-graphql-resources \"Direct link to Other GraphQL Resources\")\n\nPrisma curates [GraphQL Weekly](https://www.graphqlweekly.com/), a newsletter highlighting resources and updates from the GraphQL community. Subscribe to keep up-to-date with GraphQL articles, videos, tutorials, libraries, and more.",
    "title": "Building GraphQL servers with Prisma ORM | Prisma Documentation",
    "description": "This page gives explains how to build GraphQL servers with Prisma ORM. It shows how Prisma ORM fits into the GraphQL ecosystem and provides practical examples.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/development-environment/environment-variables",
    "markdown": "# Environment variables | Prisma Documentation\n\nAn environment variable is a key value pair of string data that is stored on your machine's local environment. Refer to our [Environment variables reference documentation](https://www.prisma.io/docs/orm/reference/environment-variables-reference) for specific details.\n\nTypically the name of the variable is uppercase, this is then followed by an equals sign then the value of the variable:\n\nThe environment variable belongs to the environment where a process is running.\n\nTaking the `TEMP` environment variable as an example, one can query its value to find where to store temporary files. This is a system environment variable and can be queried by any process or application running on the machine.\n\nAny program can read and create these environment variables. They are a cheap and effective way to store simple information.\n\n## How does Prisma ORM use environment variables?[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables#how-does-prisma-orm-use-environment-variables \"Direct link to How does Prisma ORM use environment variables?\")\n\nPrisma ORM always reads environment variables from the system's environment.\n\nWhen you initialize Prisma ORM in your project with `prisma init`, it creates a convenience `.env` file for you to set your [`connection url`](https://www.prisma.io/docs/orm/reference/connection-urls) as an environment variable. When you use Prisma CLI or Prisma Client, the `.env` file content and the variables defined in it are added to the [`process.env` object](https://nodejs.org/api/process.html#processenv), where Prisma ORM can read it and use it.\n\ninfo\n\nLooking to use more than one `.env` file? See [Using multiple `.env` files](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files) for information on how to setup and use multiple `.env` files in your application.\n\n### Using environment variables in your code[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables#using-environment-variables-in-your-code \"Direct link to Using environment variables in your code\")\n\nIf you want environment variables to be evaluated at runtime, you need to load them manually in your application code (for example, by using [`dotenv`](https://github.com/motdotla/dotenv)):\n\n```\nimport * as dotenv from 'dotenv'dotenv.config() // Load the environment variablesconsole.log(`The connection URL is ${process.env.DATABASE_URL}`)\n```",
    "title": "Environment variables | Prisma Documentation",
    "description": "Learn how to use environment variables in your Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest",
    "markdown": "# Building REST APIs with Prisma ORM\n\nWhen building REST APIs, Prisma Client can be used inside your _route controllers_ to send databases queries.\n\n![REST APIs with Prisma Client](https://www.prisma.io/docs/assets/images/prisma-rest-apis-0e61276a3ec593d67c0a7d46875fe023.png)\n\n## Supported libraries[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#supported-libraries \"Direct link to Supported libraries\")\n\nAs Prisma Client is \"only\" responsible for sending queries to your database, it can be combined with any HTTP server library or web framework of your choice.\n\nHere's a non-exhaustive list of libraries and frameworks you can use with Prisma ORM:\n\n*   [Express](https://expressjs.com/)\n*   [koa](https://koajs.com/)\n*   [hapi](https://hapi.dev/)\n*   [Fastify](https://www.fastify.io/)\n*   [Sails](https://sailsjs.com/)\n*   [AdonisJs](https://adonisjs.com/)\n*   [NestJS](https://nestjs.com/)\n*   [Next.js](https://nextjs.org/)\n*   [Foal TS](https://foalts.org/)\n*   [Polka](https://github.com/lukeed/polka)\n*   [Micro](https://github.com/zeit/micro)\n*   [Feathers](https://feathersjs.com/)\n*   [Remix](https://remix.run/)\n\n## REST API server example[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#rest-api-server-example \"Direct link to REST API server example\")\n\nAssume you have a Prisma schema that looks similar to this:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nYou can now implement route controller (e.g. using Express) that use the generated [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) to perform a database operation when an incoming HTTP request arrives. This page only shows few sample code snippets; if you want to run these code snippets, you can use a [REST API example](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-express).\n\n#### `GET`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#get \"Direct link to get\")\n\n```\napp.get('/feed', async (req, res) => {  const posts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.json(posts)})\n```\n\nNote that the `feed` endpoint in this case returns a nested JSON response of `Post` objects that _include_ an `author` object. Here's a sample response:\n\n```\n[  {    \"id\": \"21\",    \"title\": \"Hello World\",    \"content\": \"null\",    \"published\": \"true\",    \"authorId\": 42,    \"author\": {      \"id\": \"42\",      \"name\": \"Alice\",      \"email\": \"alice@prisma.io\"    }  }]\n```\n\n#### `POST`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#post \"Direct link to post\")\n\n```\napp.post(`/post`, async (req, res) => {  const { title, content, authorEmail } = req.body  const result = await prisma.post.create({    data: {      title,      content,      published: false,      author: { connect: { email: authorEmail } },    },  })  res.json(result)})\n```\n\n#### `PUT`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#put \"Direct link to put\")\n\n```\napp.put('/publish/:id', async (req, res) => {  const { id } = req.params  const post = await prisma.post.update({    where: { id: Number(id) },    data: { published: true },  })  res.json(post)})\n```\n\n#### `DELETE`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#delete \"Direct link to delete\")\n\n```\napp.delete(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.post.delete({    where: {      id: Number(id),    },  })  res.json(post)})\n```\n\n## Ready-to-run example projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#ready-to-run-example-projects \"Direct link to Ready-to-run example projects\")\n\nYou can find several ready-to-run examples that show how to implement a REST API with Prisma Client, as well as build full applications, in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#typescript \"Direct link to TypeScript\")\n\n| **Example** | **Stack** | **Description** |\n| --- | --- | --- |\n| [`rest-express`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-express) | Backend only | REST API with Express for TypeScript |\n| [`rest-fastify`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-fastify) | Backend only | REST API using Fastify and Prisma Client. |\n| [`rest-hapi`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-hapi) | Backend only | REST API using hapi and Prisma Client |\n| [`rest-nestjs`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nestjs) | Backend only | Nest.js app (Express) with a REST API |\n| [`rest-nextjs-express`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-express) | Fullstack | Next.js app (React, Express) and Prisma Client |\n| [`rest-nextjs-api-routes`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes) | Fullstack | Next.js app (React) with a REST API |\n| [`rest-nextjs-api-routes-auth`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes-auth) | Fullstack | Implement authentication using NextAuth.js |\n\n### JavaScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#javascript \"Direct link to JavaScript\")\n\n| **Example** | **Stack** | **Description** |\n| --- | --- | --- |\n| [`rest-express`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-express) | Backend only | REST API using Express and Prisma Client |\n| [`rest-fastify`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-fastify) | Backend only | REST API using Fastify and Prisma Client |\n| [`rest-nextjs`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nextjs) | Fullstack | Next.js app (React) with a REST API |\n| [`rest-nuxtjs`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nuxtjs) | Fullstack | App with NuxtJs using Vue (frontend), Express, and Prisma Client |",
    "title": "Building REST APIs with Prisma ORM | Prisma Documentation",
    "description": "This page gives an overview of the most important things when building REST APIs with Prisma. It shows practical examples and the supported libraries.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack",
    "markdown": "# Building fullstack applications with Prisma ORM\n\nFullstack frameworks, such as Next.js, Remix or SvelteKit, blur the lines between the server and the client. These frameworks also provide different patterns for fetching and mutating data on the server.\n\nYou can query your database using Prisma Client, using your framework of choice, from the server-side part of your application.\n\n## Supported frameworks[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#supported-frameworks \"Direct link to Supported frameworks\")\n\nHere's a non-exhaustive list of frameworks and libraries you can use with Prisma ORM:\n\n*   [Next.js](https://nextjs.org/)\n*   [Remix](https://remix.run/)\n*   [SvelteKit](https://kit.svelte.dev/)\n*   [Nuxt](https://nuxt.com/)\n*   [Redwood](https://redwoodjs.com/)\n*   [t3 stack — using tRPC](https://create.t3.gg/)\n*   [Wasp](https://wasp-lang.dev/)\n\n## Fullstack app example (e.g. Next.js)[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#fullstack-app-example-eg-nextjs \"Direct link to Fullstack app example (e.g. Next.js)\")\n\ntip\n\nIf you want to learn how to build an app with Next.js and Prisma ORM, check out this comprehensive [video tutorial](https://www.youtube.com/watch?v=QXxy8Uv1LnQ&ab_channel=ByteGrad).\n\nAssume you have a Prisma schema that looks similar to this:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nYou can now implement the logic for querying your database using [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) inside `getServerSideProps`, `getStaticProps`, API routes, or using API libraries such as [tRPC](https://trpc.io/) and [GraphQL](https://graphql.org/).\n\n### `getServerSideProps`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#getserversideprops \"Direct link to getserversideprops\")\n\n```\n// (in /pages/index.tsx)// Alternatively, you can use `getStaticProps`// in place of `getServerSideProps`.export const getServerSideProps = async () => {  const feed = await prisma.post.findMany({    where: {      published: true,    },  })  return { props: { feed } }}\n```\n\nNext.js will pass the props to your React component where you can display the data from your database.\n\n### API Routes[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#api-routes \"Direct link to API Routes\")\n\n```\n// Fetch all posts (in /pages/api/posts.ts)const prisma = new PrismaClient()export default async function handle(req, res) {  const posts = await prisma.post.findMany({    where: {      published: true,    },  })  res.json(posts)}\n```\n\nNote that you can use Prisma ORM inside of Next.js API routes to send queries to your database – with REST, GraphQL, and tRPC.\n\nYou can then fetch data and display it in your frontend.\n\n## Ready-to-run fullstack example projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#ready-to-run-fullstack-example-projects \"Direct link to Ready-to-run fullstack example projects\")\n\nYou can find several ready-to-run examples that show how to fullstack apps with Prisma Client in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#typescript \"Direct link to TypeScript\")\n\n| **Example** | **Description** |\n| --- | --- |\n| [Next.js (API Routes)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes) | Fullstack Next.js app using `getServerSideProps` & API Routes |\n| [Next.js (GraphQL)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nextjs) | Fullstack Next.js app using GraphQL Yoga, Pothos, & Apollo Client |\n| [Next.js (tRPC)](https://github.com/prisma/prisma-examples/tree/latest/typescript/trpc-nextjs) | Fullstack Next.js app using tRPC |\n| [Next.js (API Routes with auth)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes-auth) | Fullstack Next.js app using `getServerSideProps`, API Routes, & [NextAuth](https://next-auth.js.org/) |\n| [Remix](https://github.com/prisma/prisma-examples/tree/latest/typescript/remix) | Fullstack Remix app using actions and loaders |\n| [SvelteKit](https://github.com/prisma/prisma-examples/tree/latest/typescript/sveltekit) | Fullstack Sveltekit app using actions and loaders |\n| [SvelteKit (REST API)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-sveltekit) | Fullstack Sveltekit app using API routes |\n| [Nuxt (REST API)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nuxtjs) | Fullstack Nuxt app using API routes |\n\n### JavaScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#javascript \"Direct link to JavaScript\")\n\n| **Example** | **Description** |\n| --- | --- |\n| [Next.js (API Routes)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nextjs) | Fullstack Next.js app using `getServerSideProps` & API Routes |\n| [SvelteKit (REST API)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-sveltekit) | Fullstack Sveltekit app using API routes |\n| [Nuxt (REST API)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nuxtjs) | Fullstack Nuxt app using API routes |",
    "title": "Building fullstack applications with Prisma ORM | Prisma Documentation",
    "description": "This page gives explains how to build fullstack applications with Prisma. It shows how Prisma fits in with fullstack frameworks and provides practical examples",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions",
    "markdown": "# Special rules for referential actions in SQL Server and MongoDB\n\nSome databases have specific requirements that you should consider if you are using referential actions.\n\n*   Microsoft SQL Server doesn't allow cascading referential actions on a foreign key, if the relation chain causes a cycle or multiple cascade paths. If the referential actions on the foreign key are set to something other than `NO ACTION` (or `NoAction` if Prisma ORM is managing referential integrity), the server will check for cycles or multiple cascade paths and return an error when executing the SQL.\n    \n*   With MongoDB, using referential actions in Prisma ORM requires that for any data model with self-referential relations or cycles between three models, you must set the referential action of `NoAction` to prevent the referential action emulations from looping infinitely. Be aware that by default, the `relationMode = \"prisma\"` mode is used for MongoDB, which means that Prisma ORM manages [referential integrity](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode).\n    \n\nGiven the SQL:\n\n```\nCREATE TABLE [dbo].[Employee] (  [id] INT NOT NULL IDENTITY(1,1),  [managerId] INT,  CONSTRAINT [PK__Employee__id] PRIMARY KEY ([id]));ALTER TABLE [dbo].[Employee]  ADD CONSTRAINT [FK__Employee__managerId]    FOREIGN KEY ([managerId]) REFERENCES [dbo].[Employee]([id])    ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nWhen the SQL is run, the database would throw the following error:\n\n```\nIntroducing FOREIGN KEY constraint 'FK__Employee__managerId' on table 'Employee' may cause cycles or multiple cascade paths. Specify ON DELETE NO ACTION or ON UPDATE NO ACTION, or modify other FOREIGN KEY constraints.\n```\n\nIn more complicated data models, finding the cascade paths can get complex. Therefore in Prisma ORM, the data model is validated _before_ generating any SQL to be run during any migrations, highlighting relations that are part of the paths. This makes it much easier to find and break these action chains.\n\n## Self-relation (SQL Server and MongoDB)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#self-relation-sql-server-and-mongodb \"Direct link to Self-relation (SQL Server and MongoDB)\")\n\nThe following model describes a self-relation where an `Employee` can have a manager and managees, referencing entries of the same model.\n\n```\nmodel Employee {  id        Int        @id @default(autoincrement())  manager   Employee?  @relation(name: \"management\", fields: [managerId], references: [id])  managees  Employee[] @relation(name: \"management\")  managerId Int?}\n```\n\nThis will result in the following error:\n\n```\nError parsing attribute \"@relation\": A self-relation must have `onDelete` and `onUpdate` referential actions set to `NoAction` in one of the @relation attributes. (Implicit default `onDelete`: `SetNull`, and `onUpdate`: `Cascade`)\n```\n\nBy not defining any actions, Prisma ORM will use the following default values depending if the underlying [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) are set to be optional or required.\n\n| Clause | All of the scalar fields are optional | At least one scalar field is required |\n| --- | --- | --- |\n| `onDelete` | `SetNull` | `NoAction` |\n| `onUpdate` | `Cascade` | `Cascade` |\n\nSince the default referential action for `onUpdate` in the above relation would be `Cascade` and for `onDelete` it would be `SetNull`, it creates a cycle and the solution is to explicitly set the `onUpdate` and `onDelete` values to `NoAction`.\n\n```\nmodel Employee {  id        Int        @id @default(autoincrement())  manager   Employee   @relation(name: \"management\", fields: [managerId], references: [id])  manager   Employee   @relation(name: \"management\", fields: [managerId], references: [id], onDelete: NoAction, onUpdate: NoAction)  managees  Employee[] @relation(name: \"management\")  managerId Int}\n```\n\n## Cyclic relation between three tables (SQL Server and MongoDB)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#cyclic-relation-between-three-tables-sql-server-and-mongodb \"Direct link to Cyclic relation between three tables (SQL Server and MongoDB)\")\n\nThe following models describe a cyclic relation between a `Chicken`, an `Egg` and a `Fox`, where each model references the other.\n\n```\nmodel Chicken {  id        Int   @id @default(autoincrement())  egg       Egg   @relation(fields: [eggId], references: [id])  eggId     Int  predators Fox[]}model Egg {  id         Int       @id @default(autoincrement())  predator   Fox       @relation(fields: [predatorId], references: [id])  predatorId Int  parents    Chicken[]}model Fox {  id        Int     @id @default(autoincrement())  meal      Chicken @relation(fields: [mealId], references: [id])  mealId    Int  foodStore Egg[]}\n```\n\nThis will result in three validation errors in every relation field that is part of the cycle.\n\nThe first one is in the relation `egg` in the `Chicken` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Chicken.egg → Egg.predator → Fox.meal. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe second one is in the relation `predator` in the `Egg` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Egg.predator → Fox.meal → Chicken.egg. (Implicit default `onUpdate`: `Cascade`)\n```\n\nAnd the third one is in the relation `meal` in the `Fox` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Fox.meal → Chicken.egg → Egg.predator. (Implicit default `onUpdate`: `Cascade`)\n```\n\nAs the relation fields are required, the default referential action for `onDelete` is `NoAction` but for `onUpdate` it is `Cascade`, which causes a referential action cycle. The solution is to set the `onUpdate` value to `NoAction` in any one of the relations.\n\n```\nmodel Chicken {  id        Int   @id @default(autoincrement())  egg       Egg   @relation(fields: [eggId], references: [id])  egg       Egg   @relation(fields: [eggId], references: [id], onUpdate: NoAction)  eggId     Int  predators Fox[]}\n```\n\nor\n\n```\nmodel Egg {  id         Int       @id @default(autoincrement())  predator   Fox       @relation(fields: [predatorId], references: [id])  predator   Fox       @relation(fields: [predatorId], references: [id], onUpdate: NoAction)  predatorId Int  parents    Chicken[]}\n```\n\nor\n\n```\nmodel Fox {  id        Int     @id @default(autoincrement())  meal      Chicken @relation(fields: [mealId], references: [id])  meal      Chicken @relation(fields: [mealId], references: [id], onUpdate: NoAction)  mealId    Int  foodStore Egg[]}\n```\n\n## Multiple cascade paths between two models (SQL Server only)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#multiple-cascade-paths-between-two-models-sql-server-only \"Direct link to Multiple cascade paths between two models (SQL Server only)\")\n\nThe data model describes two different paths between same models, with both relations triggering cascading referential actions.\n\n```\nmodel User {  id       Int       @id @default(autoincrement())  comments Comment[]  posts    Post[]}model Post {  id       Int       @id @default(autoincrement())  authorId Int  author   User      @relation(fields: [authorId], references: [id])  comments Comment[]}model Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  post        Post @relation(fields: [postId], references: [id])}\n```\n\nThe problem in this data model is how there are two paths from `Comment` to the `User`, and how the default `onUpdate` action in both relations is `Cascade`. This leads into two validation errors:\n\nThe first one is in the relation `writtenBy`:\n\n```\nError parsing attribute \"@relation\": When any of the records in model `User` is updated or deleted, the referential actions on the relations cascade to model `Comment` through multiple paths. Please break one of these paths by setting the `onUpdate` and `onDelete` to `NoAction`. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe second one is in the relation `post`:\n\n```\nError parsing attribute \"@relation\": When any of the records in model `User` is updated or deleted, the referential actions on the relations cascade to model `Comment` through multiple paths. Please break one of these paths by setting the `onUpdate` and `onDelete` to `NoAction`. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe error means that by updating a primary key in a record in the `User` model, the update will cascade once between the `Comment` and `User` through the `writtenBy` relation, and again through the `Post` model from the `post` relation due to `Post` being related with the `Comment` model.\n\nThe fix is to set the `onUpdate` referential action to `NoAction` in the `writtenBy` or `post` relation fields, or from the `Post` model by changing the actions in the `author` relation:\n\n```\nmodel Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  writtenBy   User @relation(fields: [writtenById], references: [id], onUpdate: NoAction)  post        Post @relation(fields: [postId], references: [id])}\n```\n\nor\n\n```\nmodel Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  post        Post @relation(fields: [postId], references: [id])  post        Post @relation(fields: [postId], references: [id], onUpdate: NoAction)}\n```\n\nor\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  authorId Int  author   User      @relation(fields: [authorId], references: [id])  author   User      @relation(fields: [authorId], references: [id], onUpdate: NoAction)  comments Comment[]}\n```",
    "title": "Special rules for referential actions in SQL Server and MongoDB | Prisma Documentation",
    "description": "Circular references or multiple cascade paths can cause validation errors on Microsoft SQL Server and MongoDB. Since the database does not handle these situations out of the box, learn how to solve this problem.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm",
    "markdown": "# Is Prisma ORM an ORM? | What is an ORM?\n\nTo answer the question briefly: _Yes, Prisma ORM is a new kind of ORM that fundamentally differs from traditional ORMs and doesn't suffer from many of the problems commonly associated with these_.\n\nTraditional ORMs provide an object-oriented way for working with relational databases by mapping tables to _model classes_ in your programming language. This approach leads to many problems that are caused by the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch).\n\nPrisma ORM works fundamentally different compared to that. With Prisma ORM, you define your models in the declarative [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) which serves as the single source of truth for your database schema and the models in your programming language. In your application code, you can then use Prisma Client to read and write data in your database in a type-safe manner without the overhead of managing complex model instances. This makes the process of querying data a lot more natural as well as more predictable since Prisma Client always returns plain JavaScript objects.\n\nIn this article, you will learn in more detail about ORM patterns and workflows, how Prisma ORM implements the Data Mapper pattern, and the benefits of Prisma ORM's approach.\n\n## What are ORMs?[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#what-are-orms \"Direct link to What are ORMs?\")\n\nIf you're already familiar with ORMs, feel free to jump to the [next section](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm) on Prisma ORM.\n\n### ORM Patterns - Active Record and Data Mapper[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#orm-patterns---active-record-and-data-mapper \"Direct link to ORM Patterns - Active Record and Data Mapper\")\n\nORMs provide a high-level database abstraction. They expose a programmatic interface through objects to create, read, delete, and manipulate data while hiding some of the complexity of the database.\n\nThe idea with ORMs is that you define your models as **classes** that map to tables in a database. The classes and their instances provide you with a programmatic API to read and write data in the database.\n\nThere are two common ORM patterns: [_Active Record_](https://en.wikipedia.org/wiki/Active_record_pattern) and [_Data Mapper_](https://en.wikipedia.org/wiki/Data_mapper_pattern) which differ in how they transfer data between objects and the database. While both patterns require you to define classes as the main building block, the most notable difference between the two is that the Data Mapper pattern decouples in-memory objects in the application code from the database and uses the data mapper layer to transfer data between the two. In practice, this means that with Data Mapper the in-memory objects (representing data in the database) don't even know that there’s a database present.\n\n#### Active Record[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#active-record \"Direct link to Active Record\")\n\n_Active Record_ ORMs map model classes to database tables where the structure of the two representations is closely related, e.g. each field in the model class will have a matching column in the database table. Instances of the model classes wrap database rows and carry both the data and the access logic to handle persisting changes in the database. Additionally, model classes can carry business logic specific to the data in the model.\n\nThe model class typically has methods that do the following:\n\n*   Construct an instance of the model from an SQL query.\n*   Construct a new instance for later insertion into the table.\n*   Wrap commonly used SQL queries and return Active Record objects.\n*   Update the database and insert into it the data in the Active Record.\n*   Get and set the fields.\n*   Implement business logic.\n\n#### Data Mapper[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#data-mapper \"Direct link to Data Mapper\")\n\n_Data Mapper_ ORMs, in contrast to Active Record, decouple the application's in-memory representation of data from the database's representation. The decoupling is achieved by requiring you to separate the mapping responsibility into two types of classes:\n\n*   **Entity classes**: The application's in-memory representation of entities which have no knowledge of the database\n*   **Mapper classes**: These have two responsibilities:\n    *   Transforming the data between the two representations.\n    *   Generating the SQL necessary to fetch data from the database and persist changes in the database.\n\nData Mapper ORMs allow for greater flexibility between the problem domain as implemented in code and the database. This is because the data mapper pattern allows you to hide the ways in which your database is implemented which isn’t an ideal way to think about your domain behind the whole data-mapping layer.\n\nOne of the reasons that traditional data mapper ORMs do this is due to the structure of organizations where the two responsibilities would be handled by separate teams, e.g., [DBAs](https://en.wikipedia.org/wiki/Database_administrator) and backend developers.\n\nIn reality, not all Data Mapper ORMs adhere to this pattern strictly. For example, [TypeORM](https://github.com/typeorm/typeorm/blob/master/docs/active-record-data-mapper.md#what-is-the-data-mapper-pattern), a popular ORM in the TypeScript ecosystem which supports both Active Record and Data Mapper, takes the following approach to Data Mapper:\n\n*   Entity classes use decorators (`@Column`) to map class properties to table columns and are aware of the database.\n*   Instead of mapper classes, _repository_ classes are used for querying the database and may contain custom queries. Repositories use the decorators to determine the mapping between entity properties and database columns.\n\nGiven the following `User` table in the database:\n\n![user-table](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAB+CAYAAAC9MirBAAAACXBIWXMAAAsSAAALEgHS3X78AAAQnElEQVR42u2dy09bZxbAzX9AZpHZwj4j0VW6JIuqMVQKVYCZ1dQzPGzPAjuZbtqNXWkyq7TQ8shMWsV5CCdVojKJ0kkbEOShtlI6xUqbOE4EOGCNggSxYQhpC63vnPM9rj9f3+sHfmDjc6QjuPd7+Nr++dzzffec77PZhCS8gcZE70VfvHd85nlvUCMlrRaN9wZnE/3Bt2xGSbgCTc97glH6kEirWnuCC8iqDq4OLfxd6b3QmnAEGm0kJFUgqz3nUTsURhcYn6t94w4JLQFLUo0CXIKe3SfhXekd99tWe4MhPEj0XjpCHxFJtQp4AqiHuM87Pm2T/gN9NCQ1YXU5r0kCl6RmBDhtIHBJCFwSEgK3yqSty+UA1Q53ulrV84f/4GrC822dLj99SgQugUtC4FYaXPvR/g44F7B3uWbsR11Dsk1rhxfU09jW7fLZu90TWPZaV1+L6If3Bf2wOvB6WOcNw+uRELhlAVfWs3dyMO2drhmEWIDZDP9H7ahQ1tbpnIDjpP2ouwP6tYEeYn1143lnAspnDxO4BG4lwAVQz7J6Ha4mQ3vUPyGosgwAbmBWucs1rYILxwvG9iQEblnBxXJ2DFaVWVoDpKIsoCjUc8YVcJP2zn4vfeIEbsV9XDwnLS+zoN393hS44AKkg4t6RgUXX4s+cQK3JCIGXJrRGupAd7sz4kQ51M4QwgogNwiYkzBIywhiInAJ3LJIR4ej0c5v64l2gBQtr73L6ZGDLd0lAMDZYAuOUXm5M5Tmw3a7P8PZBCzHuqI/ApfALY8IF0D6qdwNgGN1IAXw+dPKGex8ygug5mBz/1fUccbRlSBwCdyyC97qEVazW74OsLC4FmVZy0kIXBICl4SEwCUhIXBJCFwCl4TAJSGpGLjb/54lJa16JXBJ9wa4dCMiIR+XhITAJSEhcEkIXBISApeEhMAlIXB3VbTw8gEtsujRHsU+1h4tXStII7Eh1vbJ8kH6ygncygB7f3k/wHeiYFitNLz4iXZ/bj999QRuGaF92qyFly6WDNqUXtQiT5vp669zcGVyoFU5Jhmy5Yiy1DG1tOWBNgUvWd76BrcdU6+7nCGr8p0sCsdu6SbAbZycmt848cUS6ouRmcjWzR9uybKfP/323sbJyfm0+sPTjzc+mn5sAe8JQqCOwW3r+kuLzGItBbja/eirVpYyPnBlM/HXiXUEd/3dayt4vS9O33mAZQhyAsplXTyOD1x+uX03MmVpeeeWDhAG9eoqdPZ71cUwMPNVXY1QX5IoX3DDMU82cBFIeYzwrvuvPzOCizDje9m6+f3t7DMOix7CoG4triuKawukQOZLD7H1B/hqhNGCwH24+GHe4Po+f7b2ztVVFdxtcB/wffz48Z0f8pllIAwIXOE28EXdVItcELhZQENw133Xn/10/ptZdBfwel+e+zqkuwbuS1tYB/8mv1u4kc9AjTAgcPX1tV7vdB7ZsY+bA9zn4LcyFwEAltBKcPH6N9FNcF/aRrAJXAI3T4trvqJhYeBaPx0zugqqqj7u1tXQV/hecKYh11M1woDA1deGVVc01N2HfMGN5D84swIXdfP9yXl0GX65+3iSBmcEblZw8WFDO1//NYoQ8xUNxSJxec8qLB0oBbjo46JbIQdvpvokRvELBK487mtJrUaI68L2exnMhTyAKGV8As0oELiFSK7VDLOCO1fmR77Y9xw98iVwyyAYCFMWeMMUZEPglhtetLw7icG11hNkaQncygH8MHaQzTaEY0OFwwrgYyB5mOISCFwSEgKXhITAJSFwSUgIXBKS6gNXblHPg8fZTuCt7SY7LZKQVA24qU2X3SEMHEdw5W6KxVwcPnV7LUtK0F4Qr3/U5vWNtpSuv0HUJgI3H2srdlJUIcMYXGNoY6GCMQ5qDMSeg9Y3DJANt3r9p86UDtqh5mP+0WkCNw9rK6O/ML9MBtIw10EJbWR5acwy97Ww3cL1en0t2A5dDDyP7gXbtZFbcbZHLtY1bvxseh34GrhlqeiP5bspOzdiv2Lv3YBZuVUfyvWwdmYukNqvsRzPG+8cwjK+ApDNHPOPhcDy+o+9N/aWUtYCZUPH/acCqfOjqC1e35jXCD/WQUt73D82CP1FsT9UAjeLVWQuAovB5fDxL5LBHFW+vGhbt3OCR4k5QwwaAISHQLpDHHrnRFunm7kXeMzT3lmUWcDe6RzMx+rLSDWR66ap18DXd2Ahl+yHIzeUloFAah+8juzDHZLtZNSbCmd7t3OQRcEh7DLfrpv/0MSaEhqCbW5txyZAbwFkDvjbkbKaOnwOADgEQH4gyvaxMoBXqbsgLHcT/H9W/BAc4II4CNw8oFGtlym4HApHpm9svuGyMVwyn2tIC2A/6hwyXpcarWbM1jDtA35kah8SRPkDle9BzXLmr5v6QVhFyAkL6lddBYC0gVnhNOvLYE3C/42izSsc1kEAdeTscWFZAVSbAJ1chVKCa4QQIVB2EQ+YpPsUDK56S9bBNLgDom4A7wBm4Kp98PfhTBivS4Ir27Tz9xtg7o7YXT3XBtPm4I4BuGManAvI2z1zI/yjcTjXygEdg3ZjXjiXQIBTVpzArQi4chDHBmECYPQRiwFXvQYjuPyWzn8kzCeVFtkAbrb3YQWudJNUzRWLnA1c9G9VcEW9pvRB2JiGLgSBuwvgpvUjQJIWr5TgGm/x3I/mGclFgWuRHJr3VJi5q6BbV4uZA+bnHntv1MNdBmmJCdyKgIszCjjIQVCxrRzYSHDlbZqV5wAjX3CxT9mf9LuLATcjx66DTwOm+bwmswoctBEAbcSrgiZhBiBn5XysHMhxsEca0K9F2MX5Q1A3jnUNx40EbtnAxexf9qVran6aahHV3LViXQVl1oC/FvSP0BUDrnR35CBO0YBeZpEommY9mXKAAdwG0CHuMrDzCTieTllUtLKBxvS6UK73NxoSfS4QuGUUZqWyDGSKyV0zCpuTzTFoKrZv47Xm9nVPoTZJGPm5AGqj8Xx+LkhmfwTuLgoOqNACGrVNWTWHpD6kpsCVFs2opbLGJAQuCQmBS0JC4JIQuCQkBC4JCYFLQuDmIfYujEPNHuhNQlJ14BYSDJNLKM9sJ/3VR55ZVYNLeWY7gbY+8szKDi4LLOl2+axzsKo7zwxfu5g8MzjXQHlmNQguh841o+ZgqdFSu5Vnxq6nRHlmPFg8M88MXs92pMOxD46TheWZIdCF5pkB0HWUZ1ZxV0ENDZQ5Wq9bBMbUap4Zh9cZx9cCLVeeWbye88zKDi67zWJ6OlpUnsYSleDu8TyzZGnzzBBcyjOrCLgicDoqb6MMYEMwdmaeWcolKHeembytlynP7EyZ88xeqec8s7KCK7c/VS2pGQjGW3vF8swM11dDeWbN9Z5nVhFw0YqyPLLfs5G3PmCyyjOT4OyFPDOrWQUO2s7zzKDNoJJXtqDkmb1ZD3lmZQXX4MOKHdQZHALc3Hlm7Xp5zeWZnYHzWNZc+Twz2d/ezTMrObimc6x55JHt1TyzbLMKKYApz6wqwS2VUJ4ZSU2CS3lmJDUJLgkJgUtC4JKQELgkRYn2aKmhrBqJgS7atCfLBG7dwxZeRj3A9hgu7SbbpddIbIhd55Plg1p4sUG7P0fg1h2w95dR97Nd3KsZVisNL34C4O7XIk8J3J2IDBCXDxbeEEHf5XrQUBpon6I2a+GlizUJbUqDAG7zblremgVXPtqVcb2FBr6w5/wlerYvAsEbs+V9CUv72z0AbQpesLwE7g4E4w70TIYCwT3OshBONZUGXB47kC37gPmGeJvd8S06xzmr8nAeba36y9ae6wltbqm2wc2Wn4VQsegpkzqYmya3UjXe5lk+mJJLZtwAEINYlHDINHBxd0tsY3atPDQQA7L1+NcWBUIHy/liZSkL6vWNeA31ZHhik4jWivIfA54bbk23tlHUV62AjHuubG5N/nBLntu++2hKPwfl6/7Pn629PbGW/M/8DVnn50/v3dv4+xdLav3tu5Ep2efG8PTj+MCVTfw+sS0ey7Y/XQ19hfXV60g7h9cEbZl6uL44feeByfVfBXAP1Cy4IjGSBVYreWN6TK2MtjLmcLG4A5ErZswFE+2i6XuSpcA0bjWVkZIj4nzNHg2LaCsNAeZ5X9zyYtIhHM+Icz6RA9bC2wx38GN0CVhAi4+FIfKwQlHGMhgcxtRzLRxD9ViBi5/5FoCjgqufQ3Dfubby3H1pe+Pk5LwO2vlvZtfeubqq1mfgQv3/nby5EB+4/BLbb9+JTL0893UI20v4EFKsbwRXPyeuCetjH6wf+aPImHFY9NQkuGbB2hnWryt9+yQe2sjAjRrbWO95JtqIEMhc4MoBnNV1i1SZlEXFrFkGnxqthVb3VEA95nDLZEXeXuaMWbkK2kNwEx4ufrhjcN+9trJx4osltZ4VuL+CVcb/X57/OqS+zovhmUjcfWmrEHDl62dxFXCW4eOaBFcCpOZfybwuCZVFfGsa7Gab9fHtVnkKuN6niHHNB9xskgGuD4O7UyneqHjrx3PKIKxRxMrGZWJjXuDyifxrxYCLVnPz/cl5vO3jOStwt798cIu1VVwPFUysky+42D/+YFAtLS64CzUNrl0FV6jB4hYEbsr9wDBGzBVze8sKLs9ACGXkfCnrGfB2mInAs20rDS76uPyWf/uBJbg3ObhG0HYCLvrQL0ZmIqh7D9wsu8oYfdyCwDWu1SBchTKCi35vKGsbnu8V5dm2LM2mMT9wYw2WT8cEJD/CYEsHV7WaCrhYtnn67gO85W9+NBMxAzcpXYVziqsAfeCxdBUk3MbBnqmrkPup2mDNDs5knhjOFKAfiyN9tJjFgqvnnmFumvCT8wVXpqRnATd67L1/HEl3A0YTx2HQpZ7D1WXkvK9IaGySoMpsW/jbgG7FcYtVZODLRbUcnCGY677rz36583jy12/nbzB/dODyplqugyiO5a3cbHCGfSU8VzaxP+ZWiBmDzfen2OBOWm422IPyX+/N38A2a+/y/iS4+Jrbtx9NoSa/TUFuGJwN1Cy4PN1cX7GGq1idZqfgHk4N1vS8NJbjlSe42WYVuE/LrCbmd4UkwDiDIPO99L/Cl+XTXWIRjtR+YiwzV0lYFP2NetJnFZZQf2dltRC8xNufrcvPf+3tf61t3fz+dhq4ymBLggqgrejHfcGkvJ0jmHibl/2hSmjTLOzA5Zf6awK06nSa2pbNMIC7YDod9iR2sOYfQFjt81WMFNNf7sU5eH5Xvudz9JW1nfBzs8YnJL9buIHTV6V8wrX15fe3EVB1Ki3tRwOvh6+7w7iFXZlRoCCbSsYpzC2j4iPfYKUfzyK8aNGNU2TFBdvA+5ijR771AW/kqY0Fp+wCvKWNEONBNrv5WRK4u2N592uPYqeZj1hb0OL1/m03LS2Bu9sAP4yhHmSzDeHYkICiShV+ZJHFAbC0B6rl8yNwSWpSCFwSApeEhMAlISFwSQhcEpJqBTfhCNCCciRVK//t/yewOp4CN947PoMHK70XWunjIalG0fx+22rfedtqz4U3kdXV3uCsbaV33M8o7glGyeqSVBuwCU/Attp/wZYYOPsbZBStbaIn+EcbwipOMHhXe4Id9JGl+VSku6V9wYaE5+w+8AYOKYzO619QwnGxSS8gJa1OTSK0yGqGhVn987gD/IdQ3X9ApFWlq73j0+DS+lRX9v/2CuVQIST8YQAAAABJRU5ErkJggg==)\n\nThis is what the corresponding entity class would look like:\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ name: 'first_name' })  firstName: string  @Column({ name: 'last_name' })  lastName: string  @Column({ unique: true })  email: string}\n```\n\n### Schema migration workflows[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#schema-migration-workflows \"Direct link to Schema migration workflows\")\n\nA central part of developing applications that make use of a database is changing the database schema to accommodate new features and to better fit the problem you're solving. In this section, we'll discuss what [schema migrations](https://www.prisma.io/dataguide/types/relational/what-are-database-migrations) are and how they affect the workflow.\n\nBecause the ORM sits between the developer and the database, most ORMs provide a **migration tool** to assist with the creation and modification of the database schema.\n\nA migration is a set of steps to take the database schema from one state to another. The first migration usually creates tables and indices. Subsequent migrations may add or remove columns, introduce new indices, or create new tables. Depending on the migration tool, the migration may be in the form of SQL statements or programmatic code which will get converted to SQL statements (as with [ActiveRecord](https://guides.rubyonrails.org/active_record_migrations.html) and [SQLAlchemy](https://alembic.sqlalchemy.org/en/latest/tutorial.html#create-a-migration-script)).\n\nBecause databases usually contain data, migrations assist you with breaking down schema changes into smaller units which helps avoid inadvertent data loss.\n\nAssuming you were starting a project from scratch, this is what a full workflow would look like: you create a migration that will create the `User` table in the database schema and define the `User` entity class as in the example above.\n\nThen, as the project progresses and you decide you want to add a new `salutation` column to the `User` table, you would create another migration which would alter the table and add the `salutation` column.\n\nLet's take a look at how that would look like with a TypeORM migration:\n\n```\nimport { MigrationInterface, QueryRunner } from 'typeorm'export class UserRefactoring1604448000 implements MigrationInterface {  async up(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(`ALTER TABLE \"User\" ADD COLUMN \"salutation\" TEXT`)  }  async down(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(`ALTER TABLE \"User\" DROP COLUMN \"salutation\"`)  }}\n```\n\nOnce a migration is carried out and the database schema has been altered, the entity and mapper classes must also be updated to account for the new `salutation` column.\n\nWith TypeORM that means adding a `salutation` property to the `User` entity class:\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ name: 'first_name' })  firstName: string  @Column({ name: 'last_name' })  lastName: string  @Column({ unique: true })  email: string  @Column()  salutation: string}\n```\n\nSynchronizing such changes can be a challenge with ORMs because the changes are applied manually and are not easily verifiable programmatically. Renaming an existing column can be even more cumbersome and involve searching and replacing references to the column.\n\n> **Note:** Django's [makemigrations](https://docs.djangoproject.com/en/3.1/ref/django-admin/#django-admin-makemigrations) CLI generates migrations by inspecting changes in models which, similar to Prisma ORM, does away with the synchronization problem.\n\nIn summary, evolving the schema is a key part of building applications. With ORMs, the workflow for updating the schema involves using a migration tool to create a migration followed by updating the corresponding entity and mapper classes (depending on the implementation). As you'll see, Prisma ORM takes a different approach to this.\n\nNow that you've seen what migrations are and how they fit into the development workflows, you will learn more about the benefits and drawbacks of ORMs.\n\n### Benefits of ORMs[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#benefits-of-orms \"Direct link to Benefits of ORMs\")\n\nThere are different reasons why developers choose to use ORMs:\n\n*   ORMs facilitate implementing the domain model. The domain model is an object model that incorporates the behavior and data of your business logic. In other words, it allows you to focus on real business concepts rather than the database structure or SQL semantics.\n*   ORMs help reduce the amount of code. They save you from writing repetitive SQL statements for common CRUD (Create Read Update Delete) operations and escaping user input to prevent vulnerabilities such as SQL injections.\n*   ORMs require you to write little to no SQL (depending on your complexity you may still need to write the odd raw query). This is beneficial for developers who are not familiar with SQL but still want to work with a database.\n*   Many ORMs abstract database-specific details. In theory, this means that an ORM can make changing from one database to another easier. It should be noted that in practice applications rarely change the database they use.\n\nAs with all abstractions that aim to improve productivity, there are also drawbacks to using ORMs.\n\n### Drawbacks of ORMs[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#drawbacks-of-orms \"Direct link to Drawbacks of ORMs\")\n\nThe drawbacks of ORMs are not always apparent when you start using them. This section covers some of the commonly accepted ones:\n\n*   With ORMs, you form an object graph representation of database tables which may lead to the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). This happens when the problem you are solving forms a complex object graph which doesn't trivially map to a relational database. Synchronizing between two different representations of data, one in the relational database, and the other in-memory (with objects) is quite difficult. This is because objects are more flexible and varied in the way they can relate to each other compared to relational database records.\n*   While ORMs handle the complexity associated with the problem, the synchronization problem doesn't go away. Any changes to the database schema or the data model require the changes to be mapped back to the other side. This burden is often on the developer. In the context of a team working on a project, database schema changes require coordination.\n*   ORMs tend to have a large API surface due to the complexity they encapsulate. The flip side of not having to write SQL is that you spend a lot of time learning how to use the ORM. This applies to most abstractions, however without understanding how the database works, improving slow queries can be difficult.\n*   Some _complex queries_ aren't supported by ORMs due to the flexibility that SQL offers. This problem is alleviated by raw SQL querying functionality in which you pass the ORM a SQL statement string and the query is run for you.\n\nNow that the costs and benefits of ORMs have been covered, you can better understand what Prisma ORM is and how it fits in.\n\n## Prisma ORM[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm \"Direct link to Prisma ORM\")\n\nPrisma ORM is a **next-generation ORM** that makes working with databases easy for application developers and features the following tools:\n\n*   [**Prisma Client**](https://www.prisma.io/docs/orm/prisma-client): Auto-generated and type-safe database client for use in your application.\n*   [**Prisma Migrate**](https://www.prisma.io/docs/orm/prisma-migrate): A declarative data modeling and migration tool.\n*   [**Prisma Studio**](https://www.prisma.io/docs/orm/tools/prisma-studio): A modern GUI for browsing and managing data in your database.\n\n> **Note:** Since Prisma Client is the most prominent tool, we often refer to it as simply Prisma.\n\nThese three tools use the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) as a single source of truth for the database schema, your application's object schema, and the mapping between the two. It's defined by you and is your main way of configuring Prisma ORM.\n\nPrisma ORM makes you productive and confident in the software you're building with features such as _type safety_, rich auto-completion, and a natural API for fetching relations.\n\nIn the next section, you will learn about how Prisma ORM implements the Data Mapper ORM pattern.\n\n### How Prisma ORM implements the Data Mapper pattern[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#how-prisma-orm-implements-the-data-mapper-pattern \"Direct link to How Prisma ORM implements the Data Mapper pattern\")\n\nAs mentioned earlier in the article, the Data Mapper pattern aligns well with organizations where the database and application are owned by different teams.\n\nWith the rise of modern cloud environments with managed database services and DevOps practices, more teams embrace a cross-functional approach, whereby teams own both the full development cycle including the database and operational concerns.\n\nPrisma ORM enables the evolution of the DB schema and object schema in tandem, thereby reducing the need for deviation in the first place, while still allowing you to keep your application and database somewhat decoupled using `@map` attributes. While this may seem like a limitation, it prevents the domain model's evolution (through the object schema) from getting imposed on the database as an afterthought.\n\nTo understand how Prisma ORM's implementation of the Data Mapper pattern differs conceptually to traditional Data Mapper ORMs, here's a brief comparison of their concepts and building blocks:\n\n| Concept | Description | Building block in traditional ORMs | Building block in Prisma ORM | Source of truth in Prisma ORM |\n| --- | --- | --- | --- | --- |\n| Object schema | The in-memory data structures in your applications | Model classes | Generated TypeScript types | Models in the Prisma schema |\n| Data Mapper | The code which transforms between the object schema and the database | Mapper classes | Generated functions in Prisma Client | @map attributes in the Prisma schema |\n| Database schema | The structure of data in the database, e.g., tables and columns | SQL written by hand or with a programmatic API | SQL generated by Prisma Migrate | Prisma schema |\n\nPrisma ORM aligns with the Data Mapper pattern with the following added benefits:\n\n*   Reducing the boilerplate of defining classes and mapping logic by generating a Prisma Client based on the Prisma schema.\n*   Eliminating the synchronization challenges between application objects and the database schema.\n*   Database migrations are a first-class citizen as they're derived from the Prisma schema.\n\nNow that we've talked about the concepts behind Prisma ORM's approach to Data Mapper, we can go through how the Prisma schema works in practice.\n\n### Prisma schema[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-schema \"Direct link to Prisma schema\")\n\nAt the heart of Prisma's implementation of the Data Mapper pattern is the _Prisma schema_ – a single source of truth for the following responsibilities:\n\n*   Configuring how Prisma connects to your database.\n*   Generating Prisma Client – the type-safe ORM for use in your application code.\n*   Creating and evolving the database schema with Prisma Migrate.\n*   Defining the mapping between application objects and database columns.\n\nModels in Prisma ORM mean something slightly different to Active Record ORMs. With Prisma ORM, models are defined in the Prisma schema as abstract entities which describe tables, relations, and the mappings between columns to properties in Prisma Client.\n\nAs an example, here's a Prisma schema for a blog:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String? @map(\"post_content\")  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nHere's a break down of the example above:\n\n*   The `datasource` block defines the connection to the database.\n*   The `generator` block tells Prisma ORM to generate Prisma Client for TypeScript and Node.js.\n*   The `Post` and `User` models map to database tables.\n*   The two models have a _1-n_ relation where each `User` can have many related `Post`s.\n*   Each field in the models has a type, e.g. the `id` has the type `Int`.\n*   Fields may contain field attributes to define:\n    *   Primary keys with the `@id` attribute.\n    *   Unique keys with the `@unique` attribute.\n    *   Default values with the `@default` attribute.\n    *   Mapping between table columns and Prisma Client fields with the `@map` attribute, e.g., the `content` field (which will be accessible in Prisma Client) maps to the `post_content` database column.\n\nThe `User` / `Post` relation can be visualized with the following diagram:\n\n![1-n relation between User and Post](https://www.prisma.io/docs/assets/images/user-post-relation-1-n-bb9740243c22ae8f3685667ee2cce56f.png)\n\nAt a Prisma ORM level, the `User` / `Post` relation is made up of:\n\n*   The scalar `authorId` field, which is referenced by the `@relation` attribute. This field exists in the database table – it is the foreign key that connects Post and User.\n*   The two relation fields: `author` and `posts` **do not exist** in the database table. Relation fields define connections between models at the Prisma ORM level and exist only in the Prisma schema and generated Prisma Client, where they are used to access the relations.\n\nThe declarative nature of Prisma schema is concise and allows defining the database schema and corresponding representation in Prisma Client.\n\nIn the next section, you will learn about Prisma ORM's supported workflows.\n\n### Prisma ORM workflow[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm-workflow \"Direct link to Prisma ORM workflow\")\n\nThe workflow with Prisma ORM is slightly different to traditional ORMs. You can use Prisma ORM when building new applications from scratch or adopt it incrementally:\n\n*   _New application_ (greenfield): Projects that have no database schema yet can use Prisma Migrate to create the database schema.\n*   _Existing application_ (brownfield): Projects that already have a database schema can be [introspected](https://www.prisma.io/docs/orm/prisma-schema/introspection) by Prisma ORM to generate the Prisma schema and Prisma Client. This use-case works with any existing migration tool and is useful for incremental adoption. It's possible to switch to Prisma Migrate as the migration tool. However, this is optional.\n\nWith both workflows, the Prisma schema is the main configuration file.\n\n#### Workflow for incremental adoption in projects with an existing database[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-incremental-adoption-in-projects-with-an-existing-database \"Direct link to Workflow for incremental adoption in projects with an existing database\")\n\nBrownfield projects typically already have some database abstraction and schema. Prisma ORM can integrate with such projects by introspecting the existing database to obtain a Prisma schema that reflects the existing database schema and to generate Prisma Client. This workflow is compatible with any migration tool and ORM which you may already be using. If you prefer to incrementally evaluate and adopt, this approach can be used as part of a [parallel adoption strategy](https://en.wikipedia.org/wiki/Parallel_adoption).\n\nA non-exhaustive list of setups compatible with this workflow:\n\n*   Projects using plain SQL files with `CREATE TABLE` and `ALTER TABLE` to create and alter the database schema.\n*   Projects using a third party migration library like [db-migrate](https://github.com/db-migrate/node-db-migrate) or [Umzug](https://github.com/sequelize/umzug).\n*   Projects already using an ORM. In this case, database access through the ORM remains unchanged while the generated Prisma Client can be incrementally adopted.\n\nIn practice, these are the steps necessary to introspect an existing DB and generate Prisma Client:\n\n1.  Create a `schema.prisma` defining the `datasource` (in this case, your existing DB) and `generator`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://janedoe:janedoe@localhost:5432/hello-prisma\"}generator client {  provider = \"prisma-client-js\"}\n```\n\n2.  Run `prisma db pull` to populate the Prisma schema with models derived from your database schema.\n3.  (Optional) Customize [field and model mappings](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections) between Prisma Client and the database.\n4.  Run `prisma generate`.\n\nPrisma ORM will generate Prisma Client inside the `node_modules` folder, from which it can be imported in your application. For more extensive usage documentation, see the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) docs.\n\nTo summarize, Prisma Client can be integrated into projects with an existing database and tooling as part of a parallel adoption strategy. New projects will use a different workflow detailed next.\n\n#### Workflow for new projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-new-projects \"Direct link to Workflow for new projects\")\n\nPrisma ORM is different from ORMs in terms of the workflows it supports. A closer look at the steps necessary to create and change a new database schema is useful for understanding Prisma Migrate.\n\nPrisma Migrate is a CLI for declarative data modeling & migrations. Unlike most migration tools that come as part of an ORM, you only need to describe the current schema, instead of the operations to move from one state to another. Prisma Migrate infers the operations, generates the SQL and carries out the migration for you.\n\nThis example demonstrates using Prisma ORM in a new project with a new database schema similar to the blog example above:\n\n1.  Create the Prisma schema:\n\n```\n// schema.prismadatasource db {  provider = \"postgresql\"  url      = \"postgresql://janedoe:janedoe@localhost:5432/hello-prisma\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String? @map(\"post_content\")  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\n2.  Run `prisma migrate` to generate the SQL for the migration, apply it to the database, and generate Prisma Client.\n\nFor any further changes to the database schema:\n\n1.  Apply changes to the Prisma schema, e.g., add a `registrationDate` field to the `User` model\n2.  Run `prisma migrate` again.\n\nThe last step demonstrates how declarative migrations work by adding a field to the Prisma schema and using Prisma Migrate to transform the database schema to the desired state. After the migration is run, Prisma Client is automatically regenerated so that it reflects the updated schema.\n\nIf you don't want to use Prisma Migrate but still want to use the type-safe generated Prisma Client in a new project, see the next section.\n\n##### Alternative for new projects without Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#alternative-for-new-projects-without-prisma-migrate \"Direct link to Alternative for new projects without Prisma Migrate\")\n\nIt is possible to use Prisma Client in a new project with a third-party migration tool instead of Prisma Migrate. For example, a new project could choose to use the Node.js migration framework [db-migrate](https://github.com/db-migrate/node-db-migrate) to create the database schema and migrations and Prisma Client for querying. In essence, this is covered by the [workflow for existing databases](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-incremental-adoption-in-projects-with-an-existing-database).\n\n## Accessing data with Prisma Client[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#accessing-data-with-prisma-client \"Direct link to Accessing data with Prisma Client\")\n\nSo far, the article covered the concepts behind Prisma ORM, its implementation of the Data Mapper pattern, and the workflows it supports. In this last section, you will see how to access data in your application using Prisma Client.\n\nAccessing the database with Prisma Client happens through the query methods it exposes. All queries return plain old JavaScript objects. Given the blog schema from above, fetching a user looks as follows:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()const user = await prisma.user.findUnique({  where: {    email: 'alice@prisma.io',  },})\n```\n\nIn this query, the `findUnique()` method is used to fetch a single row from the `User` table. By default, Prisma ORM will return all the scalar fields in the `User` table.\n\n> **Note:** The example uses TypeScript to make full use of the type safety features offered by Prisma Client. However, Prisma ORM also works with [JavaScript in Node.js](https://dev.to/prisma/productive-development-with-prisma-s-zero-cost-type-safety-4od2).\n\nPrisma Client maps queries and results to [structural types](https://en.wikipedia.org/wiki/Structural_type_system) by generating code from the Prisma schema. This means that `user` has an associated type in the generated Prisma Client:\n\n```\nexport type User = {  id: number  email: string  name: string | null}\n```\n\nThis ensures that accessing a non-existent field will raise a type error. More broadly, it means that the result's type for every query is known ahead of running the query, which helps catch errors. For example, the following code snippet will raise a type error:\n\n```\nconsole.log(user.lastName) // Property 'lastName' does not exist on type 'User'.\n```\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#fetching-relations \"Direct link to Fetching relations\")\n\nFetch relations with Prisma Client is done with the `include` option. For example, to fetch a user and their posts would be done as follows:\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'alice@prisma.io',  },  include: {    posts: true,  },})\n```\n\nWith this query, `user`'s type will also include `Post`s which can be accessed with the `posts` array field:\n\n```\nconsole.log(user.posts[0].title)\n```\n\nThe example only scratches the surface of Prisma Client's API for [CRUD operations](https://www.prisma.io/docs/orm/prisma-client/queries/crud) which you can learn more about in the docs. The main idea is that all queries and results are backed by types and you have full control over how relations are fetched.\n\n## Conclusion[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#conclusion \"Direct link to Conclusion\")\n\nIn summary, Prisma ORM is a new kind of Data Mapper ORM that differs from traditional ORMs and doesn't suffer from the problems commonly associated with them.\n\nUnlike traditional ORMs, with Prisma ORM, you define the Prisma schema – a declarative single source of truth for the database schema and application models. All queries in Prisma Client return plain JavaScript objects which makes the process of interacting with the database a lot more natural as well as more predictable.\n\nPrisma ORM supports two main workflows for starting new projects and adopting in an existing project. For both workflows, your main avenue for configuration is via the Prisma schema.\n\nLike all abstractions, both Prisma ORM and other ORMs hide away some of the underlying details of the database with different assumptions.\n\nThese differences and your use case all affect the workflow and cost of adoption. Hopefully understanding how they differ can help you make an informed decision.",
    "title": "Is Prisma ORM an ORM? | What is an ORM? | Prisma Documentation",
    "description": "Learn about how Prisma ORM implements the Data Mapper ORM pattern and how it achieves the same goal as traditional ORMs without requiring you to map classes to tables as traditional ORMs do.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/introduction/data-modeling",
    "markdown": "# Data modeling with Prisma | Prisma Documentation\n\n## What is data modeling?[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#what-is-data-modeling \"Direct link to What is data modeling?\")\n\nThe term _data modeling_ refers to the **process of defining the shape and structure of the objects in an application**, these objects are often called \"application models\". In relational databases (like PostgreSQL), they are stored in _tables_ . When using document databases (like MongoDB), they are stored in _collections_.\n\nDepending on the domain of your application, the models will be different. For example, if you're writing a blogging application, you might have models such as _blog_, _author_, _article_. When writing a car-sharing app, you probably have models like _driver_, _car_, _route_. Application models enable you to represent these different entities in your code by creating respective _data structures_.\n\nWhen modeling data, you typically ask questions like:\n\n*   What are the main entities/concepts in my application?\n*   How do they relate to each other?\n*   What are their main characteristics/properties?\n*   How can they be represented with my technology stack?\n\n## Data modeling without Prisma ORM[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-without-prisma-orm \"Direct link to Data modeling without Prisma ORM\")\n\nData modeling typically needs to happen on (at least) two levels:\n\n*   On the **database** level\n*   On the **application** level (i.e., in your programming language)\n\nThe way that the application models are represented on both levels might differ due to a few reasons:\n\n*   Databases and programming languages use different data types\n*   Relations are represented differently in a database than in a programming language\n*   Databases typically have more powerful data modeling capabilities, like indexes, cascading deletes, or a variety of additional constraints (e.g. unique, not null, ...)\n*   Databases and programming languages have different technical constraints\n\n### Data modeling on the database level[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-on-the-database-level \"Direct link to Data modeling on the database level\")\n\n#### Relational databases[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#relational-databases \"Direct link to Relational databases\")\n\nIn relational databases, models are represented by _tables_. For example, you might define a `users` table to store information about the users of your application. Using PostgreSQL, you'd define it as follows:\n\n```\nCREATE TABLE users (  user_id SERIAL PRIMARY KEY NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL,  isAdmin BOOLEAN NOT NULL DEFAULT false);\n```\n\nA visual representation of the `users` table with some random data might look as follows:\n\n| `user_id` | `name` | `email` | `isAdmin` |\n| --- | --- | --- | --- |\n| `1` | `Alice` | `alice@prisma.io` | `false` |\n| `2` | `Bob` | `bob@prisma.io` | `false` |\n| `3` | `Sarah` | `sarah@prisma.io` | `true` |\n\nIt has the following columns:\n\n*   `user_id`: An integer that increments with every new record in the `users` table. It also represents the [primary key](https://en.wikipedia.org/wiki/Primary_key) for each record.\n*   `name`: A string with at most 255 characters.\n*   `email`: A string with at most 255 characters. Additionally, the added constraints express that no two records can have duplicate values for the `email` column, and that _every_ record needs to have a value for it.\n*   `isAdmin`: A boolean that indicates whether the user has admin rights (default value: `false`)\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#mongodb \"Direct link to MongoDB\")\n\nIn MongoDB databases, models are represented by _collections_ and contain _documents_ that can have any structure:\n\n```\n{  _id: '607ee94800bbe41f001fd568',  slug: 'prisma-loves-mongodb',  title: 'Prisma <3 MongoDB',  body: \"This is my first post. Isn't MongoDB + Prisma awesome?!\"}\n```\n\nPrisma Client currently expects a consistent model and [normalized model design](https://docs.mongodb.com/manual/core/data-model-design/#normalized-data-models). This means that:\n\n*   If a model or field is not present in the Prisma schema, it is ignored\n*   If a field is mandatory but not present in the MongoDB dataset, you will get an error\n\n### Data modeling on the application level[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-on-the-application-level \"Direct link to Data modeling on the application level\")\n\nIn addition to creating the tables that represent the entities from your application domain, you also need to create application models in your programming language. In object-oriented languages, this is often done by creating _classes_ to represent your models. Depending on the programming language, this might also be done with _interfaces_ or _structs_.\n\nThere often is a strong correlation between the tables in your database and the models you define in your code. For example, to represent records from the aforementioned `users` table in your application, you might define a JavaScript (ES6) class looking similar to this:\n\n```\nclass User {  constructor(user_id, name, email, isAdmin) {    this.user_id = user_id    this.name = name    this.email = email    this.isAdmin = isAdmin  }}\n```\n\nWhen using TypeScript, you might define an interface instead:\n\n```\ninterface User {  user_id: number  name: string  email: string  isAdmin: boolean}\n```\n\nNotice how the `User` model in both cases has the same properties as the `users` table in the previous example. While it's often the case that there's a 1:1 mapping between database tables and application models, it can also happen that models are represented completely differently in the database and your application.\n\nWith this setup, you can retrieve records from the `users` table and store them as instances of your `User` type. The following example code snippet uses [`pg`](https://node-postgres.com/) as the driver for PostgreSQL and creates a `User` instance based on the above defined JavaScript class:\n\n```\nconst resultRows = await client.query('SELECT * FROM users WHERE user_id = 1')const userData = resultRows[0]const user = new User(  userData.user_id,  userData.name,  userData.email,  userData.isAdmin)// user = {//   user_id: 1,//   name: \"Alice\",//   email: \"alice@prisma.io\",//   isAdmin: false// }\n```\n\nNotice that in these examples, the application models are \"dumb\", meaning they don't implement any logic but their sole purpose is to carry data as _plain old JavaScript objects_.\n\n### Data modeling with ORMs[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-with-orms \"Direct link to Data modeling with ORMs\")\n\nORMs are commonly used in object-oriented languages to make it easier for developers to work with a database. The key characteristic of an ORM is that it lets you model your application data in terms of _classes_ which are mapped to _tables_ in the underlying database.\n\nThe main difference compared to the approaches explained above is these classes not only carry data but also implement a substantial amount of logic. Mostly for storage, retrieval, serialization, and deserialization, but sometimes they also implement business logic that's specific to your application.\n\nThis means, you don't write SQL statements to read and write data in the database, but instead the instances of your model classes provide an API to store and retrieve data.\n\n[Sequelize](https://sequelize.org/) is a popular ORM in the Node.js ecosystem, this is how you'd define the same `User` model from the sections before using Sequelize's modeling approach:\n\n```\nclass User extends Model {}User.init(  {    user_id: {      type: Sequelize.INTEGER,      primaryKey: true,      autoIncrement: true,    },    name: Sequelize.STRING(255),    email: {      type: Sequelize.STRING(255),      unique: true,    },    isAdmin: Sequelize.BOOLEAN,  },  { sequelize, modelName: 'user' })\n```\n\nTo get an example with this `User` class to work, you still need to create the corresponding table in the database. With Sequelize, you have two ways of doing this:\n\n*   Run `User.sync()` (typically not recommended for production)\n*   Use [Sequelize migrations](https://sequelize.org/v5/manual/migrations.html) to change your database schema\n\nNote that you'll never instantiate the `User` class manually (using `new User(...)`) as was shown in the previous section, but rather call _static_ methods on the `User` class which then return the `User` model instances:\n\n```\nconst user = await User.findByPk(42)\n```\n\nThe call to `findByPk` creates a SQL statement to retrieve the `User` record that's identified by the ID value `42`.\n\nThe resulting `user` object is an instance of Sequelize's `Model` class (because `User` inherits from `Model`). It's not a POJO, but an object that implements additional behavior from Sequelize.\n\n## Data modeling with Prisma ORM[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-with-prisma-orm \"Direct link to Data modeling with Prisma ORM\")\n\nDepending on which parts of Prisma ORM you want to use in your application, the data modeling flow looks slightly different. The following two sections explain the workflows for using [**only Prisma Client**](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-only-prisma-client) and using [**Prisma Client and Prisma Migrate**](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-prisma-client-and-prisma-migrate).\n\nNo matter which approach though, with Prisma ORM you never create application models in your programming language by manually defining classes, interfaces, or structs. Instead, the application models are defined in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\n*   **Only Prisma Client**: Application models in the Prisma schema are _generated based on the introspection of your database schema_. Data modeling happens primarily on the database-level.\n*   **Prisma Client and Prisma Migrate**: Data modeling happens in the Prisma schema by _manually adding application models_ to it. Prisma Migrate maps these application models to tables in the underlying database (currently only supported for relational databases).\n\nAs an example, the `User` model from the previous example would be represented as follows in the Prisma schema:\n\n```\nmodel User {  user_id Int     @id @default(autoincrement())  name    String?  email   String  @unique  isAdmin Boolean @default(false)}\n```\n\nOnce the application models are in your Prisma schema (whether they were added through introspection or manually by you), the next step typically is to generate Prisma Client which provides a programmatic and type-safe API to read and write data in the shape of your application models.\n\nPrisma Client uses TypeScript [type aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases) to represent your application models in your code. For example, the `User` model would be represented as follows in the generated Prisma Client library:\n\n```\nexport declare type User = {  id: number  name: string | null  email: string  isAdmin: boolean}\n```\n\nIn addition to the generated types, Prisma Client also provides a data access API that you can use once you've installed the `@prisma/client` package:\n\n```\nimport { PrismaClient } from '@prisma/client'// or// const { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()// use inside an `async` function to `await` the resultawait prisma.user.findUnique(...)await prisma.user.findMany(...)await prisma.user.create(...)await prisma.user.update(...)await prisma.user.delete(...)await prisma.user.upsert(...)\n```\n\n### Using only Prisma Client[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-only-prisma-client \"Direct link to Using only Prisma Client\")\n\nWhen using only Prisma Client and _not_ using Prisma Migrate in your application, data modeling needs to happen on the database level via SQL. Once your SQL schema is ready, you use Prisma's introspection feature to add the application models to your Prisma schema. Finally, you generate Prisma Client which creates the types as well as the programmatic API for you to read and write data in your database.\n\nHere is an overview of the main workflow:\n\n1.  Change your database schema using SQL (e.g. `CREATE TABLE`, `ALTER TABLE`, ...)\n2.  Run `prisma db pull` to introspect the database and add application models to the Prisma schema\n3.  Run `prisma generate` to update your Prisma Client API\n\n### Using Prisma Client and Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-prisma-client-and-prisma-migrate \"Direct link to Using Prisma Client and Prisma Migrate\")\n\nWhen using [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you define your application in the Prisma schema and with relational databases use the `prisma migrate` subcommand to generate plain SQL migration files, which you can edit before applying. With MongoDB, you use `prisma db push` instead which applies the changes to your database directly.\n\nHere is an overview of the main workflow:\n\n1.  Manually change your application models in the Prisma schema (e.g. add a new model, remove an existing one, ...)\n2.  Run `prisma migrate dev` to create and apply a migration or run `prisma db push` to apply the changes directly (in both cases Prisma Client is automatically generated)",
    "title": "Data modeling with Prisma | Prisma Documentation",
    "description": "Learn how data modeling with Prisma differs from data modeling with SQL or ORMs. Prisma uses a declarative data modeling language to describe a database schema.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections",
    "markdown": "# Database connections | Prisma Documentation\n\nDatabases can handle a limited number of concurrent connections. Each connection requires RAM, which means that simply increasing the database connection limit without scaling available resources:\n\n*   ✔ might allow more processes to connect _but_\n*   ✘ significantly affects **database performance**, and can result in the database being **shut down** due to an out of memory error\n\nThe way your application **manages connections** also impacts performance. This guide describes how to approach connection management in [serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas) and [long-running processes](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes).\n\nwarning\n\nThis guide focuses on **relational databases** and how to configure and tune the Prisma ORM connection pool (MongoDB uses the MongoDB driver connection pool).\n\n## Long-running processes[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes \"Direct link to Long-running processes\")\n\nExamples of long-running processes include Node.js applications hosted on a service like Heroku or a virtual machine. Use the following checklist as a guide to connection management in long-running environments:\n\n*   Start with the [recommended pool size (`connection_limit`)](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size) and [tune it](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool)\n*   Make sure you have [**one** global instance of `PrismaClient`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-long-running-applications)\n\n### Recommended connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size \"Direct link to Recommended connection pool size\")\n\nThe recommended connection pool size (`connection_limit`) to [start with](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool) for long-running processes is the **default pool size** (`num_physical_cpus * 2 + 1`) ÷ **number of application instances**.\n\ninfo\n\n`num_physical_cpus` refers to the the number of CPUs of the machine your application is running on.\n\nIf you have **one** application instances:\n\n*   The default pool size applies by default (`num_physical_cpus * 2 + 1`) - you do not need to set the `connection_limit` parameter.\n*   You can optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool).\n\nIf you have **multiple** application instances:\n\n*   You must **manually** [set the `connection_limit` parameter](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size) . For example, if your calculated pool size is _10_ and you have _2_ instances of your app, the `connection_limit` parameter should be **no more than _5_**.\n*   You can optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool).\n\n### `PrismaClient` in long-running applications[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-long-running-applications \"Direct link to prismaclient-in-long-running-applications\")\n\nIn **long-running** applications, we recommend that you:\n\n*   ✔ Create **one** instance of `PrismaClient` and re-use it across your application\n*   ✔ Assign `PrismaClient` to a global variable _in dev environments only_ to [prevent hot reloading from creating new instances](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prevent-hot-reloading-from-creating-new-instances-of-prismaclient)\n\n#### Re-using a single `PrismaClient` instance[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#re-using-a-single-prismaclient-instance \"Direct link to re-using-a-single-prismaclient-instance\")\n\nTo re-use a single instance, create a module that exports a `PrismaClient` object:\n\nclient.ts\n\n```\nimport { PrismaClient } from '@prisma/client'let prisma = new PrismaClient()export default prisma\n```\n\nThe object is [cached](https://nodejs.org/api/modules.html#modules_caching) the first time the module is imported. Subsequent requests return the cached object rather than creating a new `PrismaClient`:\n\napp.ts\n\n```\nimport prisma from './client'async function main() {  const allUsers = await prisma.user.findMany()}main()\n```\n\nYou do not have to replicate the example above exactly - the goal is to make sure `PrismaClient` is cached. For example, you can [instantiate `PrismaClient` in the `context` object](https://github.com/prisma/prisma-examples/blob/9f1a6b9e7c25b9e1851bd59b273046158d748995/typescript/graphql-express/src/context.ts#L9) that you [pass into an Express app](https://github.com/prisma/prisma-examples/blob/9f1a6b9e7c25b9e1851bd59b273046158d748995/typescript/graphql-express/src/server.ts#L12).\n\n#### Do not explicitly `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#do-not-explicitly-disconnect \"Direct link to do-not-explicitly-disconnect\")\n\nYou [do not need to explicitly `$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly) in the context of a long-running application that is continuously serving requests. Opening a new connection takes time and can slow down your application if you disconnect after each query.\n\n#### Prevent hot reloading from creating new instances of `PrismaClient`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prevent-hot-reloading-from-creating-new-instances-of-prismaclient \"Direct link to prevent-hot-reloading-from-creating-new-instances-of-prismaclient\")\n\nFrameworks like [Next.js](https://nextjs.org/) support hot reloading of changed files, which enables you to see changes to your application without restarting. However, if the framework refreshes the module responsible for exporting `PrismaClient`, this can result in **additional, unwanted instances of `PrismaClient` in a development environment**.\n\nAs a workaround, you can store `PrismaClient` as a global variable in development environments only, as global variables are not reloaded:\n\nclient.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }export const prisma =  globalForPrisma.prisma || new PrismaClient()if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n```\n\nThe way that you import and use Prisma Client does not change:\n\napp.ts\n\n```\nimport { prisma } from './client'async function main() {  const allUsers = await prisma.user.findMany()}main()\n```\n\n## Serverless environments (FaaS)[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas \"Direct link to Serverless environments (FaaS)\")\n\nExamples of serverless environments include Node.js functions hosted on AWS Lambda, Vercel or Netlify Functions. Use the following checklist as a guide to connection management in serverless environments:\n\n*   Familiarize yourself with the [serverless connection management challenge](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge)\n*   [Set pool size (`connection_limit`)](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1) based on whether you have an external connection pooler, and optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool)\n*   [Instantiate `PrismaClient` outside the handler](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#instantiate-prismaclient-outside-the-handler) and do not explicitly `$disconnect()`\n*   Configure [function concurrency](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#concurrency-limits) and handle [idle connections](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#zombie-connections)\n\n### The serverless challenge[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge \"Direct link to The serverless challenge\")\n\nIn a serverless environment, each function creates **its own instance** of `PrismaClient`, and each client instance has its own connection pool.\n\nConsider the following example, where a single AWS Lambda function uses `PrismaClient` to connect to a database. The `connection_limit` is **3**:\n\n![An AWS Lambda function connecting to a database.](https://www.prisma.io/docs/assets/images/serverless-connections-a0fa3c9d0c54eb1b9d4c7321ae812a74.png)\n\nA traffic spike causes AWS Lambda to spawn two additional lambdas to handle the increased load. Each lambda creates an instance of `PrismaClient`, each with a `connection_limit` of **3**, which results in a maximum of **9** connections to the database:\n\n![Three AWS Lambda function connecting to a database.](https://www.prisma.io/docs/assets/images/serverless-connections-2-23447d81bde18522c5b4dcf08bcf4dac.png)\n\n200 _concurrent functions_ (and therefore 600 possible connections) responding to a traffic spike 📈 can exhaust the database connection limit very quickly. Furthermore, any functions that are **paused** keep their connections open by default and block them from being used by another function.\n\n1.  Start by [setting the `connection_limit` to `1`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1)\n2.  If a smaller pool size is not enough, consider using an [external connection pooler like PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers)\n\n### Recommended connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1 \"Direct link to Recommended connection pool size\")\n\nThe recommended pool size (`connection_limit`) in serverless environments depends on:\n\n*   Whether you are using an [external connection pooler](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers)\n*   Whether your functions are [designed to send queries in parallel](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests)\n\n#### Without an external connection pooler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#without-an-external-connection-pooler \"Direct link to Without an external connection pooler\")\n\nIf you are **not** using an external connection pooler, _start_ by setting the pool size (`connection_limit`) to **1**, then [optimize](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests). Each incoming request starts a short-lived Node.js process, and many concurrent functions with a high `connection_limit` can quickly **exhaust the _database_ connection limit** during a traffic spike.\n\nThe following example demonstrates how to set the `connection_limit` to 1 in your connection URL:\n\n*   PostgreSQL\n*   MySQL\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public&connection_limit=1\n```\n\n#### With an external connection pooler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#with-an-external-connection-pooler \"Direct link to With an external connection pooler\")\n\nIf you are using an external connection pooler, use the default pool size (`num_physical_cpus * 2 + 1`) as a starting point and then [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool). The external connection pooler should prevent a traffic spike from overwhelming the database.\n\n#### Optimizing for parallel requests[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests \"Direct link to Optimizing for parallel requests\")\n\nIf you rarely or never exceed the database connection limit with the pool size set to 1, you can further optimize the connection pool size. Consider a function that sends queries in parallel:\n\n```\nPromise.all() {  query1,  query2,  query3  query4,  ...}\n```\n\nIf the `connection_limit` is 1, this function is forced to send queries **serially** (one after the other) rather than **in parallel**. This slows down the function's ability to process requests, and may result in pool timeout errors. Tune the `connection_limit` parameter until a traffic spike:\n\n*   Does not exhaust the database connection limit\n*   Does not result in pool timeout errors\n\n### `PrismaClient` in serverless environments[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-serverless-environments \"Direct link to prismaclient-in-serverless-environments\")\n\n#### Instantiate `PrismaClient` outside the handler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#instantiate-prismaclient-outside-the-handler \"Direct link to instantiate-prismaclient-outside-the-handler\")\n\nInstantiate `PrismaClient` [outside the scope of the function handler](https://github.com/prisma/e2e-tests/blob/5d1041d3f19245d3d237d959eca94d1d796e3a52/platforms/serverless-lambda/index.ts#L3) to increase the chances of reuse. As long as the handler remains 'warm' (in use), the connection is potentially reusable:\n\n```\nimport { PrismaClient } from '@prisma/client'const client = new PrismaClient()export async function handler() {  /* ... */}\n```\n\n#### Do not explicitly `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#do-not-explicitly-disconnect-1 \"Direct link to do-not-explicitly-disconnect-1\")\n\nYou [do not need to explicitly `$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly) at the end of a function, as there is a possibility that the container might be reused. Opening a new connection takes time and slows down your function's ability to process requests.\n\n### Other serverless considerations[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#other-serverless-considerations \"Direct link to Other serverless considerations\")\n\n#### Container reuse[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#container-reuse \"Direct link to Container reuse\")\n\nThere is no guarantee that subsequent nearby invocations of a function will hit the same container - for example, AWS can choose to create a new container at any time.\n\nCode should assume the container to be stateless and create a connection only if it does not exist - Prisma Client JS already implements this logic.\n\n#### Zombie connections[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#zombie-connections \"Direct link to Zombie connections\")\n\nContainers that are marked \"to be removed\" and are not being reused still **keep a connection open** and can stay in that state for some time (unknown and not documented from AWS). This can lead to sub-optimal utilization of the database connections.\n\nA potential solution is to **clean up idle connections** ([`serverless-mysql`](https://github.com/jeremydaly/serverless-mysql) implements this idea, but cannot be used with Prisma ORM).\n\n#### Concurrency limits[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#concurrency-limits \"Direct link to Concurrency limits\")\n\nDepending on your serverless concurrency limit (the number of serverless functions running in parallel), you might still exhaust your database's connection limit. This can happen when too many functions are invoked concurrently, each with its own connection pool, which eventually exhausts the database connection limit. To prevent this, you can [set your serverless concurrency limit](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html) to a number lower than the maximum connection limit of your database divided by the number of connections used by each function invocation (as you might want to be able to connect from another client for other purposes).\n\n## Optimizing the connection pool[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool \"Direct link to Optimizing the connection pool\")\n\nIf the query engine cannot [process a query in the queue before the time limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#how-the-connection-pool-works) , you will see connection pool timeout exceptions in your log. A connection pool timeout can occur if:\n\n*   Many users are accessing your app simultaneously\n*   You send a large number of queries in parallel (for example, using `await Promise.all()`)\n\nIf you consistently experience connection pool timeouts after configuring the recommended pool size, you can further tune the `connection_limit` and `pool_timeout` parameters.\n\n### Increasing the pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#increasing-the-pool-size \"Direct link to Increasing the pool size\")\n\nIncreasing the pool size allows the query engine to process a larger number of queries in parallel. Be aware that your database must be able to support the increased number of concurrent connections, otherwise you will **exhaust the database connection limit**.\n\nTo increase the pool size, manually set the `connection_limit` to a higher number:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public&connection_limit=40\"}\n```\n\n> **Note**: Setting the `connection_limit` to 1 in serverless environments is a recommended starting point, but [this value can also be tuned](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests).\n\n### Increasing the pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#increasing-the-pool-timeout \"Direct link to Increasing the pool timeout\")\n\nIncreasing the pool timeout gives the query engine more time to process queries in the queue. You might consider this approach in the following scenario:\n\n*   You have already increased the `connection_limit`.\n*   You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.\n\nTo increase the pool timeout, set the `pool_timeout` parameter to a value larger than the default (10 seconds):\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=20\"}\n```\n\n### Disabling the pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#disabling-the-pool-timeout \"Direct link to Disabling the pool timeout\")\n\nDisabling the pool timeout prevents the query engine from throwing an exception after x seconds of waiting for a connection and allows the queue to build up. You might consider this approach in the following scenario:\n\n*   You are submitting a large number of queries for a limited time - for example, as part of a job to import or update every customer in your database.\n*   You have already increased the `connection_limit`.\n*   You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.\n\nTo disable the pool timeout, set the `pool_timeout` parameter to `0`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=0\"}\n```\n\n## External connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers \"Direct link to External connection poolers\")\n\nConnection poolers like [Prisma Accelerate](https://www.prisma.io/docs/accelerate) and PgBouncer prevent your application from exhausting the database's connection limit.\n\nIf you would like to use the Prisma CLI in order to perform other actions on your database ,e.g. migrations and introspection, you will need to add an environment variable that provides a direct connection to your database in the `datasource.directUrl` property in your Prisma schema:\n\n.env\n\n```\n# Connection URL to your database using PgBouncer.DATABASE_URL=\"postgres://root:password@127.0.0.1:54321/postgres?pgbouncer=true\"# Direct connection URL to the database used for migrationsDIRECT_URL=\"postgres://root:password@127.0.0.1:5432/postgres\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\n### Prisma Accelerate[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prisma-accelerate \"Direct link to Prisma Accelerate\")\n\n[Prisma Accelerate](https://www.prisma.io/docs/accelerate) is a managed external connection pooler built by Prisma that is integrated in the [Prisma Data Platform](https://www.prisma.io/docs/platform) and handles connection pooling for you.\n\n### PgBouncer[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#pgbouncer \"Direct link to PgBouncer\")\n\nPostgreSQL only supports a certain amount of concurrent connections, and this limit can be reached quite fast when the service usage goes up – especially in [serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).\n\n[PgBouncer](https://www.pgbouncer.org/) holds a connection pool to the database and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time. PgBouncer passes on a limited number of connections to the database and queues additional connections for delivery when connections becomes available. To use PgBouncer, see [Configure Prisma Client with PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer).\n\n### AWS RDS Proxy[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#aws-rds-proxy \"Direct link to AWS RDS Proxy\")\n\nDue to the way AWS RDS Proxy pins connections, [it does not provide any connection pooling benefits](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-rds-proxy) when used together with Prisma Client.",
    "title": "Database connections | Prisma Documentation",
    "description": "Databases connections",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-planetscale",
    "markdown": "# Connect your database using TypeScript and PlanetScale\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For PlanetScale, you need to edit the `datasource` block to use the `mysql` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou will also need to set the relation mode type to `prisma` in order to [emulate foreign key constraints](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\n> **Note**: Since February 2024, you can alternatively [use foreign key constraints on a database-level in PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings), which omits the need for setting `relationMode = \"prisma\"`.\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://janedoe:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. PlanetScale uses the MySQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nFor a database hosted with PlanetScale, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nThe connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' to get the Prisma format for the connection URL.\n\nAlternative method: connecting using the PlanetScale CLI\n\nAlternatively, you can connect to your PlanetScale database server using the [PlanetScale CLI](https://docs.planetscale.com/reference/planetscale-environment-setup), and use a local connection URL. In this case the connection URL will look like this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root@localhost:PORT/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nTo connect to your branch, use the following command:\n\n```\npscale connect prisma-test branchname --port PORT\n```\n\nThe `--port` flag can be omitted if you are using the default port `3306`.",
    "title": "Connect your database using TypeScript and PlanetScale | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode",
    "markdown": "# Manage relations between records with relation modes in Prisma\n\n## Relation mode\n\nIn Prisma schema, relations between records are defined with the [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attribute. For example, in the following schema there is a one-to-many relation between the `User` and `Post` models:\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nPrisma ORM has two _relation modes_, `foreignKeys` and `prisma`, that specify how relations between records are enforced.\n\nIf you use Prisma ORM with a relational database, then by default Prisma ORM uses the [`foreignKeys` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode), which enforces relations between records at the database level with foreign keys. A foreign key is a column or group of columns in one table that take values based on the primary key in another table. Foreign keys allow you to:\n\n*   set constraints that prevent you from making changes that break references\n*   set [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) that define how changes to records are handled\n\nTogether these constraints and referential actions guarantee the _referential integrity_ of the data.\n\nFor the example schema above, Prisma Migrate will generate the following SQL by default if you use the PostgreSQL connector:\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" TEXT NOT NULL,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"User\" (    \"id\" SERIAL NOT NULL,    CONSTRAINT \"User_pkey\" PRIMARY KEY (\"id\"));-- AddForeignKey//highlight-startALTER TABLE \"Post\"  ADD CONSTRAINT \"Post_authorId_fkey\"  FOREIGN KEY (\"authorId\")  REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;//highlight-end\n```\n\nIn this case, the foreign key constraint on the `authorId` column of the `Post` table references the `id` column of the `User` table, and guarantees that a post must have an author that exists. If you update or delete a user then the `ON DELETE` and `ON UPDATE` referential actions specify the `CASCADE` option, which will also delete or update all posts belonging to the user.\n\nSome databases, such as MongoDB or [PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#differences-to-consider), do not support foreign keys. Additionally, in some cases developers may prefer not to use foreign keys in their relational database that usually does support foreign keys. For these situations, Prisma ORM offers [the `prisma` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode), which emulates some properties of relations in relational databases. When you use Prisma Client with the `prisma` relation mode enabled, the behavior of queries is identical or similar, but referential actions and some constraints are handled by the Prisma engine rather than in the database.\n\nwarning\n\nThere are performance implications to emulation of referential integrity and referential actions in Prisma Client. In cases where the underlying database supports foreign keys, it is usually the preferred choice.\n\n## How to set the relation mode in your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#how-to-set-the-relation-mode-in-your-prisma-schema \"Direct link to How to set the relation mode in your Prisma schema\")\n\nTo set the relation mode, add the `relationMode` field in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\ninfo\n\nThe ability to set the relation mode was introduced as part of the `referentialIntegrity` preview feature in Prisma ORM version 3.1.1, and is generally available in Prisma ORM versions 4.8.0 and later.\n\nThe `relationMode` field was renamed in Prisma ORM version 4.5.0, and was previously named `referentialIntegrity`.\n\nFor relational databases, the available options are:\n\n*   `foreignKeys`: this handles relations in the database with foreign keys. This is the default option for all relational database connectors and is active if no `relationMode` is explicitly set in the `datasource` block.\n*   `prisma`: this emulates relations in Prisma Client. You should also [enable this option](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) when you use the MySQL connector with a PlanetScale database and don't have native foreign key constraints enabled in your PlanetScale database settings.\n\nFor MongoDB, the only available option is the `prisma` relation mode. This mode is also active if no `relationMode` is explicitly set in the `datasource` block.\n\nwarning\n\nIf you switch between relation modes, Prisma ORM will add or remove foreign keys to your database next time you apply changes to your schema with Prisma Migrate or `db push`. See [Switch between relation modes](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-between-relation-modes) for more information.\n\n## Handle relations in your relational database with the `foreignKeys` relation mode[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode \"Direct link to handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode\")\n\nThe `foreignKeys` relation mode handles relations in your relational database with foreign keys. This is the default option when you use a relational database connector (PostgreSQL, MySQL, SQLite, SQL Server, CockroachDB).\n\nThe `foreignKeys` relation mode is not available when you use the MongoDB connector. Some relational databases, [such as PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client), also forbid the use of foreign keys. In these cases, you should instead [emulate relations in Prisma ORM with the `prisma` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode).\n\n### Referential integrity[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#referential-integrity \"Direct link to Referential integrity\")\n\nThe `foreignKeys` relation mode maintains referential integrity at the database level with foreign key constraints and referential actions.\n\n#### Foreign key constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#foreign-key-constraints \"Direct link to Foreign key constraints\")\n\nWhen you _create_ or _update_ a record with a relation to another record, the related record needs to exist. Foreign key constraints enforce this behavior in the database. If the record does not exist, the database will return an error message.\n\n#### Referential actions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#referential-actions \"Direct link to Referential actions\")\n\nWhen you _update_ or _delete_ a record with a relation to another record, referential actions are triggered in the database. To maintain referential integrity in related records, referential actions prevent changes that would break referential integrity, cascade changes through to related records, or set the value of fields that reference the updated or deleted records to a `null` or default value.\n\nFor more information, see the [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) page.\n\n### Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#introspection \"Direct link to Introspection\")\n\nWhen you introspect a relational database with the `db pull` command with the `foreignKeys` relation mode enabled, a `@relation` attribute will be added to your Prisma schema for relations where foreign keys exist.\n\n### Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#prisma-migrate-and-db-push \"Direct link to prisma-migrate-and-db-push\")\n\nWhen you apply changes to your Prisma schema with Prisma Migrate or `db push` with the `foreignKeys` relation mode enabled, foreign keys will be created in your database for all `@relation` attributes in your schema.\n\n## Emulate relations in Prisma ORM with the `prisma` relation mode[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode \"Direct link to emulate-relations-in-prisma-orm-with-the-prisma-relation-mode\")\n\nThe `prisma` relation mode emulates some foreign key constraints and referential actions for each Prisma Client query to maintain referential integrity, using some additional database queries and logic.\n\nThe `prisma` relation mode is the default option for the MongoDB connector. It should also be set if you use a relational database that does not support foreign keys. For example, [if you use PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) without foreign key constraints, you should use the `prisma` relation mode.\n\nwarning\n\nThere are performance implications to emulation of referential integrity in Prisma Client, because it uses additional database queries to maintain referential integrity. In cases where the underlying database can handle referential integrity with foreign keys, it is usually the preferred choice.\n\nEmulation of relations is only available for Prisma Client queries and does not apply to raw queries.\n\n### Which foreign key constraints are emulated?[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#which-foreign-key-constraints-are-emulated \"Direct link to Which foreign key constraints are emulated?\")\n\nWhen you _update_ a record, Prisma ORM will emulate foreign key constraints. This means that when you update a record with a relation to another record, the related record needs to exist. If the record does not exist, Prisma Client will return an error message.\n\nHowever, when you _create_ a record, Prisma ORM does not emulate any foreign key constraints. You will be able to create invalid data.\n\n### Which referential actions are emulated?[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#which-referential-actions-are-emulated \"Direct link to Which referential actions are emulated?\")\n\nWhen you _update_ or _delete_ a record with related records, Prisma ORM will emulate referential actions.\n\nThe following table shows which emulated referential actions are available for each database connector:\n\n| Database | Cascade | Restrict | NoAction | SetNull | SetDefault |\n| --- | --- | --- | --- | --- | --- |\n| PostgreSQL | **✔️** | **✔️** | **❌**‡ | **✔️** | **❌**† |\n| MySQL | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| SQLite | **✔️** | **✔️** | **❌**‡ | **✔️** | **❌**† |\n| SQL Server | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| CockroachDB | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| MongoDB | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n\n*   † The `SetDefault` referential action is not supported in the `prisma` relation mode.\n*   ‡ The `NoAction` referential action is not supported in the `prisma` relation mode for PostgreSQL and SQLite. Instead, use the `Restrict` action.\n\n### Error messages[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#error-messages \"Direct link to Error messages\")\n\nError messages returned by emulated constraints and referential actions in the `prisma` relation mode are generated by Prisma Client and differ slightly from the error messages in the `foreignKeys` relation mode:\n\n```\nExample:// foreignKeys:... Foreign key constraint failed on the field: `ProfileOneToOne_userId_fkey (index)`// prisma:... The change you are trying to make would violate the required relation 'ProfileOneToOneToUserOneToOne' between the `ProfileOneToOne` and `UserOneToOne` models.\n```\n\n### Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#introspection-1 \"Direct link to Introspection\")\n\nWhen you introspect a database with the `db pull` command with the `prisma` relation mode enabled, relations will not be automatically added to your schema. You will instead need to add any relations manually with the `@relation` attribute. This only needs to be done once – next time you introspect your database, Prisma ORM will keep your added `@relation` attributes.\n\n### Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#prisma-migrate-and-db-push-1 \"Direct link to prisma-migrate-and-db-push-1\")\n\nWhen you apply changes to your Prisma schema with Prisma Migrate or `db push` with the `prisma` relation mode enabled, Prisma ORM will not use foreign keys in your database.\n\n### Indexes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#indexes \"Direct link to Indexes\")\n\nIn relational databases that use foreign key constraints, the database usually also implicitly creates an index for the foreign key columns. For example, [MySQL will create an index on all foreign key columns](https://dev.mysql.com/doc/refman/8.0/en/constraint-foreign-key.html#:~:text=MySQL%20requires%20that%20foreign%20key%20columns%20be%20indexed%3B%20if%20you%20create%20a%20table%20with%20a%20foreign%20key%20constraint%20but%20no%20index%20on%20a%20given%20column%2C%20an%20index%20is%20created.). This is to allow foreign key checks to run fast and not require a table scan.\n\nThe `prisma` relation mode does not use foreign keys, so no indexes are created when you use Prisma Migrate or `db push` to apply changes to your database. You instead need to manually add an index on your relation scalar fields with the [`@@index`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index) attribute (or the [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique), [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1) or [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) attributes, if applicable).\n\n#### Index validation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#index-validation \"Direct link to Index validation\")\n\nIf you do not add the index manually, queries might require full table scans. This can be slow, and also expensive on database providers that bill per accessed row. To help avoid this, Prisma ORM warns you when your schema contains fields that are used in a `@relation` that does not have an index defined. For example, take the following schema with a relation between the `User` and `Post` models:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}model User {  id    Int    @id  posts Post[]}model Post {  id     Int  @id  userId Int  user   User @relation(fields: [userId], references: [id])}\n```\n\nPrisma ORM displays the following warning when you run `prisma format` or `prisma validate`:\n\n```\nWith `relationMode = \"prisma\"`, no foreign keys are used, so relation fields will not benefit from the index usually created by the relational database under the hood. This can lead to poor performance when querying these fields. We recommend adding an index manually.\n```\n\nTo fix this, add an index to your `Post` model:\n\nschema.prisma\n\n```\nmodel Post {  id     Int  @id  userId Int  user   User @relation(fields: [userId], references: [id])  @@index([userId])}\n```\n\nIf you use the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) (or our [language server in another editor](https://www.prisma.io/docs/orm/more/development-environment/editor-setup)), the warning is augmented with a Quick Fix that adds the required index for you:\n\n![The Quick Fix pop-up for adding an index on a relation scalar field in VS Code](https://www.prisma.io/docs/assets/images/quick-fix-index-a2282aafe221d87196e61ec54170f9b2.png)\n\nIt is only possible to switch between relation modes when you use a relational database connector (PostgreSQL, MySQL, SQLite, SQL Server, CockroachDB).\n\n### Switch from `foreignKeys` to `prisma`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-from-foreignkeys-to-prisma \"Direct link to switch-from-foreignkeys-to-prisma\")\n\nThe default relation mode if you use a relational database and do not include the `relationMode` field in your `datasource` block is `foreignKeys`. To switch to the `prisma` relation mode, add the `relationMode` field with a value of `prisma`, or update the `relationMode` field value to `prisma` if it already exists.\n\nWhen you switch the relation mode from `foreignKeys` to `prisma`, after you first apply changes to your schema with Prisma Migrate or `db push` Prisma ORM will remove all previously created foreign keys in the next migration.\n\nIf you keep the same database, you can then continue to work as normal. If you switch to a database that does not support foreign keys at all, your existing migration history contains SQL DDL that creates foreign keys, which might trigger errors if you ever have to rerun these migrations. In this case, we recommend that you delete the `migrations` directory. (If you use PlanetScale, which does not support foreign keys, we generally recommend that you [use `db push` rather than Prisma Migrate](https://www.prisma.io/docs/orm/overview/databases/planetscale#differences-to-consider).)\n\n### Switch from `prisma` to `foreignKeys`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-from-prisma-to-foreignkeys \"Direct link to switch-from-prisma-to-foreignkeys\")\n\nTo switch from the `prisma` relation mode to the `foreignKeys` relation mode, update the `relationMode` field value from `prisma` to `foreignKeys`. To do this, the database must support foreign keys. When you apply changes to your schema with Prisma Migrate or `db push` for the first time after you switch relation modes, Prisma ORM will create foreign keys for all relations in the next migration.",
    "title": "Manage relations between records with relation modes in Prisma | Prisma Documentation",
    "description": "Manage relations between records with relation modes in Prisma",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/select-fields",
    "markdown": "# Select fields (Concepts) | Prisma Documentation\n\nBy default, when a query returns records (as opposed to a count), the result includes the **default selection set**:\n\n*   **All** scalar fields defined in the Prisma schema (including enums)\n*   **None** of the relations\n\nTo customize the result:\n\n*   Use [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to return specific fields - [you can also use a nested `select` to include relation fields](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations)\n*   Use [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) to explicitly [include relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads)\n\nSelecting only the fields and relations that you require rather than relying on the default selection set can ✔ reduce the size of the response and ✔ improve query speed.\n\nSince version [5.9.0](https://github.com/prisma/prisma/releases/tag/5.9.0), when doing a relation query with `include` or by using `select` on a relation field, you can also specify the `relationLoadStrategy` to decide whether you want to use a database-level join or perform multiple queries and merge the data on the application level. This feature is currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview), you can learn more about it [here](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview).\n\n## Example schema[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#example-schema \"Direct link to Example schema\")\n\nAll examples are based on the following schema:\n\nExpand for sample schema\n\n*   Relational databases\n*   MongoDB\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model ExtendedProfile {  id        Int    @id @default(autoincrement())  biography String  user      User   @relation(fields: [userId], references: [id])  userId    Int    @unique}model User {  id           Int              @id @default(autoincrement())  name         String?  email        String           @unique  profileViews Int              @default(0)  role         Role             @default(USER)  coinflips    Boolean[]  posts        Post[]  profile      ExtendedProfile?}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  comments   Json?  views      Int        @default(0)  likes      Int        @default(0)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}enum Role {  USER  ADMIN}\n```\n\nFor **relational databases**, use `db push` command to push the example schema to your own database\n\nFor **MongoDB**, ensure your data is in a uniform shape and matches the model defined in the Prisma schema.\n\n## Return the default selection set[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#return-the-default-selection-set \"Direct link to Return the default selection set\")\n\nThe following query returns the default selection set (all scalar fields, no relations):\n\n```\n// Query returns User or nullconst getUser: User | null = await prisma.user.findUnique({  where: {    id: 22,  },})\n```\n\n## Select specific fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#select-specific-fields \"Direct link to Select specific fields\")\n\nUse `select` to return a limited subset of fields instead of all fields. The following example returns the `email` and `name` fields only:\n\n```\n// Returns an object or nullconst getUser: object | null = await prisma.user.findUnique({  where: {    id: 22,  },  select: {    email: true,    name: true,  },})\n```\n\n## Include relations and select relation fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields \"Direct link to Include relations and select relation fields\")\n\nTo return **specific relation fields**, you can:\n\n*   Use a nested `select`\n*   Use a `select` within an `include`\n\n> To return _all_ relation fields, use `include` only - for example, `{ include: { posts: true } }`.\n\nThe following query uses a nested `select` to select each user's `name` and the `title` of each related post:\n\n```\nconst users = await prisma.user.findMany({  select: {    name: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\nThe following query uses `select` within an `include`, and returns _all_ user fields and each post's `title` field:\n\n```\nconst users = await prisma.user.findMany({  // Returns all user fields  include: {    posts: {      select: {        title: true,      },    },  },})\n```\n\nFor more information about querying relations, refer to the following documentation:\n\n*   [Include a relation (including all fields)](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-all-fields-for-a-specific-relation)\n*   [Select specific relation fields](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations)\n\n## Relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#relation-count \"Direct link to Relation count\")\n\nIn [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` or `select` a count of relations](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) alongside fields - for example, a user's post count.",
    "title": "Select fields (Concepts) | Prisma Documentation",
    "description": "This page explains how to select only a subset of a model's fields and/or include relations (\"eager loading\") in a Prisma Client query.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-planetscale",
    "markdown": "# Introspection with Prisma ORM, TypeScript, and PlanetScale\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, TypeScript, and PlanetScale | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, TypeScript, and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations",
    "markdown": "# Many-to-many relations | Prisma Documentation\n\nMany-to-many (m-n) relations refer to relations where zero or more records on one side of the relation can be connected to zero or more records on the other side.\n\nPrisma schema syntax and the implementation in the underlying database differs between [relational databases](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relational-databases) and [MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb).\n\n## Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relational-databases \"Direct link to Relational databases\")\n\nIn relational databases, m-n-relations are typically modelled via [relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables). m-n-relations can be either [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) or [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) in the Prisma schema. We recommend using [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) m-n-relations if you do not need to store any additional meta-data in the relation table itself. You can always migrate to an [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) m-n-relation later if needed.\n\n### Explicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations \"Direct link to Explicit many-to-many relations\")\n\nIn an explicit m-n relation, the **relation table is represented as a model in the Prisma schema** and can be used in queries. Explicit m-n relations define three models:\n\n*   Two models with m-n relation, such as `Category` and `Post`.\n*   One model that represents the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables), such as `CategoriesOnPosts` (also sometimes called _JOIN_, _link_ or _pivot_ table) in the underlying database. The fields of a relation table model are both annotated relation fields (`post` and `category`) with a corresponding relation scalar field (`postId` and `categoryId`).\n\nThe relation table `CategoriesOnPosts` connects related `Post` and `Category` records. In this example, the model representing the relation table also **defines additional fields** that describe the `Post`/`Category` relationship - who assigned the category (`assignedBy`), and when the category was assigned (`assignedAt`):\n\n```\nmodel Post {  id         Int                 @id @default(autoincrement())  title      String  categories CategoriesOnPosts[]}model Category {  id    Int                 @id @default(autoincrement())  name  String  posts CategoriesOnPosts[]}model CategoriesOnPosts {  post       Post     @relation(fields: [postId], references: [id])  postId     Int // relation scalar field (used in the `@relation` attribute above)  category   Category @relation(fields: [categoryId], references: [id])  categoryId Int // relation scalar field (used in the `@relation` attribute above)  assignedAt DateTime @default(now())  assignedBy String  @@id([postId, categoryId])}\n```\n\nThe underlying SQL looks like this:\n\n```\nCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" TEXT NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));CREATE TABLE \"Category\" (    \"id\" SERIAL NOT NULL,    \"name\" TEXT NOT NULL,    CONSTRAINT \"Category_pkey\" PRIMARY KEY (\"id\"));-- Relation table + indexes --CREATE TABLE \"CategoriesOnPosts\" (    \"postId\" INTEGER NOT NULL,    \"categoryId\" INTEGER NOT NULL,    \"assignedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,    CONSTRAINT \"CategoriesOnPosts_pkey\" PRIMARY KEY (\"postId\",\"categoryId\"));ALTER TABLE \"CategoriesOnPosts\" ADD CONSTRAINT \"CategoriesOnPosts_postId_fkey\" FOREIGN KEY (\"postId\") REFERENCES \"Post\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;ALTER TABLE \"CategoriesOnPosts\" ADD CONSTRAINT \"CategoriesOnPosts_categoryId_fkey\" FOREIGN KEY (\"categoryId\") REFERENCES \"Category\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;\n```\n\nNote that the same rules as for [1-n relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations) apply (because `Post`↔ `CategoriesOnPosts` and `Category` ↔ `CategoriesOnPosts` are both in fact 1-n relations), which means one side of the relation needs to be annotated with the `@relation` attribute.\n\nWhen you don't need to attach additional information to the relation, you can model m-n-relations as [implicit m-n-relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). If you're not using Prisma Migrate but obtain your data model from [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), you can still make use of implicit m-n-relations by following Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations).\n\n#### Querying an explicit many-to-many[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-explicit-many-to-many \"Direct link to Querying an explicit many-to-many\")\n\nThe following section demonstrates how to query an explicit m-n-relation. You can query the relation model directly (`prisma.categoriesOnPosts(...)`), or use nested queries to go from `Post` -> `CategoriesOnPosts` -> `Category` or the other way.\n\nThe following query does three things:\n\n1.  Creates a `Post`\n2.  Creates a new record in the relation table `CategoriesOnPosts`\n3.  Creates a new `Category` that is associated with the newly created `Post` record\n\n```\nconst createCategory = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            create: {              name: 'New category',            },          },        },      ],    },  },})\n```\n\nThe following query:\n\n*   Creates a new `Post`\n*   Creates a new record in the relation table `CategoriesOnPosts`\n*   Connects the category assignment to existing categories (with IDs `9` and `22`)\n\n```\nconst assignCategories = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connect: {              id: 9,            },          },        },        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connect: {              id: 22,            },          },        },      ],    },  },})\n```\n\nSometimes you might not know if a `Category` record exists. If the `Category` record exists, you want to connect a new `Post` record to that category. If the `Category` record does not exist, you want to create the record first and then connect it to the new `Post` record. The following query:\n\n1.  Creates a new `Post`\n2.  Creates a new record in the relation table `CategoriesOnPosts`\n3.  Connects the category assignment to an existing category (with ID `9`), or creates a new category first if it does not exist\n\n```\nconst assignCategories = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connectOrCreate: {              where: {                id: 9,              },              create: {                name: 'New Category',                id: 9,              },            },          },        },      ],    },  },})\n```\n\nThe following query returns all `Post` records where at least one (`some`) category assignment (`categories`) refers to a category named `\"New category\"`:\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    categories: {      some: {        category: {          name: 'New Category',        },      },    },  },})\n```\n\nThe following query returns all categories where at least one (`some`) related `Post` record titles contain the words `\"Cool stuff\"` _and_ the category was assigned by Bob.\n\n```\nconst getAssignments = await prisma.category.findMany({  where: {    posts: {      some: {        assignedBy: 'Bob',        post: {          title: {            contains: 'Cool stuff',          },        },      },    },  },})\n```\n\nThe following query gets all category assignments (`CategoriesOnPosts`) records that were assigned by `\"Bob\"` to one of 5 posts:\n\n```\nconst getAssignments = await prisma.categoriesOnPosts.findMany({  where: {    assignedBy: 'Bob',    post: {      id: {        in: [9, 4, 10, 12, 22],      },    },  },})\n```\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nImplicit m-n relations define relation fields as lists on both sides of the relation. Although the relation table exists in the underlying database, **it is managed by Prisma ORM and does not manifest in the Prisma schema**. Implicit relation tables follow a [specific convention](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations).\n\nImplicit m-n-relations makes the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) for m-n-relations a bit simpler (since you have one fewer level of nesting inside of [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes)).\n\nIn the example below, there's one _implicit_ m-n-relation between `Post` and `Category`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\n#### Querying an implicit many-to-many[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-implicit-many-to-many \"Direct link to Querying an implicit many-to-many\")\n\nThe following section demonstrates how to query an [implicit m-n](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) relation. The queries require less nesting than [explicit m-n queries](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-explicit-many-to-many).\n\nThe following query creates a single `Post` and multiple `Category` records:\n\n```\nconst createPostAndCategory = await prisma.post.create({  data: {    title: 'How to become a butterfly',    categories: {      create: [{ name: 'Magic' }, { name: 'Butterflies' }],    },  },})\n```\n\nThe following query creates a single `Category` and multiple `Post` records:\n\n```\nconst createCategoryAndPosts = await prisma.category.create({  data: {    name: 'Stories',    posts: {      create: [        { title: 'That one time with the stuff' },        { title: 'The story of planet Earth' },      ],    },  },})\n```\n\nThe following query returns all `Post` records with a list of that post's assigned categories:\n\n```\nconst getPostsAndCategories = await prisma.post.findMany({  include: {    categories: true,  },})\n```\n\n#### Rules for defining an implicit m-n relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#rules-for-defining-an-implicit-m-n-relation \"Direct link to Rules for defining an implicit m-n relation\")\n\nImplicit m-n relations:\n\n*   Use a specific [convention for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations)\n    \n*   Do **not** require the `@relation` attribute unless you need to [disambiguate relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#disambiguating-relations) with a name, e.g. `@relation(\"MyRelation\")` or `@relation(name: \"MyRelation\")`.\n    \n*   If you do use the `@relation` attribute, you cannot use the `references`, `fields`, `onUpdate` or `onDelete` arguments. This is because these take a fixed value for implicit m-n-relations and cannot be changed.\n    \n*   Require both models to have a single `@id`. Be aware that:\n    \n    *   You cannot use a [multi-field ID](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)\n    *   You cannot use a `@unique` in place of an `@id`\n\n#### Conventions for relation tables in implicit m-n relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations \"Direct link to Conventions for relation tables in implicit m-n relations\")\n\nIf you obtain your data model from [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), you can still use implicit m-n-relations by following Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations). The following example assumes you want to create a relation table to get an implicit m-n-relation for two models called `Post` and `Category`.\n\n##### Relation table[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-table \"Direct link to Relation table\")\n\nIf you want a relation table to be picked up by introspection as an implicit m-n-relation, the name must follow this exact structure:\n\n*   It must start with an underscore `_`\n*   Then the name of the first model in alphabetical order (in this case `Category`)\n*   Then the relationship (in this case `To`)\n*   Then the name of the second model in alphabetical order (in this case `Post`)\n\nIn the example, the correct table name is `_CategoryToPost`.\n\nWhen creating an implicit m-n-relation yourself in the Prisma schema file, you can [configure the relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#configuring-the-name-of-the-relation-table-in-implicit-many-to-many-relations) to have a different name. This will change the name given to the relation table in the database. For example, for a relation named `\"MyRelation\"` the corresponding table will be called `_MyRelation`.\n\n###### Multi-schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#multi-schema \"Direct link to Multi-schema\")\n\nIf your implicit many-to-many relationship spans multiple database schemas (using the [`multiSchema` preview feature](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema)), the relation table (with the name defined directly above, in the example `_CategoryToPost`) must be present in the same database schema as the first model in alphabetical order (in this case `Category`).\n\n##### Columns[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#columns \"Direct link to Columns\")\n\nA relation table for an implicit m-n-relation must have exactly two columns:\n\n*   A foreign key column that points to `Category` called `A`\n*   A foreign key column that points to `Post` called `B`\n\nThe columns must be called `A` and `B` where `A` points to the model that comes first in the alphabet and `B` points to the model which comes last in the alphabet.\n\n##### Indexes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#indexes \"Direct link to Indexes\")\n\nThere further must be:\n\n*   A unique index defined on both foreign key columns:\n    \n    ```\n    CREATE UNIQUE INDEX \"_CategoryToPost_AB_unique\" ON \"_CategoryToPost\"(\"A\" int4_ops,\"B\" int4_ops);\n    ```\n    \n*   A non-unique index defined on B:\n    \n    ```\n    CREATE INDEX \"_CategoryToPost_B_index\" ON \"_CategoryToPost\"(\"B\" int4_ops);\n    ```\n    \n\n##### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#example \"Direct link to Example\")\n\nThis is a sample SQL statement that would create the three tables including indexes (in PostgreSQL dialect) that are picked up as a implicit m-n-relation by Prisma Introspection:\n\n```\nCREATE TABLE \"_CategoryToPost\" (    \"A\" integer NOT NULL REFERENCES \"Category\"(id) ,    \"B\" integer NOT NULL REFERENCES \"Post\"(id));CREATE UNIQUE INDEX \"_CategoryToPost_AB_unique\" ON \"_CategoryToPost\"(\"A\" int4_ops,\"B\" int4_ops);CREATE INDEX \"_CategoryToPost_B_index\" ON \"_CategoryToPost\"(\"B\" int4_ops);CREATE TABLE \"Category\" (    id integer SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id integer SERIAL PRIMARY KEY);\n```\n\nAnd you can define multiple many-to-many relations between two tables by using the different relationship name. This example shows how the Prisma introspection works under such case:\n\n```\nCREATE TABLE IF NOT EXISTS \"User\" (    \"id\" SERIAL PRIMARY KEY);CREATE TABLE IF NOT EXISTS \"Video\" (    \"id\" SERIAL PRIMARY KEY);CREATE TABLE IF NOT EXISTS \"_UserLikedVideos\" (    \"A\" SERIAL NOT NULL,    \"B\" SERIAL NOT NULL,    CONSTRAINT \"_UserLikedVideos_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"User\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT \"_UserLikedVideos_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Video\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE IF NOT EXISTS \"_UserDislikedVideos\" (    \"A\" SERIAL NOT NULL,    \"B\" SERIAL NOT NULL,    CONSTRAINT \"_UserDislikedVideos_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"User\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT \"_UserDislikedVideos_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Video\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE);CREATE UNIQUE INDEX \"_UserLikedVideos_AB_unique\" ON \"_UserLikedVideos\"(\"A\", \"B\");CREATE INDEX \"_UserLikedVideos_B_index\" ON \"_UserLikedVideos\"(\"B\");CREATE UNIQUE INDEX \"_UserDislikedVideos_AB_unique\" ON \"_UserDislikedVideos\"(\"A\", \"B\");CREATE INDEX \"_UserDislikedVideos_B_index\" ON \"_UserDislikedVideos\"(\"B\");\n```\n\nIf you run `prisma db pull` on this database, the Prisma CLI will generate the following schema through introspection:\n\n```\nmodel User {  id                       Int     @id @default(autoincrement())  Video_UserDislikedVideos Video[] @relation(\"UserDislikedVideos\")  Video_UserLikedVideos    Video[] @relation(\"UserLikedVideos\")}model Video {  id                      Int    @id @default(autoincrement())  User_UserDislikedVideos User[] @relation(\"UserDislikedVideos\")  User_UserLikedVideos    User[] @relation(\"UserLikedVideos\")}\n```\n\n#### Configuring the name of the relation table in implicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#configuring-the-name-of-the-relation-table-in-implicit-many-to-many-relations \"Direct link to Configuring the name of the relation table in implicit many-to-many relations\")\n\nWhen using Prisma Migrate, you can configure the name of the relation table that's managed by Prisma ORM using the `@relation` attribute. For example, if you want the relation table to be called `_MyRelationTable` instead of the default name `_CategoryToPost`, you can specify it as follows:\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"MyRelationTable\")}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"MyRelationTable\")}\n```\n\n### Relation tables[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables \"Direct link to Relation tables\")\n\nA relation table (also sometimes called a _JOIN_, _link_ or _pivot_ table) connects two or more other tables and therefore creates a _relation_ between them. Creating relation tables is a common data modelling practice in SQL to represent relationships between different entities. In essence it means that \"one m-n relation is modeled as two 1-n relations in the database\".\n\nWe recommend using [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) m-n-relations, where Prisma ORM automatically generates the relation table in the underlying database. [Explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) m-n-relations should be used when you need to store additional data in the relations, such as the date the relation was created.\n\n## MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb \"Direct link to MongoDB\")\n\nIn MongoDB, m-n-relations are represented by:\n\n*   relation fields on both sides, that each have a `@relation` attribute, with mandatory `fields` and `references` arguments\n*   a scalar list of referenced IDs on each side, with a type that matches the ID field on the other side\n\nThe following example demonstrates a m-n-relation between posts and categories:\n\n```\nmodel Post {  id          String     @id @default(auto()) @map(\"_id\") @db.ObjectId  categoryIDs String[]   @db.ObjectId  categories  Category[] @relation(fields: [categoryIDs], references: [id])}model Category {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  name    String  postIDs String[] @db.ObjectId  posts   Post[]   @relation(fields: [postIDs], references: [id])}\n```\n\nPrisma ORM validates m-n-relations in MongoDB with the following rules:\n\n*   The fields on both sides of the relation must have a list type (in the example above, `categories` have a type of `Category[]` and `posts` have a type of `Post[]`)\n*   The `@relation` attribute must define `fields` and `references` arguments on both sides\n*   The `fields` argument must have only one scalar field defined, which must be of a list type\n*   The `references` argument must have only one scalar field defined. This scalar field must exist on the referenced model and must be of the same type as the scalar field in the `fields` argument, but singular (no list)\n*   The scalar field to which `references` points must have the `@id` attribute\n*   No [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) are allowed in `@relation`\n\nThe implicit m-n-relations [used in relational databases](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) are not supported on MongoDB.\n\n### Querying MongoDB many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-mongodb-many-to-many-relations \"Direct link to Querying MongoDB many-to-many relations\")\n\nThis section demonstrates how to query m-n-relations in MongoDB, using the example schema above.\n\nThe following query finds posts with specific matching category IDs:\n\n```\nconst newId1 = new ObjectId()const newId2 = new ObjectId()const posts = await prisma.post.findMany({  where: {    categoryIDs: {      hasSome: [newId1.toHexString(), newId2.toHexString()],    },  },})\n```\n\nThe following query finds posts where the category name contains the string `'Servers'`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    categories: {      some: {        name: {          contains: 'Servers',        },      },    },  },})\n```",
    "title": "Many-to-many relations | Prisma Documentation",
    "description": "How to define and work with many-to-many relations in Prisma.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting",
    "markdown": "# Filtering and Sorting (Concepts) | Prisma Documentation\n\nPrisma Client supports [filtering](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering) with the `where` query option, and [sorting](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting) with the `orderBy` query option.\n\n## Filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering \"Direct link to Filtering\")\n\nPrisma Client allows you to filter records on any combination of model fields, [including related models](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-relations), and supports a variety of [filter conditions](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators).\n\nwarning\n\nSome filter conditions use the SQL operators `LIKE` and `ILIKE` which may cause unexpected behavior in your queries. Please refer to [our filtering FAQs](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering-faqs) for more information.\n\nThe following query:\n\n*   Returns all `User` records with:\n    *   an email address that ends with `prisma.io` _and_\n    *   at least one published post (a relation query)\n*   Returns all `User` fields\n*   Includes all related `Post` records where `published` equals `true`\n\n```\nconst result = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },    posts: {      some: {        published: true,      },    },  },  include: {    posts: {      where: {        published: true,      },    },  },})\n```\n\n### Filter conditions and operators[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators \"Direct link to Filter conditions and operators\")\n\nRefer to Prisma Client's reference documentation for [a full list of operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) , such as `startsWith` and `contains`.\n\n#### Combining operators[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#combining-operators \"Direct link to Combining operators\")\n\nYou can use operators (such as [`NOT`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not-1) and [`OR`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or) ) to filter by a combination of conditions. The following query returns all users with an `email` that ends in `\"prisma.io\"` or `\"gmail.com\"`, but not `\"hotmail.com\"`:\n\n```\nconst result = await prisma.user.findMany({  where: {    OR: [      {        email: {          endsWith: 'prisma.io',        },      },      { email: { endsWith: 'gmail.com' } },    ],    NOT: {      email: {        endsWith: 'hotmail.com',      },    },  },  select: {    email: true,  },})\n```\n\n### Filter on null fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-null-fields \"Direct link to Filter on null fields\")\n\nThe following query returns all posts whose `content` field is `null`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    content: null,  },})\n```\n\n### Filter for non-null fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-for-non-null-fields \"Direct link to Filter for non-null fields\")\n\nThe following query returns all posts whose `content` field is **not** `null`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    content: { not: null },  },})\n```\n\n### Filter on relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-relations \"Direct link to Filter on relations\")\n\nPrisma Client supports [filtering on related records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters). For example, in the following schema, a user can have many blog posts:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[] // User can have many posts}model Post {  id        Int     @id @default(autoincrement())  title     String  published Boolean @default(true)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int}\n```\n\nThe one-to-many relation between `User` and `Post` allows you to query users based on their posts - for example, the following query returns all users where _at least one_ post (`some`) has more than 10 views:\n\n```\nconst result = await prisma.user.findMany({  where: {    posts: {      some: {        views: {          gt: 10,        },      },    },  },})\n```\n\nYou can also query posts based on the properties of the author. For example, the following query returns all posts where the author's `email` contains `\"prisma.io\"`:\n\n```\nconst res = await prisma.post.findMany({  where: {    author: {      email: {        contains: 'prisma.io',      },    },  },})\n```\n\n### Filter on scalar lists / arrays[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-scalar-lists--arrays \"Direct link to Filter on scalar lists / arrays\")\n\nScalar lists (for example, `String[]`) have a special set of [filter conditions](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-filters) - for example, the following query returns all posts where the `tags` array contains `databases`:\n\n```\nconst posts = await client.post.findMany({  where: {    tags: {      has: 'databases',    },  },})\n```\n\n### Case-insensitive filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering \"Direct link to Case-insensitive filtering\")\n\nCase-insensitive filtering [is available as a feature for the PostgreSQL and MongoDB providers](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering). MySQL, MariaDB and Microsoft SQL Server are case-insensitive by default, and do not require a Prisma Client feature to make case-insensitive filtering possible.\n\nTo use case-insensitive filtering, add the `mode` property to a particular filter and specify `insensitive`:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },    name: {      equals: 'Archibald', // Default mode    },  },})\n```\n\nSee also: [Case sensitivity](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity)\n\n### Filtering FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering-faqs \"Direct link to Filtering FAQs\")\n\n#### How does filtering work at the database level?[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#how-does-filtering-work-at-the-database-level \"Direct link to How does filtering work at the database level?\")\n\nFor MySQL and PostgreSQL, Prisma Client utilizes the [`LIKE`](https://www.w3schools.com/sql/sql_like.asp) (and [`ILIKE`](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE)) operator to search for a given pattern. The operators have built-in pattern matching using symbols unique to `LIKE`. The pattern-matching symbols include `%` for zero or more characters (similar to `*` in other regex implementations) and `_` for one character (similar to `.`)\n\nTo match the literal characters, `%` or `_`, make sure you escape those characters. For example:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: {      startsWith: '_benny',    },  },})\n```\n\nThe above query will match any user whose name starts with a character followed by `benny` such as `7benny` or `&benny`. If you instead wanted to find any user whose name starts with the literal string `_benny`, you could do:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: {      startsWith: '\\\\_benny', // note that the `_` character is escaped, preceding `\\` with `\\` when included in a string    },  },})\n```\n\n## Sorting[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting \"Direct link to Sorting\")\n\nUse [`orderBy`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#orderby) to sort a list of records or a nested list of records by a particular field or set of fields. For example, the following query returns all `User` records sorted by `role` and `name`, **and** each user's posts sorted by `title`:\n\n```\nconst usersWithPosts = await prisma.user.findMany({  orderBy: [    {      role: 'desc',    },    {      name: 'desc',    },  ],  include: {    posts: {      orderBy: {        title: 'desc',      },      select: {        title: true,      },    },  },})\n```\n\n> **Note**: You can also [sort lists of nested records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-a-list-of-relations) to retrieve a single record by ID.\n\n### Sort by relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation \"Direct link to Sort by relation\")\n\nYou can also sort by properties of a relation. For example, the following query sorts all posts by the author's email address:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    author: {      email: 'asc',    },  },})\n```\n\n### Sort by relation aggregate value[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation-aggregate-value \"Direct link to Sort by relation aggregate value\")\n\nIn [2.19.0](https://github.com/prisma/prisma/releases/2.19.0) and later, you can sort by the **count of related records**.\n\nFor example, the following query sorts users by the number of related posts:\n\n```\nconst getActiveUsers = await prisma.user.findMany({  take: 10,  orderBy: {    posts: {      _count: 'desc',    },  },})\n```\n\n> **Note**: It is not currently possible to [return the count of a relation](https://github.com/prisma/prisma/issues/5079).\n\n### Sort by relevance (PostgreSQL and MySQL)[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relevance-postgresql-and-mysql \"Direct link to Sort by relevance (PostgreSQL and MySQL)\")\n\nIn [3.5.0+](https://github.com/prisma/prisma/releases/3.5.0) for PostgreSQL and [3.8.0+](https://github.com/prisma/prisma/releases/3.8.0) for MySQL, you can sort records by relevance to the query using the `_relevance` keyword. This uses the relevance ranking functions from full text search features.\n\nThis feature is further explain in [the PostgreSQL documentation](https://www.postgresql.org/docs/12/textsearch-controls.html) and [the MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html).\n\nEnable order by relevance with the `fullTextSearch` [preview feature](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search):\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n```\n\nOrdering by relevance can be used either separately from or together with the `search` filter: `_relevance` is used to order the list, while `search` filters the unordered list. For example, the following query uses `_relevance` to order the list of users by relevance to the search term `'developer'` in their bio, and `search` to filter the list:\n\n```\nconst getUsersByRelevance = await prisma.user.findMany({  take: 10,  orderBy: {    _relevance: {      fields: ['bio'],      search: 'developer',      sort: 'asc',    },  },})\n```\n\n  \n\nnote\n\nPrior to Prisma ORM 5.16.0, enabling the `fullTextSearch` preview feature would rename the `<Model>OrderByWithRelationInput` TypeScript types to `<Model>OrderByWithRelationAndSearchRelevanceInput`. If you are using the Preview feature, you will need to update your type imports.\n\n### Sort with null records first or last[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last \"Direct link to Sort with null records first or last\")\n\ninfo\n\nThis feature is generally available in version `4.16.0` and later. To use this feature in versions [`4.1.0`](https://github.com/prisma/prisma/releases/tag/4.1.0) to [`4.15.0`](https://github.com/prisma/prisma/releases/tag/4.15.0) the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `orderByNulls` will need to be enabled.\n\ninfo\n\nNote: Prisma Client does not support this feature for MongoDB.\n\nYou can sort the results so that records with `null` fields appear either first or last.\n\ninfo\n\n**Note:** You can only sort by nulls on optional [scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) fields. If you try to sort by nulls on a required or [relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields) field, Prisma Client throws a [P2009 error](https://www.prisma.io/docs/orm/reference/error-reference#p2009).\n\nExample: If `updatedAt` is an optional field, then the following query sorts posts by `updatedAt`, with null records at the end:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    updatedAt: { sort: 'asc', nulls: 'last' },  },})\n```\n\n### Sorting FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting-faqs \"Direct link to Sorting FAQs\")\n\n#### Can I perform case-insensitive sorting?[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#can-i-perform-case-insensitive-sorting \"Direct link to Can I perform case-insensitive sorting?\")\n\nFollow [issue #841 on GitHub](https://github.com/prisma/prisma-client-js/issues/841).",
    "title": "Filtering and Sorting (Concepts) | Prisma Documentation",
    "description": "Use Prisma Client API to filter records by any combination of fields or related record fields, and/or sort query results.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries",
    "markdown": "# Relation queries (Concepts) | Prisma Documentation\n\nA key feature of Prisma Client is the ability to query [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) between two or more models. Relation queries include:\n\n*   [Nested reads](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads) (sometimes referred to as _eager loading_) via [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) and [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n*   [Nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) with [transactional](https://www.prisma.io/docs/orm/prisma-client/queries/transactions) guarantees\n*   [Filtering on related records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters)\n\nPrisma Client also has a [fluent API for traversing relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api).\n\n## Nested reads[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads \"Direct link to Nested reads\")\n\nNested reads allow you to read related data from multiple tables in your database - such as a user and that user's posts. You can:\n\n*   Use [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) to include related records, such as a user's posts or profile, in the query response.\n*   Use a nested [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to include specific fields from a related record. You can also nest `select` inside an `include`.\n\n### Relation load strategies (Preview)[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview \"Direct link to Relation load strategies (Preview)\")\n\nSince version [5.8.0](https://github.com/prisma/prisma/releases/tag/5.8.0), you can decide on a per-query-level _how_ you want Prisma Client to execute a relation query (i.e. what _load strategy_ should be applied) via the `relationLoadStrategy` option for PostgreSQL databases.\n\nSince version [5.10.0](https://github.com/prisma/prisma/releases/tag/5.10.0), this feature is also available for MySQL.\n\nBecause the `relationLoadStrategy` option is currently in Preview, you need to enable it via the `relationJoins` preview feature flag in your Prisma schema file:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"relationJoins\"]}\n```\n\nAfter adding this flag, you need to run `prisma generate` again to re-generate Prisma Client. This feature is currently available on PostgreSQL, CockroachDB and MySQL.\n\nPrisma Client supports two load strategies for relations:\n\n*   `join` (default): Uses a database-level `LATERAL JOIN` (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\n*   `query`: Sends multiple queries to the database (one per table) and joins them on the application level.\n\nAnother important difference between these two options is that the `join` strategy uses JSON aggregation on the database level. That means that it creates the JSON structures returned by Prisma Client already in the database which saves computation resources on the application level.\n\n> **Note**: Once `relationLoadStrategy` moves from [Preview](https://www.prisma.io/docs/orm/more/releases#preview) into [General Availability](https://www.prisma.io/docs/orm/more/releases#generally-available-ga), `join` will universally become the default for all relation queries.\n\n#### Examples[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#examples \"Direct link to Examples\")\n\nYou can use the `relationLoadStrategy` option on the top-level in any query that supports `include` or `select`.\n\nHere is an example with `include`:\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join', // or 'query'  include: {    posts: true,  },})\n```\n\nAnd here is another example with `select`:\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join', // or 'query'  select: {    posts: true,  },})\n```\n\n#### When to use which load strategy?[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#when-to-use-which-load-strategy \"Direct link to When to use which load strategy?\")\n\n*   The `join` strategy (default) will be more effective in most scenarios. On PostgreSQL, it uses a combination of `LATERAL JOINs` and JSON aggregation to reduce redundancy in result sets and delegate the work of transforming the query results into the expected JSON structures on the database server. On MySQL, it uses correlated subqueries to fetch the results with a single query.\n*   There may be edge cases where `query` could be more performant depending on the characteristics of the dataset and query. We recommend that you profile your database queries to identify these situations.\n*   Use `query` if you want to save resources on the database server and do heavy-lifting of merging and transforming data in the application server which might be easier to scale.\n\n### Include a relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-a-relation \"Direct link to Include a relation\")\n\nThe following example returns a single user and that user's posts:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: true,  },})\n```\n\n### Include all fields for a specific relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-all-fields-for-a-specific-relation \"Direct link to Include all fields for a specific relation\")\n\nThe following example returns a post and its author:\n\n```\nconst post = await prisma.post.findFirst({  include: {    author: true,  },})\n```\n\n### Include deeply nested relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-deeply-nested-relations \"Direct link to Include deeply nested relations\")\n\nYou can nest `include` options to include relations of relations. The following example returns a user's posts, and each post's categories:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: {      include: {        categories: true,      },    },  },})\n```\n\n### Select specific fields of included relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations \"Direct link to Select specific fields of included relations\")\n\nYou can use a nested `select` to choose a subset of fields of relations to return. For example, the following query returns the user's `name` and the `title` of each related post:\n\n```\nconst user = await prisma.user.findFirst({  select: {    name: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\nYou can also nest a `select` inside an `include` - the following example returns _all_ `User` fields and the `title` field of each post:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: {      select: {        title: true,      },    },  },})\n```\n\nNote that you **cannot** use `select` and `include` _on the same level_. This means that if you choose to `include` a user's post and `select` each post's title, you cannot `select` only the users' `email`:\n\n```\n// The following query returns an exceptionconst user = await prisma.user.findFirst({  select: { // This won't work!    email:  true  }  include: { // This won't work!    posts: {      select: {        title: true      }    }  },})\n```\n\nInstead, use nested `select` options:\n\n```\nconst user = await prisma.user.findFirst({  select: {    // This will work!    email: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\n## Relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-count \"Direct link to Relation count\")\n\nIn [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` or `select` a count of relations](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) alongside fields - for example, a user's post count.\n\n```\nconst relationCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\n## Filter a list of relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-a-list-of-relations \"Direct link to Filter a list of relations\")\n\nWhen you use `select` or `include` to return a subset of the related data, you can **filter and sort the list of relations** inside the `select` or `include`.\n\nFor example, the following query returns all users and a list of titles of the unpublished posts associated with each user:\n\n```\nconst result = await prisma.user.findFirst({  select: {    posts: {      where: {        published: false,      },      orderBy: {        title: 'asc',      },      select: {        title: true,      },    },  },})\n```\n\nYou can also write the same query using `include` as follows:\n\n```\nconst result = await prisma.user.findFirst({  include: {    posts: {      where: {        published: false,      },      orderBy: {        title: 'asc',      },    },  },})\n```\n\n## Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes \"Direct link to Nested writes\")\n\nA nested write allows you to write **relational data** to your database in **a single transaction**.\n\nNested writes:\n\n*   Provide **transactional guarantees** for creating, updating or deleting data across multiple tables in a single Prisma Client query. If any part of the query fails (for example, creating a user succeeds but creating posts fails), Prisma Client rolls back all changes.\n*   Support any level of nesting supported by the data model.\n*   Are available for [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) when using the model's create or update query. The following section shows the nested write options that are available per query.\n\nYou can create a record and one or more related records at the same time. The following query creates a `User` record and two related `Post` records:\n\n```\nconst result = await prisma.user.create({  data: {    email: 'elsa@prisma.io',    name: 'Elsa Prisma',    posts: {      create: [        { title: 'How to make an omelette' },        { title: 'How to eat an omelette' },      ],    },  },  include: {    posts: true, // Include all posts in the returned object  },})\n```\n\n### Create a single record and multiple related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-a-single-record-and-multiple-related-records \"Direct link to Create a single record and multiple related records\")\n\nThere are two ways to create or update a single record and multiple related records - for example, a user with multiple posts:\n\n*   Use a nested [`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) query\n*   Use a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1) query\n\nIn most cases, a nested `create` will be preferable unless the [`skipDuplicates` query option](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-createmany-options) is required. Here's a quick table describing the differences between the two options:\n\n| Feature | `create` | `createMany` | Notes |\n| --- | --- | --- | --- |\n| Supports nesting additional relations | ✔   | ✘ \\* | For example, you can create a user, several posts, and several comments per post in one query.  <br>\\* You can manually set a foreign key in a has-one relation - for example: `{ authorId: 9}` |\n| Supports 1-n relations | ✔   | ✔   | For example, you can create a user and multiple posts (one user has many posts) |\n| Supports m-n relations | ✔   | ✘   | For example, you can create a post and several categories (one post can have many categories, and one category can have many posts) |\n| Supports skipping duplicate records | ✘   | ✔   | Use `skipDuplicates` query option. |\n\n#### Using nested `create`[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#using-nested-create \"Direct link to using-nested-create\")\n\nThe following query uses nested [`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) to create:\n\n*   One user\n*   Two posts\n*   One post category\n\nThe example also uses a nested `include` to include all posts and post categories in the returned data.\n\n```\nconst result = await prisma.user.create({  data: {    email: 'yvette@prisma.io',    name: 'Yvette',    posts: {      create: [        {          title: 'How to make an omelette',          categories: {            create: {              name: 'Easy cooking',            },          },        },        { title: 'How to eat an omelette' },      ],    },  },  include: {    // Include posts    posts: {      include: {        categories: true, // Include post categories      },    },  },})\n```\n\n#### Using nested `createMany`[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#using-nested-createmany \"Direct link to using-nested-createmany\")\n\nThe following query uses a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) to create:\n\n*   One user\n*   Two posts\n\nThe example also uses a nested `include` to include all posts in the returned data.\n\n```\nconst result = await prisma.user.create({  data: {    email: 'saanvi@prisma.io',    posts: {      createMany: {        data: [{ title: 'My first post' }, { title: 'My second post' }],      },    },  },  include: {    posts: true,  },})\n```\n\nwarning\n\n**Note**: It is **not possible** to nest an additional `create` or `createMany` inside the highlighted query, which means that you cannot create a user, posts, and post categories at the same time.\n\n### Create multiple records and multiple related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-multiple-records-and-multiple-related-records \"Direct link to Create multiple records and multiple related records\")\n\nYou cannot access relations in a `createMany()` or `createManyAndReturn()` query, which means that you cannot create multiple users and multiple posts in a single nested write. The following is **not** possible:\n\n```\nconst createMany = await prisma.user.createMany({  data: [    {      name: 'Yewande',      email: 'yewande@prisma.io',      posts: {        // Not possible to create posts!      },    },    {      name: 'Noor',      email: 'noor@prisma.io',      posts: {        // Not possible to create posts!      },    },  ],})\n```\n\n### Connect multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-multiple-records \"Direct link to Connect multiple records\")\n\nThe following query creates ([`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create) ) a new `User` record and connects that record ([`connect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) ) to three existing posts:\n\n```\nconst result = await prisma.user.create({  data: {    email: 'vlad@prisma.io',    posts: {      connect: [{ id: 8 }, { id: 9 }, { id: 10 }],    },  },  include: {    posts: true, // Include all posts in the returned object  },})\n```\n\n> **Note**: Prisma Client throws an exception if any of the post records cannot be found: `connect: [{ id: 8 }, { id: 9 }, { id: 10 }]`\n\n### Connect a single record[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-a-single-record \"Direct link to Connect a single record\")\n\nYou can [`connect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) an existing record to a new or existing user. The following query connects an existing post (`id: 11`) to an existing user (`id: 9`)\n\n```\nconst result = await prisma.user.update({  where: {    id: 9,  },  data: {    posts: {      connect: {        id: 11,      },    },  },  include: {    posts: true,  },})\n```\n\n### Connect _or_ create a record[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-or-create-a-record \"Direct link to connect-or-create-a-record\")\n\nIf a related record may or may not already exist, use [`connectOrCreate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate) to connect the related record:\n\n*   Connect a `User` with the email address `viola@prisma.io` _or_\n*   Create a new `User` with the email address `viola@prisma.io` if the user does not already exist\n\n```\nconst result = await prisma.post.create({  data: {    title: 'How to make croissants',    author: {      connectOrCreate: {        where: {          email: 'viola@prisma.io',        },        create: {          email: 'viola@prisma.io',          name: 'Viola',        },      },    },  },  include: {    author: true,  },})\n```\n\nTo `disconnect` one out of a list of records (for example, a specific blog post) provide the ID or unique identifier of the record(s) to disconnect:\n\n```\nconst result = await prisma.user.update({  where: {    id: 16,  },  data: {    posts: {      disconnect: [{ id: 12 }, { id: 19 }],    },  },  include: {    posts: true,  },})\n```\n\nTo `disconnect` _one_ record (for example, a post's author), use `disconnect: true`:\n\n```\nconst result = await prisma.post.update({  where: {    id: 23,  },  data: {    author: {      disconnect: true,    },  },  include: {    author: true,  },})\n```\n\nTo [`disconnect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect) _all_ related records in a one-to-many relation (a user has many posts), `set` the relation to an empty list as shown:\n\n```\nconst result = await prisma.user.update({  where: {    id: 16,  },  data: {    posts: {      set: [],    },  },  include: {    posts: true,  },})\n```\n\nDelete all related `Post` records:\n\n```\nconst result = await prisma.user.update({  where: {    id: 11,  },  data: {    posts: {      deleteMany: {},    },  },  include: {    posts: true,  },})\n```\n\nUpdate a user by deleting all unpublished posts:\n\n```\nconst result = await prisma.user.update({  where: {    id: 11,  },  data: {    posts: {      deleteMany: {        published: false,      },    },  },  include: {    posts: true,  },})\n```\n\nUpdate a user by deleting specific posts:\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      deleteMany: [{ id: 7 }],    },  },  include: {    posts: true,  },})\n```\n\nYou can use a nested `updateMany` to update _all_ related records for a particular user. The following query unpublishes all posts for a specific user:\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      updateMany: {        where: {          published: true,        },        data: {          published: false,        },      },    },  },  include: {    posts: true,  },})\n```\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      update: {        where: {          id: 9,        },        data: {          title: 'My updated title',        },      },    },  },  include: {    posts: true,  },})\n```\n\nThe following query uses a nested `upsert` to update `\"bob@prisma.io\"` if that user exists, or create the user if they do not exist:\n\n```\nconst result = await prisma.post.update({  where: {    id: 6,  },  data: {    author: {      upsert: {        create: {          email: 'bob@prisma.io',          name: 'Bob the New User',        },        update: {          email: 'bob@prisma.io',          name: 'Bob the existing user',        },      },    },  },  include: {    author: true,  },})\n```\n\nYou can nest `create` or `createMany` inside an `update` to add new related records to an existing record. The following query adds two posts to a user with an `id` of 9:\n\n```\nconst result = await prisma.user.update({  where: {    id: 9,  },  data: {    posts: {      createMany: {        data: [{ title: 'My first post' }, { title: 'My second post' }],      },    },  },  include: {    posts: true,  },})\n```\n\n## Relation filters[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters \"Direct link to Relation filters\")\n\n### Filter on \"-to-many\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on--to-many-relations \"Direct link to Filter on \"-to-many\" relations\")\n\nPrisma Client provides the [`some`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#some), [`every`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#every), and [`none`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#none) options to filter records by the properties of related records on the \"-to-many\" side of the relation. For example, filtering users based on properties of their posts.\n\nFor example:\n\n| Requirement | Query option to use |\n| --- | --- |\n| \"I want a list of every `User` that has _at least one_ unpublished `Post` record\" | `some` posts are unpublished |\n| \"I want a list of every `User` that has _no_ unpublished `Post` records\" | `none` of the posts are unpublished |\n| \"I want a list of every `User` that has _only_ unpublished `Post` records\" | `every` post is unpublished |\n\nFor example, the following query returns `User` that meet the following criteria:\n\n*   No posts with more than 100 views\n*   All posts have less than, or equal to 50 likes\n\n```\nconst users = await prisma.user.findMany({  where: {    posts: {      none: {        views: {          gt: 100,        },      },      every: {        likes: {          lte: 50,        },      },    },  },  include: {    posts: true,  },})\n```\n\n### Filter on \"-to-one\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on--to-one-relations \"Direct link to Filter on \"-to-one\" relations\")\n\nPrisma Client provides the [`is`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#is) and [`isNot`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isnot) options to filter records by the properties of related records on the \"-to-one\" side of the relation. For example, filtering posts based on properties of their author.\n\nFor example, the following query returns `Post` records that meet the following criteria:\n\n*   Author's name is not Bob\n*   Author is older than 40\n\n```\nconst users = await prisma.post.findMany({  where: {    author: {      isNot: {        name: 'Bob',      },      is: {        age: {          gt: 40,        },      },    },  },  include: {    author: true,  },})\n```\n\n### Filter on absence of \"-to-many\" records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on-absence-of--to-many-records \"Direct link to Filter on absence of \"-to-many\" records\")\n\nFor example, the following query uses `none` to return all users that have zero posts:\n\n```\nconst usersWithZeroPosts = await prisma.user.findMany({  where: {    posts: {      none: {},    },  },  include: {    posts: true,  },})\n```\n\n### Filter on absence of \"-to-one\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on-absence-of--to-one-relations \"Direct link to Filter on absence of \"-to-one\" relations\")\n\nThe following query returns all posts that don't have an author relation:\n\n```\nconst postsWithNoAuthor = await prisma.post.findMany({  where: {    author: null, // or author: { }  },  include: {    author: true,  },})\n```\n\nThe following query returns all users with at least one post:\n\n```\nconst usersWithSomePosts = await prisma.user.findMany({  where: {    posts: {      some: {},    },  },  include: {    posts: true,  },})\n```\n\n## Fluent API[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api \"Direct link to Fluent API\")\n\nThe fluent API lets you _fluently_ traverse the [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) of your models via function calls. Note that the _last_ function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).\n\nThis query returns all `Post` records by a specific `User`:\n\n```\nconst postsByUser: Post[] = await prisma.user  .findUnique({ where: { email: 'alice@prisma.io' } })  .posts()\n```\n\nThis is equivalent to the following `findMany` query:\n\n```\nconst postsByUser = await prisma.post.findMany({  where: {    author: {      email: 'alice@prisma.io',    },  },})\n```\n\nThe main difference between the queries is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984))\n\n> **Note**: You can use the fact that `.findUnique({ where: { email: 'alice@prisma.io' } }).posts()` queries are automatically batched by the Prisma dataloader in Prisma Client to [avoid the n+1 problem in GraphQL resolvers](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader).\n\nThis request returns all categories by a specific post:\n\n```\nconst categoriesOfPost: Category[] = await prisma.post  .findUnique({ where: { id: 1 } })  .categories()\n```\n\nNote that you can chain as many queries as you like. In this example, the chaining starts at `Profile` and goes over `User` to `Post`:\n\n```\nconst posts: Post[] = await prisma.profile  .findUnique({ where: { id: 1 } })  .user()  .posts()\n```\n\nThe only requirement for chaining is that the previous function call must return only a _single object_ (e.g. as returned by a `findUnique` query or a \"to-one relation\" like `profile.user()`).\n\nThe following query is **not possible** because `findMany` does not return a single object but a _list_:\n\n```\n// This query is illegalconst posts = await prisma.user.findMany().posts()\n```",
    "title": "Relation queries (Concepts) | Prisma Documentation",
    "description": "Prisma Client provides convenient queries for working with relations, such as a fluent API, nested writes (transactions), nested reads and relation filters.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/pagination",
    "markdown": "# Pagination (Reference) | Prisma Documentation\n\nPrisma Client supports both offset pagination and cursor-based pagination.\n\nOffset pagination uses `skip` and `take` to skip a certain number of results and select a limited range. The following query skips the first 3 `Post` records and returns records 4 - 7:\n\n```\nconst results = await prisma.post.findMany({  skip: 3,  take: 4,})\n```\n\n![](https://www.prisma.io/docs/assets/images/offset-skip-take-761acfc939aa498db1a8a48a1b7c1a38.png)\n\nTo implement pages of results, you would just `skip` the number of pages multiplied by the number of results you show per page.\n\n*   You can jump to any page immediately. For example, you can `skip` 200 records and `take` 10, which simulates jumping straight to page 21 of the result set (the underlying SQL uses `OFFSET`). This is not possible with cursor-based pagination.\n*   You can paginate the same result set in any sort order. For example, you can jump to page 21 of a list of `User` records sorted by first name. This is not possible with cursor-based pagination, which requires sorting by a unique, sequential column.\n\n*   Offset pagination **does not scale** at a database level. For example, if you skip 200,000 records and take the first 10, the database still has to traverse the first 200,000 records before returning the 10 that you asked for - this negatively affects performance.\n\n*   Shallow pagination of a small result set. For example, a blog interface that allows you to filter `Post` records by author and paginate the results.\n\n### Example: Filtering and offset pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-filtering-and-offset-pagination \"Direct link to Example: Filtering and offset pagination\")\n\nThe following query returns all records where the `email` field contains `prisma.io`. The query skips the first 40 records and returns records 41 - 50.\n\n```\nconst results = await prisma.post.findMany({  skip: 40,  take: 10,  where: {    email: {      contains: 'prisma.io',    },  },})\n```\n\n### Example: Sorting and offset pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-sorting-and-offset-pagination \"Direct link to Example: Sorting and offset pagination\")\n\nThe following query returns all records where the `email` field contains `Prisma`, and sorts the result by the `title` field. The query skips the first 200 records and returns records 201 - 220.\n\n```\nconst results = await prisma.post.findMany({  skip: 200,  take: 20,  where: {    email: {      contains: 'Prisma',    },  },  orderBy: {    title: 'desc',  },})\n```\n\nCursor-based pagination uses `cursor` and `take` to return a limited set of results before or after a given **cursor**. A cursor bookmarks your location in a result set and must be a unique, sequential column - such as an ID or a timestamp.\n\nThe following example returns the first 4 `Post` records that contain the word `\"Prisma\"` and saves the ID of the last record as `myCursor`:\n\n> **Note**: Since this is the first query, there is no cursor to pass in.\n\n```\nconst firstQueryResults = await prisma.post.findMany({  take: 4,  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})// Bookmark your location in the result set - in this// case, the ID of the last post in the list of 4.const lastPostInResults = firstQueryResults[3] // Remember: zero-based index! :)const myCursor = lastPostInResults.id // Example: 29\n```\n\nThe following diagram shows the IDs of the first 4 results - or page 1. The cursor for the next query is **29**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-1-77db774b6e7cd70f97903db7aaf5c2af.png)\n\nThe second query returns the first 4 `Post` records that contain the word `\"Prisma\"` **after the supplied cursor** (in other words - IDs that are larger than **29**):\n\n```\nconst secondQueryResults = await prisma.post.findMany({  take: 4,  skip: 1, // Skip the cursor  cursor: {    id: myCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})const lastPostInResults = secondQueryResults[3] // Remember: zero-based index! :)const myCursor = lastPostInResults.id // Example: 52\n```\n\nThe following diagram shows the first 4 `Post` records **after** the record with ID **29**. In this example, the new cursor is **52**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-2-d6143e7931d422bb653ca96523d8a542.png)\n\n### FAQ[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#faq \"Direct link to FAQ\")\n\n#### Do I always have to skip: 1?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#do-i-always-have-to-skip-1 \"Direct link to Do I always have to skip: 1?\")\n\nIf you do not `skip: 1`, your result set will include your previous cursor. The first query returns four results and the cursor is **29**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-1-77db774b6e7cd70f97903db7aaf5c2af.png)\n\nWithout `skip: 1`, the second query returns 4 results after (and _including_) the cursor:\n\n![](https://www.prisma.io/docs/assets/images/cursor-3-afdca78b2f1c2407a2b82df6e8b0aebf.png)\n\nIf you `skip: 1`, the cursor is not included:\n\n![](https://www.prisma.io/docs/assets/images/cursor-2-d6143e7931d422bb653ca96523d8a542.png)\n\nYou can choose to `skip: 1` or not depending on the pagination behavior that you want.\n\n#### Can I guess the value of the cursor?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#can-i-guess-the-value-of-the-cursor \"Direct link to Can I guess the value of the cursor?\")\n\nIf you guess the value of the next cursor, you will page to an unknown location in your result set. Although IDs are sequential, you cannot predict the rate of increment (`2`, `20`, `32` is more likely than `1`, `2`, `3`, particularly in a filtered result set).\n\nNo, cursor pagination does not use cursors in the underlying database ([e.g. PostgreSQL](https://www.postgresql.org/docs/9.2/plpgsql-cursors.html)).\n\n#### What happens if the cursor value does not exist?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#what-happens-if-the-cursor-value-does-not-exist \"Direct link to What happens if the cursor value does not exist?\")\n\nUsing a nonexistent cursor returns `null`. Prisma Client does not try to locate adjacent values.\n\n*   Cursor-based pagination **scales**. The underlying SQL does not use `OFFSET`, but instead queries all `Post` records with an ID greater than the value of `cursor`.\n\n*   You must sort by your cursor, which has to be a unique, sequential column.\n*   You cannot jump to a specific page using only a cursor. For example, you cannot accurately predict which cursor represents the start of page 400 (page size 20) without first requesting pages 1 - 399.\n\n*   Infinite scroll - for example, sort blog posts by date/time descending and request 10 blog posts at a time.\n*   Paging through an entire result set in batches - for example, as part of a long-running data export.\n\n### Example: Filtering and cursor-based pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-filtering-and-cursor-based-pagination \"Direct link to Example: Filtering and cursor-based pagination\")\n\n```\nconst secondQuery = await prisma.post.findMany({  take: 4,  cursor: {    id: myCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})\n```\n\n### Sorting and cursor-based pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#sorting-and-cursor-based-pagination \"Direct link to Sorting and cursor-based pagination\")\n\nCursor-based pagination requires you to sort by a sequential, unique column such as an ID or a timestamp. This value - known as a cursor - bookmarks your place in the result set and allows you to request the next set.\n\nTo page backwards, set `take` to a negative value. The following query returns 4 `Post` records with an `id` of less than 200, excluding the cursor:\n\n```\nconst myOldCursor = 200const firstQueryResults = await prisma.post.findMany({  take: -4,  skip: 1,  cursor: {    id: myOldCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})\n```",
    "title": "Pagination (Reference) | Prisma Documentation",
    "description": "Prisma Client supports both offset pagination and cursor-based pagination. Learn more about the pros and cons of different pagination approaches and how to implement them.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing",
    "markdown": "# Aggregation, grouping, and summarizing (Concepts)\n\nPrisma Client allows you to count records, aggregate number fields, and select distinct field values.\n\n## Aggregate[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate \"Direct link to Aggregate\")\n\nPrisma Client allows you to [`aggregate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#aggregate) on the **number** fields (such as `Int` and `Float`) of a model. The following query returns the average age of all users:\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },})console.log('Average age:' + aggregations._avg.age)\n```\n\nYou can combine aggregation with filtering and ordering. For example, the following query returns the average age of users:\n\n*   Ordered by `age` ascending\n*   Where `email` contains `prisma.io`\n*   Limited to the 10 users\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },  where: {    email: {      contains: 'prisma.io',    },  },  orderBy: {    age: 'asc',  },  take: 10,})console.log('Average age:' + aggregations._avg.age)\n```\n\n### Aggregate values are nullable[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate-values-are-nullable \"Direct link to Aggregate values are nullable\")\n\nIn [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0) and later, aggregations on **nullable fields** can return a `number` or `null`. This excludes `count`, which always returns 0 if no records are found.\n\nConsider the following query, where `age` is nullable in the schema:\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },  _count: {    age: true,  },})\n```\n\nThe query returns `{ _avg: { age: null } }` in either of the following scenarios:\n\n*   There are no users\n*   The value of every user's `age` field is `null`\n\nThis allows you to differentiate between the true aggregate value (which could be zero) and no data.\n\n## Group by[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#group-by \"Direct link to Group by\")\n\nPrisma Client's [`groupBy()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby) allows you to **group records** by one or more field values - such as `country`, or `country` and `city` and **perform aggregations** on each group, such as finding the average age of people living in a particular city. `groupBy()` is a GA in [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later.\n\nThe following video uses `groupBy()` to summarize total COVID-19 cases by continent:\n\nThe following example groups all users by the `country` field and returns the total number of profile views for each country:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  _sum: {    profileViews: true,  },})\n```\n\nIf you have a single element in the `by` option, you can use the following shorthand syntax to express your query:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: 'country',})\n```\n\n### `groupBy()` and filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-and-filtering \"Direct link to groupby-and-filtering\")\n\n`groupBy()` supports two levels of filtering: `where` and `having`.\n\n#### Filter records with `where`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-records-with-where \"Direct link to filter-records-with-where\")\n\nUse `where` to filter all records **before grouping**. The following example groups users by country and sums profile views, but only includes users where the email address contains `prisma.io`:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    email: {      contains: 'prisma.io',    },  },  _sum: {    profileViews: true,  },})\n```\n\n#### Filter groups with `having`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-groups-with-having \"Direct link to filter-groups-with-having\")\n\nUse `having` to filter **entire groups** by an aggregate value such as the sum or average of a field, not individual records - for example, only return groups where the _average_ `profileViews` is greater than 100:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    email: {      contains: 'prisma.io',    },  },  _sum: {    profileViews: true,  },  having: {    profileViews: {      _avg: {        gt: 100,      },    },  },})\n```\n\n##### Use case for `having`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#use-case-for-having \"Direct link to use-case-for-having\")\n\nThe primary use case for `having` is to filter on aggregations. We recommend that you use `where` to reduce the size of your data set as far as possible _before_ grouping, because doing so ✔ reduces the number of records the database has to return and ✔ makes use of indices.\n\nFor example, the following query groups all users that are _not_ from Sweden or Ghana:\n\n```\nconst fd = await prisma.user.groupBy({  by: ['country'],  where: {    country: {      notIn: ['Sweden', 'Ghana'],    },  },  _sum: {    profileViews: true,  },  having: {    profileViews: {      _min: {        gte: 10,      },    },  },})\n```\n\nThe following query technically achieves the same result, but excludes users from Ghana _after_ grouping. This does not confer any benefit and is not recommended practice.\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    country: {      not: 'Sweden',    },  },  _sum: {    profileViews: true,  },  having: {    country: {      not: 'Ghana',    },    profileViews: {      _min: {        gte: 10,      },    },  },})\n```\n\n> **Note**: Within `having`, you can only filter on aggregate values _or_ fields available in `by`.\n\n### `groupBy()` and ordering[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-and-ordering \"Direct link to groupby-and-ordering\")\n\nThe following constraints apply when you combine `groupBy()` and `orderBy`:\n\n*   You can `orderBy` fields that are present in `by`\n*   You can `orderBy` aggregate (Preview in 2.21.0 and later)\n*   If you use `skip` and/or `take` with `groupBy()`, you must also include `orderBy` in the query\n\n#### Order by aggregate group[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-aggregate-group \"Direct link to Order by aggregate group\")\n\nYou can **order by aggregate group**. Prisma ORM added support for using `orderBy` with aggregated groups in relational databases in version [2.21.0](https://github.com/prisma/prisma/releases/2.21.0) and support for MongoDB in [3.4.0](https://github.com/prisma/prisma/releases/3.4.0).\n\nThe following example sorts each `city` group by the number of users in that group (largest group first):\n\n```\nconst groupBy = await prisma.user.groupBy({  by: ['city'],  _count: {    city: true,  },  orderBy: {    _count: {      city: 'desc',    },  },})\n```\n\n#### Order by field[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-field \"Direct link to Order by field\")\n\nThe following query orders groups by country, skips the first two groups, and returns the 3rd and 4th group:\n\n```\nconst groupBy = await prisma.user.groupBy({  by: ['country'],  _sum: {    profileViews: true,  },  orderBy: {    country: 'desc',  },  skip: 2,  take: 2,})\n```\n\n### `groupBy()` FAQ[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-faq \"Direct link to groupby-faq\")\n\n#### Can I use `select` with `groupBy()`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#can-i-use-select-with-groupby \"Direct link to can-i-use-select-with-groupby\")\n\nYou cannot use `select` with `groupBy()`. However, all fields included in `by` are automatically returned.\n\n#### What is the difference between using `where` and `having` with `groupBy()`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#what-is-the-difference-between-using-where-and-having-with-groupby \"Direct link to what-is-the-difference-between-using-where-and-having-with-groupby\")\n\n`where` filters all records before grouping, and `having` filters entire groups and supports filtering on an aggregate field value, such as the average or sum of a particular field in that group.\n\n#### What is the difference between `groupBy()` and `distinct`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#what-is-the-difference-between-groupby-and-distinct \"Direct link to what-is-the-difference-between-groupby-and-distinct\")\n\nBoth `distinct` and `groupBy()` group records by one or more unique field values. `groupBy()` allows you to aggregate data within each group - for example, return the average number of views on posts from Denmark - whereas distinct does not.\n\n## Count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count \"Direct link to Count\")\n\n### Count records[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-records \"Direct link to Count records\")\n\nUse [`count()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count) to count the number of records or non-`null` field values. The following example query counts all users:\n\n```\nconst userCount = await prisma.user.count()\n```\n\n### Count relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations \"Direct link to Count relations\")\n\ninfo\n\nThis feature is generally available in version [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later. To use this feature in versions before 3.0.1 the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `selectRelationCount` will need to be enabled.\n\nTo return a count of relations (for example, a user's post count), use the `_count` parameter with a nested `select` as shown:\n\n```\nconst usersWithCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\nThe `_count` parameter:\n\n*   Can be used inside a top-level `include` _or_ `select`\n*   Can be used with any query that returns records (including `delete`, `update`, and `findFirst`)\n*   Can return [multiple relation counts](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-multiple-relation-counts)\n*   Can [filter relation counts](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count) (from version 4.3.0)\n\n#### Return a relations count with `include`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-a-relations-count-with-include \"Direct link to return-a-relations-count-with-include\")\n\nThe following query includes each user's post count in the results:\n\n```\nconst usersWithCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\n#### Return a relations count with `select`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-a-relations-count-with-select \"Direct link to return-a-relations-count-with-select\")\n\nThe following query uses `select` to return each user's post count _and no other fields_:\n\n```\nconst usersWithCount = await prisma.user.findMany({  select: {    _count: {      select: { posts: true },    },  },})\n```\n\n#### Return multiple relation counts[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-multiple-relation-counts \"Direct link to Return multiple relation counts\")\n\nThe following query returns a count of each user's `posts` and `recipes` and no other fields:\n\n```\nconst usersWithCount = await prisma.user.findMany({  select: {    _count: {      select: {        posts: true,        recipes: true,      },    },  },})\n```\n\n#### Filter the relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count \"Direct link to Filter the relation count\")\n\ninfo\n\nThis feature is generally available in version `4.16.0` and later. To use this feature in versions [`4.3.0`](https://github.com/prisma/prisma/releases/tag/4.3.0) to [`4.15.0`](https://github.com/prisma/prisma/releases/tag/4.15.0) the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `filteredRelationCount` will need to be enabled.\n\nUse `where` to filter the fields returned by the `_count` output type. You can do this on [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields), [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields) and fields of a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types).\n\nFor example, the following query returns all user posts with the title \"Hello!\":\n\n```\n// Count all user posts with the title \"Hello!\"await prisma.user.findMany({  select: {    _count: {      select: {        posts: { where: { title: 'Hello!' } },      },    },  },})\n```\n\nThe following query finds all user posts with comments from an author named \"Alice\":\n\n```\n// Count all user posts that have comments// whose author is named \"Alice\"await prisma.user.findMany({  select: {    _count: {      select: {        posts: {          where: { comments: { some: { author: { is: { name: 'Alice' } } } } },        },      },    },  },})\n```\n\n### Count non-`null` field values[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-non-null-field-values \"Direct link to count-non-null-field-values\")\n\nIn [2.15.0](https://github.com/prisma/prisma/releases/2.15.0) and later, you can count all records as well as all instances of non-`null` field values. The following query returns a count of:\n\n*   All `User` records (`_all`)\n*   All non-`null` `name` values (not distinct values, just values that are not `null`)\n\n```\nconst userCount = await prisma.user.count({  select: {    _all: true, // Count all records    name: true, // Count all non-null field values  },})\n```\n\n### Filtered count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filtered-count \"Direct link to Filtered count\")\n\n`count` supports filtering. The following example query counts all users with more than 100 profile views:\n\n```\nconst userCount = await prisma.user.count({  where: {    profileViews: {      gte: 100,    },  },})\n```\n\nThe following example query counts a particular user's posts:\n\n```\nconst postCount = await prisma.post.count({  where: {    authorId: 29,  },})\n```\n\n## Select distinct[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#select-distinct \"Direct link to Select distinct\")\n\nPrisma Client allows you to filter duplicate rows from a Prisma Query response to a [`findMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany) query using [`distinct`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#distinct) . `distinct` is often used in combination with [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to identify certain unique combinations of values in the rows of your table.\n\nThe following example returns all fields for all `User` records with distinct `name` field values:\n\n```\nconst result = await prisma.user.findMany({  where: {},  distinct: ['name'],})\n```\n\nThe following example returns distinct `role` field values (for example, `ADMIN` and `USER`):\n\n```\nconst distinctRoles = await prisma.user.findMany({  distinct: ['role'],  select: {    role: true,  },})\n```\n\n### `distinct` under the hood[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#distinct-under-the-hood \"Direct link to distinct-under-the-hood\")\n\nPrisma Client's `distinct` option does not use SQL `SELECT DISTINCT`. Instead, `distinct` uses:\n\n*   A `SELECT` query\n*   In-memory post-processing to select distinct\n\nIt was designed in this way in order to **support `select` and `include`** as part of `distinct` queries.\n\nThe following example selects distinct on `gameId` and `playerId`, ordered by `score`, in order to return **each player's highest score per game**. The query uses `include` and `select` to include additional data:\n\n*   Select `score` (field on `Play`)\n*   Select related player name (relation between `Play` and `User`)\n*   Select related game name (relation between `Play` and `Game`)\n\nExpand for sample schema\n\n```\nmodel User {  id   Int     @id @default(autoincrement())  name String?  play Play[]}model Game {  id   Int     @id @default(autoincrement())  name String?  play Play[]}model Play {  id       Int   @id @default(autoincrement())  score    Int?  @default(0)  playerId Int?  player   User? @relation(fields: [playerId], references: [id])  gameId   Int?  game     Game? @relation(fields: [gameId], references: [id])}\n```\n\n```\nconst distinctScores = await prisma.play.findMany({  distinct: ['playerId', 'gameId'],  orderBy: {    score: 'desc',  },  select: {    score: true,    game: {      select: {        name: true,      },    },    player: {      select: {        name: true,      },    },  },})\n```\n\nWithout `select` and `distinct`, the query would return:\n\n```\n[  {    gameId: 2,    playerId: 5  },  {    gameId: 2,    playerId: 10  }]\n```",
    "title": "Aggregation, grouping, and summarizing (Concepts) | Prisma Documentation",
    "description": "Use Prisma Client to aggregate, group by, count, and select distinct.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/computed-fields",
    "markdown": "# Computed fields | Prisma Documentation\n\nwarning\n\nWith Prisma Client extensions Generally Available as of Prisma ORM version 4.16.0, the following steps are not recommended. Please use [a client extension](https://www.prisma.io/docs/orm/prisma-client/queries/computed-fields#using-a-prisma-client-extension) to accomplish this.\n\nPrisma Client does not yet natively support computed fields, but, you can define a function that accepts a generic type as an input then extend that generic to ensure it conforms to a specific structure. Finally, you can return that generic with additional computed fields. Let's see how that might look:\n\n*   TypeScript\n*   JavaScript\n\n```\n// Define a type that needs a first and last nametype FirstLastName = {  firstName: string  lastName: string}// Extend the T generic with the fullName attributetype WithFullName<T> = T & {  fullName: string}// Take objects that satisfy FirstLastName and computes a full namefunction computeFullName<User extends FirstLastName>(  user: User): WithFullName<User> {  return {    ...user,    fullName: user.firstName + ' ' + user.lastName,  }}async function main() {  const user = await prisma.user.findUnique({ where: 1 })  const userWithFullName = computeFullName(user)}\n```\n\nIn the TypeScript example above, a `User` generic has been defined that extends the `FirstLastName` type. This means that whatever you pass into `computeFullName` must contain `firstName` and `lastName` keys.\n\nA `WithFullName<User>` return type has also been defined, which takes whatever `User` is and tacks on a `fullName` string attribute.\n\nWith this function, any object that contains `firstName` and `lastName` keys can compute a `fullName`. Pretty neat, right?",
    "title": "Computed fields | Prisma Documentation",
    "description": "This page explains how to use client extensions to add computed fields to Prisma models.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search",
    "markdown": "# Full-text search (Preview) | Prisma Documentation\n\nPrisma Client supports full-text search for **PostgreSQL** databases in versions 2.30.0 and later, and **MySQL** databases in versions 3.8.0 and later. With full-text search enabled, you can add search functionality to your application by searching for text within a database column.\n\n> **Note**: There currently is a [known issue](https://github.com/prisma/prisma/issues/23627) in the full-text search feature. If you observe slow search queries, you can [optimize your query with raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#full-text-search-with-raw-sql).\n\n## Enabling full-text search[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#enabling-full-text-search \"Direct link to Enabling full-text search\")\n\nThe full-text search API is currently a Preview feature. To enable this feature, carry out the following steps:\n\n1.  Update the [`previewFeatures`](https://www.prisma.io/docs/orm/reference/preview-features) block in your schema to include the `fullTextSearch` preview feature flag:\n    \n    schema.prisma\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n    ```\n    \n    For MySQL, you will also need to include the `fullTextIndex` preview feature flag:\n    \n    schema.prisma\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\", \"fullTextIndex\"]}\n    ```\n    \n2.  Generate Prisma Client:\n    \n\nAfter you regenerate your client, a new `search` field will be available on any `String` fields created on your models. For example, the following search will return all posts that contain the word 'cat'.\n\n```\n// All posts that contain the word 'cat'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat',    },  },})\n```\n\n## Querying the database[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#querying-the-database \"Direct link to Querying the database\")\n\nThe `search` field uses the database's native querying capabilities under the hood. This means that the exact query operators available are also database-specific.\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql \"Direct link to PostgreSQL\")\n\nThe following examples demonstrate the use of the PostgreSQL 'and' (`&`) and 'or' (`|`) operators:\n\n```\n// All posts that contain the words 'cat' or 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat | dog',    },  },})// All drafts that contain the words 'cat' and 'dog'.const result = await prisma.posts.findMany({  where: {    status: 'Draft',    body: {      search: 'cat & dog',    },  },})\n```\n\nTo get a sense of how the query format works, consider the following text:\n\n**\"The quick brown fox jumps over the lazy dog\"**\n\nHere's how the following queries would match that text:\n\n| Query | Match? | Description |\n| --- | --- | --- |\n| `fox & dog` | Yes | The text contains 'fox' and 'dog' |\n| `dog & fox` | Yes | The text contains 'dog' and 'fox' |\n| `dog & cat` | No  | The text contains 'dog' but not 'cat' |\n| `!cat` | Yes | 'cat' is not in the text |\n| `fox &#124; cat` | Yes | The text contains 'fox' or 'cat' |\n| `cat &#124; pig` | No  | The text doesn't contain 'cat' or 'pig' |\n| `fox <-> dog` | Yes | 'dog' follows 'fox' in the text |\n| `dog <-> fox` | No  | 'fox' doesn't follow 'dog' in the text |\n\nFor the full range of supported operations, see the [PostgreSQL full text search documentation](https://www.postgresql.org/docs/12/functions-textsearch.html).\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql \"Direct link to MySQL\")\n\nThe following examples demonstrate use of the MySQL 'and' (`+`) and 'not' (`-`) operators:\n\n```\n// All posts that contain the words 'cat' or 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat dog',    },  },})// All posts that contain the words 'cat' and not 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: '+cat -dog',    },  },})// All drafts that contain the words 'cat' and 'dog'.const result = await prisma.posts.findMany({  where: {    status: 'Draft',    body: {      search: '+cat +dog',    },  },})\n```\n\nTo get a sense of how the query format works, consider the following text:\n\n**\"The quick brown fox jumps over the lazy dog\"**\n\nHere's how the following queries would match that text:\n\n| Query | Match? | Description |\n| --- | --- | --- |\n| `+fox +dog` | Yes | The text contains 'fox' and 'dog' |\n| `+dog +fox` | Yes | The text contains 'dog' and 'fox' |\n| `+dog -cat` | Yes | The text contains 'dog' but not 'cat' |\n| `-cat` | No  | The minus operator cannot be used on its own (see note below) |\n| `fox dog` | Yes | The text contains 'fox' or 'dog' |\n| `quic*` | Yes | The text contains a word starting with 'quic' |\n| `quick fox @2` | Yes | 'fox' starts within a 2 word distance of 'quick' |\n| `fox dog @2` | No  | 'dog' does not start within a 2 word distance of 'fox' |\n| `\"jumps over\"` | Yes | The text contains the whole phrase 'jumps over' |\n\n> **Note**: The - operator acts only to exclude rows that are otherwise matched by other search terms. Thus, a boolean-mode search that contains only terms preceded by - returns an empty result. It does not return “all rows except those containing any of the excluded terms.”\n\nMySQL also has `>`, `<` and `~` operators for altering the ranking order of search results. As an example, consider the following two records:\n\n**1\\. \"The quick brown fox jumps over the lazy dog\"**\n\n**2\\. \"The quick brown fox jumps over the lazy cat\"**\n\n| Query | Result | Description |\n| --- | --- | --- |\n| `fox ~cat` | Return 1. first, then 2. | Return all records containing 'fox', but rank records containing 'cat' lower |\n| `fox (<cat >dog)` | Return 1. first, then 2. | Return all records containing 'fox', but rank records containing 'cat' lower than rows containing 'dog' |\n\nFor the full range of supported operations, see the [MySQL full text search documentation](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html).\n\n## Sorting results by `_relevance`[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#sorting-results-by-_relevance \"Direct link to sorting-results-by-_relevance\")\n\nwarning\n\nSorting by relevance is only available for PostgreSQL and MySQL.\n\nIn addition to [Prisma Client's default `orderBy` behavior](https://www.prisma.io/docs/orm/reference/prisma-client-reference#orderby), full-text search also adds sorting by relevance to a given string or strings. As an example, if you wanted to order posts by their relevance to the term `'database'` in their title, you could use the following:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    _relevance: {      fields: ['title'],      search: 'database',      sort: 'asc'    },  },})\n```\n\n## Adding indexes[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#adding-indexes \"Direct link to Adding indexes\")\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql-1 \"Direct link to PostgreSQL\")\n\nPrisma Client does not currently support using indexes to speed up full text search. There is an existing [GitHub Issue](https://github.com/prisma/prisma/issues/8950) for this.\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql-1 \"Direct link to MySQL\")\n\nFor MySQL, it is necessary to add indexes to any columns you search using the `@@fulltext` argument in the `schema.prisma` file. To do this, the `\"fullTextIndex\"` preview feature must be enabled.\n\nIn the following example, one full text index is added to the `content` field of the `Blog` model, and another is added to both the `content` and `title` fields together:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\", \"fullTextIndex\"]}model Blog {  id      Int    @unique  content String  title   String  @@fulltext([content])  @@fulltext([content, title])}\n```\n\nThe first index allows searching the `content` field for occurrences of the word 'cat':\n\n```\nconst result = await prisma.blogs.findMany({  where: {    content: {      search: 'cat',    },  },})\n```\n\nThe second index allows searching both the `content` and `title` fields for occurrences of the word 'cat' in the `content` and 'food' in the `title`:\n\n```\nconst result = await prisma.blogs.findMany({  where: {    content: {      search: 'cat',    },    title: {      search: 'food',    },  },})\n```\n\nHowever, if you try to search on `title` alone, the search will fail with the error \"Cannot find a fulltext index to use for the search\" and the message code is `P2030`, because the index requires a search on both fields.\n\n## Full-text search with raw SQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#full-text-search-with-raw-sql \"Direct link to Full-text search with raw SQL\")\n\nFull-text search is currently in Preview and due to a [known issue](https://github.com/prisma/prisma/issues/23627), you may be seeing slow search queries. If that's the case, you can optimize your query using [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access).\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql-2 \"Direct link to PostgreSQL\")\n\nIn PostgreSQL, you can use `to_tsvector` and `to_tsquery` to express your search query:\n\n```\nconst term = `cat`const result =  await prisma.$queryRaw`SELECT * FROM \"Blog\" WHERE to_tsvector('english', \"Blog\".\"content\") @@ to_tsquery('english', ${term});`\n```\n\n> **Note**: Depending on your language preferences, you may exchange `english` against another language in the SQL statement.\n\nIf you want to include a wildcard in your search term, you can do this as follows:\n\n```\nconst term = `cat:*`const result =  await prisma.$queryRaw`SELECT * FROM \"Blog\" WHERE to_tsvector('english', \"Blog\".\"content\") @@ to_tsquery('english', ${term});`\n```\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql-2 \"Direct link to MySQL\")\n\nIn MySQL, you can express your search query as follows:\n\n```\nconst term = `cat`const result =  await prisma.$queryRaw`SELECT * FROM Blog WHERE MATCH(content) AGAINST(${term} IN NATURAL LANGUAGE MODE);`\n```",
    "title": "Full-text search (Preview) | Prisma Documentation",
    "description": "This page explains how to search for text within a field.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/custom-validation",
    "markdown": "# Custom validation | Prisma Documentation\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'import { z } from 'zod'/** * Zod schema */export const ProductCreateInput = z.object({  slug: z    .string()    .max(100)    .regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/),  name: z.string().max(100),  description: z.string().max(1000),  price: z    .instanceof(Prisma.Decimal)    .refine((price) => price.gte('0.01') && price.lt('1000000.00')),}) satisfies z.Schema<Prisma.ProductUncheckedCreateInput>/** * Prisma Client Extension */const prisma = new PrismaClient().$extends({  query: {    product: {      create({ args, query }) {        args.data = ProductCreateInput.parse(args.data)        return query(args)      },      update({ args, query }) {        args.data = ProductCreateInput.partial().parse(args.data)        return query(args)      },      updateMany({ args, query }) {        args.data = ProductCreateInput.partial().parse(args.data)        return query(args)      },      upsert({ args, query }) {        args.create = ProductCreateInput.parse(args.create)        args.update = ProductCreateInput.partial().parse(args.update)        return query(args)      },    },  },})async function main() {  /**   * Example usage   */  // Valid product  const product = await prisma.product.create({    data: {      slug: 'example-product',      name: 'Example Product',      description: 'Lorem ipsum dolor sit amet',      price: new Prisma.Decimal('10.95'),    },  })  // Invalid product  try {    await prisma.product.create({      data: {        slug: 'invalid-product',        name: 'Invalid Product',        description: 'Lorem ipsum dolor sit amet',        price: new Prisma.Decimal('-1.00'),      },    })  } catch (err: any) {    console.log(err?.cause?.issues)  }}main()\n```",
    "title": "Custom validation | Prisma Documentation",
    "description": "This page explains how to add custom validation to Prisma Client",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/transactions",
    "markdown": "# Transactions and batch queries (Reference)\n\nA database transaction refers to a sequence of read/write operations that are _guaranteed_ to either succeed or fail as a whole. This section describes the ways in which the Prisma Client API supports transactions.\n\n## Transactions overview[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transactions-overview \"Direct link to Transactions overview\")\n\ninfo\n\nBefore Prisma ORM version 4.4.0, you could not set isolation levels on transactions. The isolation level in your database configuration always applied.\n\nDevelopers take advantage of the safety guarantees provided by the database by wrapping the operations in a transaction. These guarantees are often summarized using the ACID acronym:\n\n*   **Atomic**: Ensures that either _all_ or _none_ operations of the transactions succeed. The transaction is either _committed_ successfully or _aborted_ and _rolled back_.\n*   **Consistent**: Ensures that the states of the database before and after the transaction are _valid_ (i.e. any existing invariants about the data are maintained).\n*   **Isolated**: Ensures that concurrently running transactions have the same effect as if they were running in serial.\n*   **Durability**: Ensures that after the transaction succeeded, any writes are being stored persistently.\n\nWhile there's a lot of ambiguity and nuance to each of these properties (for example, consistency could actually be considered an _application-level responsibility_ rather than a database property or isolation is typically guaranteed in terms of stronger and weaker _isolation levels_), overall they serve as a good high-level guideline for expectations developers have when thinking about database transactions.\n\n> \"Transactions are an abstraction layer that allows an application to pretend that certain concurrency problems and certain kinds of hardware and software faults don’t exist. A large class of errors is reduced down to a simple transaction abort, and the application just needs to try again.\" [Designing Data-Intensive Applications](https://dataintensive.net/), [Martin Kleppmann](https://twitter.com/martinkl)\n\nPrisma Client supports six different ways of handling transactions for three different scenarios:\n\nScenario\n\nAvailable techniques\n\nDependent writes\n\n*   Nested writes\n\nIndependent writes\n\n*   `$transaction([])` API\n*   Batch operations\n\nRead, modify, write\n\n*   Idempotent operations\n*   Optimistic concurrency control\n*   Interactive transactions\n\nThe technique you choose depends on your particular use case.\n\n> **Note**: For the purposes of this guide, _writing_ to a database encompasses creating, updating, and deleting data.\n\n## About transactions in Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#about-transactions-in-prisma-client \"Direct link to About transactions in Prisma Client\")\n\nPrisma Client provides the following options for using transactions:\n\n*   [Nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes): use the Prisma Client API to process multiple operations on one or more related records inside the same transaction.\n*   [Batch / bulk transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#batchbulk-operations): process one or more operations in bulk with `updateMany`, `deleteMany`, and `createMany`.\n*   The `$transaction` API in Prisma Client:\n    *   [Sequential operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations): pass an array of Prisma Client queries to be executed sequentially inside a transaction, using `$transaction<R>(queries: PrismaPromise<R>[]): Promise<R[]>`.\n    *   [Interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions): pass a function that can contain user code including Prisma Client queries, non-Prisma code and other control flow to be executed in a transaction, using `$transaction<R>(fn: (prisma: PrismaClient) => R, options?: object): R`\n\n## Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes \"Direct link to Nested writes\")\n\nA [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) lets you perform a single Prisma Client API call with multiple _operations_ that touch multiple [_related_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) records. For example, creating a _user_ together with a _post_ or updating an _order_ together with an _invoice_. Prisma Client ensures that all operations succeed or fail as a whole.\n\nThe following example demonstrates a nested write with `create`:\n\n```\n// Create a new user with two posts in a// single transactionconst newUser: User = await prisma.user.create({  data: {    email: 'alice@prisma.io',    posts: {      create: [        { title: 'Join the Prisma Discord at https://pris.ly/discord' },        { title: 'Follow @prisma on Twitter' },      ],    },  },})\n```\n\nThe following example demonstrates a nested write with `update`:\n\n```\n// Change the author of a post in a single transactionconst updatedPost: Post = await prisma.post.update({  where: { id: 42 },  data: {    author: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n## Batch/bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#batchbulk-operations \"Direct link to Batch/bulk operations\")\n\nThe following bulk operations run as transactions:\n\n*   `deleteMany()`\n*   `updateMany()`\n*   `createMany()`\n*   `createManyAndReturn()`\n\n> Refer to the section about [bulk operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#bulk-operations) for more examples.\n\n## The `$transaction` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api \"Direct link to the-transaction-api\")\n\nThe `$transaction` API can be used in two ways:\n\n*   [Sequential operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations): Pass an array of Prisma Client queries to be executed sequentially inside of a transaction.\n    \n    `$transaction<R>(queries: PrismaPromise<R>[]): Promise<R[]>`\n    \n*   [Interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions): Pass a function that can contain user code including Prisma Client queries, non-Prisma code and other control flow to be executed in a transaction.\n    \n    `$transaction<R>(fn: (prisma: PrismaClient) => R): R`\n    \n\n### Sequential Prisma Client operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations \"Direct link to Sequential Prisma Client operations\")\n\nThe following query returns all posts that match the provided filter as well as a count of all posts:\n\n```\nconst [posts, totalPosts] = await prisma.$transaction([  prisma.post.findMany({ where: { title: { contains: 'prisma' } } }),  prisma.post.count(),])\n```\n\nYou can also use raw queries inside of a `$transaction`:\n\n*   Relational databases\n*   MongoDB\n\n```\nconst [userList, updateUser] = await prisma.$transaction([  prisma.$queryRaw`SELECT 'title' FROM User`,  prisma.$executeRaw`UPDATE User SET name = 'Hello' WHERE id = 2;`,])\n```\n\nInstead of immediately awaiting the result of each operation when it's performed, the operation itself is stored in a variable first which later is submitted to the database with a method called `$transaction`. Prisma Client will ensure that either all three `create` operations succeed or none of them succeed.\n\n> **Note**: Operations are executed according to the order they are placed in the transaction. Using a query in a transaction does not influence the order of operations in the query itself.\n> \n> Refer to the section about the [transactions API](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api) for more examples.\n\nFrom version 4.4.0, the sequential operations transaction API has a second parameter. You can use the following optional configuration option in this parameter:\n\n*   `isolationLevel`: Sets the [transaction isolation level](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level). By default this is set to the value currently configured in your database.\n\nFor example:\n\n```\nawait prisma.$transaction(  [    prisma.resource.deleteMany({ where: { name: 'name' } }),    prisma.resource.createMany({ data }),  ],  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\n### Interactive transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions \"Direct link to Interactive transactions\")\n\n#### Overview[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#overview \"Direct link to Overview\")\n\nSometimes you need more control over what queries execute within a transaction. Interactive transactions are meant to provide you with an escape hatch.\n\ninfo\n\nInteractive transactions have been generally available from version 4.7.0.\n\nIf you use interactive transactions in preview from version 2.29.0 to 4.6.1 (included), you need to add the `interactiveTransactions` preview feature to the generator block of your Prisma schema.\n\nTo use interactive transactions, you can pass an async function into [`$transaction`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api).\n\nThe first argument passed into this async function is an instance of Prisma Client. Below, we will call this instance `tx`. Any Prisma Client call invoked on this `tx` instance is encapsulated into the transaction.\n\nwarning\n\n**Use interactive transactions with caution**. Keeping transactions open for a long time hurts database performance and can even cause deadlocks. Try to avoid performing network requests and executing slow queries inside your transaction functions. We recommend you get in and out as quick as possible!\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#example \"Direct link to Example\")\n\nLet's look at an example:\n\nImagine that you are building an online banking system. One of the actions to perform is to send money from one person to another.\n\nAs experienced developers, we want to make sure that during the transfer,\n\n*   the amount doesn't disappear\n*   the amount isn't doubled\n\nThis is a great use-case for interactive transactions because we need to perform logic in-between the writes to check the balance.\n\nIn the example below, Alice and Bob each have $100 in their account. If they try to send more money than they have, the transfer is rejected.\n\nAlice is expected to be able to make 1 transfer for $100 while the other transfer would be rejected. This would result in Alice having $0 and Bob having $200.\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()function transfer(from: string, to: string, amount: number) {  return prisma.$transaction(async (tx) => {    // 1. Decrement amount from the sender.    const sender = await tx.account.update({      data: {        balance: {          decrement: amount,        },      },      where: {        email: from,      },    })    // 2. Verify that the sender's balance didn't go below zero.    if (sender.balance < 0) {      throw new Error(`${from} doesn't have enough to send ${amount}`)    }    // 3. Increment the recipient's balance by amount    const recipient = await tx.account.update({      data: {        balance: {          increment: amount,        },      },      where: {        email: to,      },    })    return recipient  })}async function main() {  // This transfer is successful  await transfer('alice@prisma.io', 'bob@prisma.io', 100)  // This transfer fails because Alice doesn't have enough funds in her account  await transfer('alice@prisma.io', 'bob@prisma.io', 100)}main()\n```\n\nIn the example above, both `update` queries run within a database transaction. When the application reaches the end of the function, the transaction is **committed** to the database.\n\nIf your application encounters an error along the way, the async function will throw an exception and automatically **rollback** the transaction.\n\nTo catch the exception, you can wrap `$transaction` in a try-catch block:\n\n```\ntry {  await prisma.$transaction(async (tx) => {    // Code running in a transaction...  })} catch (err) {  // Handle the rollback...}\n```\n\n#### Transaction options[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-options \"Direct link to Transaction options\")\n\nThe transaction API has a second parameter. For interactive transactions, you can use the following optional configuration options in this parameter:\n\n*   `maxWait`: The maximum amount of time Prisma Client will wait to acquire a transaction from the database. The default value is 2 seconds.\n*   `timeout`: The maximum amount of time the interactive transaction can run before being canceled and rolled back. The default value is 5 seconds.\n*   `isolationLevel`: Sets the [transaction isolation level](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level). By default this is set to the value currently configured in your database.\n\nFor example:\n\n```\nawait prisma.$transaction(  async (tx) => {    // Code running in a transaction...  },  {    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\nYou can also set these globally on the constructor-level:\n\n```\nconst prisma = new PrismaClient({  transactionOptions: {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000  },})\n```\n\n### Transaction isolation level[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level \"Direct link to Transaction isolation level\")\n\ninfo\n\nThis feature is not available on MongoDB, because MongoDB does not support isolation levels.\n\nYou can set the transaction [isolation level](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels) for transactions.\n\ninfo\n\nThis is available in the following Prisma ORM versions for interactive transactions from version 4.2.0, for sequential operations from version 4.4.0.\n\nIn versions before 4.2.0 (for interactive transactions), or 4.4.0 (for sequential operations), you cannot configure the transaction isolation level at a Prisma ORM level. Prisma ORM does not explicitly set the isolation level, so the [isolation level configured in your database](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#database-specific-information-on-isolation-levels) is used.\n\n#### Set the isolation level[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#set-the-isolation-level \"Direct link to Set the isolation level\")\n\nTo set the transaction isolation level, use the `isolationLevel` option in the second parameter of the API.\n\nFor sequential operations:\n\n```\nawait prisma.$transaction(  [    // Prisma Client operations running in a transaction...  ],  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\nFor an interactive transaction:\n\n```\nawait prisma.$transaction(  async (prisma) => {    // Code running in a transaction...  },  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000  })\n```\n\n#### Supported isolation levels[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#supported-isolation-levels \"Direct link to Supported isolation levels\")\n\nPrisma Client supports the following isolation levels if they are available in the underlying database:\n\n*   `ReadUncommitted`\n*   `ReadCommitted`\n*   `RepeatableRead`\n*   `Snapshot`\n*   `Serializable`\n\nThe isolation levels available for each database connector are as follows:\n\nDatabase\n\n`ReadUncommitted`\n\n`ReadCommitted`\n\n`RepeatableRead`\n\n`Snapshot`\n\n`Serializable`\n\nPostgreSQL\n\n✔️\n\n✔️\n\n✔️\n\nNo\n\n✔️\n\nMySQL\n\n✔️\n\n✔️\n\n✔️\n\nNo\n\n✔️\n\nSQL Server\n\n✔️\n\n✔️\n\n✔️\n\n✔️\n\n✔️\n\nCockroachDB\n\nNo\n\nNo\n\nNo\n\nNo\n\n✔️\n\nSQLite\n\nNo\n\nNo\n\nNo\n\nNo\n\n✔️\n\nBy default, Prisma Client sets the isolation level to the value currently configured in your database.\n\nThe isolation levels configured by default in each database are as follows:\n\nDatabase\n\nDefault\n\nPostgreSQL\n\n`ReadCommitted`\n\nMySQL\n\n`RepeatableRead`\n\nSQL Server\n\n`ReadCommitted`\n\nCockroachDB\n\n`Serializable`\n\nSQLite\n\n`Serializable`\n\n#### Database-specific information on isolation levels[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#database-specific-information-on-isolation-levels \"Direct link to Database-specific information on isolation levels\")\n\nSee the following resources:\n\n*   [Transaction isolation levels in PostgreSQL](https://www.postgresql.org/docs/9.3/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION)\n*   [Transaction isolation levels in Microsoft SQL Server](https://docs.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver15)\n*   [Transaction isolation levels in MySQL](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)\n\nCockroachDB and SQLite only support the `Serializable` isolation level.\n\n### Transaction timing issues[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-timing-issues \"Direct link to Transaction timing issues\")\n\ninfo\n\n*   The solution in this section does not apply to MongoDB, because MongoDB does not support [isolation levels](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels).\n*   The timing issues discussed in this section do not apply to CockroachDB and SQLite, because these databases only support the highest `Serializable` isolation level.\n\nWhen two or more transactions run concurrently in certain [isolation levels](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels), timing issues can cause write conflicts or deadlocks, such as the violation of unique constraints. For example, consider the following sequence of events where Transaction A and Transaction B both attempt to execute a `deleteMany` and a `createMany` operation:\n\n1.  Transaction B: `createMany` operation creates a new set of rows.\n2.  Transaction B: The application commits transaction B.\n3.  Transaction A: `createMany` operation.\n4.  Transaction A: The application commits transaction A. The new rows conflict with the rows that transaction B added at step 2.\n\nThis conflict can occur at the isolation level `ReadCommited`, which is the default isolation level in PostgreSQL and Microsoft SQL Server. To avoid this problem, you can set a higher isolation level (`RepeatableRead` or `Serializable`). You can set the isolation level on a transaction. This overrides your database isolation level for that transaction.\n\nTo avoid transaction write conflicts and deadlocks on a transaction:\n\n1.  On your transaction, use the `isolationLevel` parameter to `Prisma.TransactionIsolationLevel.Serializable`.\n    \n    This ensures that your application commits multiple concurrent or parallel transactions as if they were run serially. When a transaction fails due to a write conflict or deadlock, Prisma Client returns a [P2034 error](https://www.prisma.io/docs/orm/reference/error-reference#p2034).\n    \n2.  In your application code, add a retry around your transaction to handle any P2034 errors, as shown in this example:\n    \n    ```\n    import { Prisma, PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const MAX_RETRIES = 5  let retries = 0  let result  while (retries < MAX_RETRIES) {    try {      result = await prisma.$transaction(        [          prisma.user.deleteMany({            where: {              /** args */            },          }),          prisma.post.createMany({            data: {              /** args */            },          }),        ],        {          isolationLevel: Prisma.TransactionIsolationLevel.Serializable,        }      )      break    } catch (error) {      if (error.code === 'P2034') {        retries++        continue      }      throw error    }  }}\n    ```\n    \n\n## Dependent writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#dependent-writes \"Direct link to Dependent writes\")\n\nWrites are considered **dependent** on each other if:\n\n*   Operations depend on the result of a preceding operation (for example, the database generating an ID)\n\nThe most common scenario is creating a record and using the generated ID to create or update a related record. Examples include:\n\n*   Creating a user and two related blog posts (a one-to-many relationship) - the author ID must be known before creating blog posts\n*   Creating a team and assigning members (a many-to-many relationship) - the team ID must be known before assigning members\n\nDependent writes must succeed together in order to maintain data consistency and prevent unexpected behavior, such as blog post without an author or a team without members.\n\n### Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-1 \"Direct link to Nested writes\")\n\nPrisma Client's solution to dependent writes is the **nested writes** feature, which is supported by `create` and `update`. The following nested write creates one user and two blog posts:\n\n```\nconst nestedWrite = await prisma.user.create({  data: {    email: 'imani@prisma.io',    posts: {      create: [        { title: 'My first day at Prisma' },        { title: 'How to configure a unique constraint in PostgreSQL' },      ],    },  },})\n```\n\nIf any operation fails, Prisma Client rolls back the entire transaction. Nested writes are not currently supported by top-level bulk operations like `client.user.deleteMany` and `client.user.updateMany`.\n\n#### When to use nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-nested-writes \"Direct link to When to use nested writes\")\n\nConsider using nested writes if:\n\n*   ✔ You want to create two or more records related by ID at the same time (for example, create a blog post and a user)\n*   ✔ You want to update and create records related by ID at the same time (for example, change a user's name and create a new blog post)\n\n#### Scenario: Sign-up flow[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-sign-up-flow \"Direct link to Scenario: Sign-up flow\")\n\nConsider the Slack sign-up flow, which:\n\n1.  Creates a team\n2.  Adds one user to that team, which automatically becomes that team's administrator\n\nThis scenario can be represented by the following schema - note that users can belong to many teams, and teams can have many users (a many-to-many relationship):\n\n```\nmodel Team {  id      Int    @id @default(autoincrement())  name    String  members User[] // Many team members}model User {  id    Int    @id @default(autoincrement())  email String @unique  teams Team[] // Many teams}\n```\n\nThe most straightforward approach is to create a team, then create and attach a user to that team:\n\n```\n// Create a teamconst team = await prisma.team.create({  data: {    name: 'Aurora Adventures',  },})// Create a user and assign them to the teamconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    team: {      connect: {        id: team.id,      },    },  },})\n```\n\nHowever, this code has a problem - consider the following scenario:\n\n1.  Creating the team succeeds - \"Aurora Adventures\" is now taken\n2.  Creating and connecting the user fails - the team \"Aurora Adventures\" exists, but has no users\n3.  Going through the sign-up flow again and attempting to recreate \"Aurora Adventures\" fails - the team already exists\n\nCreating a team and adding a user should be one atomic operation that **succeeds or fails as a whole**.\n\nTo implement atomic writes in a low-level database clients, you must wrap your inserts in `BEGIN`, `COMMIT` and `ROLLBACK` statements. Prisma Client solves the problem with [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes). The following query creates a team, creates a user, and connects the records in a single transaction:\n\n```\nconst team = await prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})\n```\n\nFurthermore, if an error occurs at any point, Prisma Client rolls back the entire transaction.\n\n#### Nested writes FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-faqs \"Direct link to Nested writes FAQs\")\n\n##### Why can't I use the `$transaction([])` API to solve the same problem?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#why-cant-i-use-the-transaction-api-to-solve-the-same-problem \"Direct link to why-cant-i-use-the-transaction-api-to-solve-the-same-problem\")\n\nThe `$transaction([])` API does not allow you to pass IDs between distinct operations. In the following example, `createUserOperation.id` is not available yet:\n\n```\nconst createUserOperation = prisma.user.create({  data: {    email: 'ebony@prisma.io',  },})const createTeamOperation = prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      connect: {        id: createUserOperation.id, // Not possible, ID not yet available      },    },  },})await prisma.$transaction([createUserOperation, createTeamOperation])\n```\n\n##### Nested writes support nested updates, but updates are not dependent writes - should I use the `$transaction([])` API?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-support-nested-updates-but-updates-are-not-dependent-writes---should-i-use-the-transaction-api \"Direct link to nested-writes-support-nested-updates-but-updates-are-not-dependent-writes---should-i-use-the-transaction-api\")\n\nIt is correct to say that because you know the ID of the team, you can update the team and its team members independently within a `$transaction([])`. The following example performs both operations in a `$transaction([])`:\n\n```\nconst updateTeam = prisma.team.update({  where: {    id: 1,  },  data: {    name: 'Aurora Adventures Ltd',  },})const updateUsers = prisma.user.updateMany({  where: {    teams: {      some: {        id: 1,      },    },    name: {      equals: null,    },  },  data: {    name: 'Unknown User',  },})await prisma.$transaction([updateUsers, updateTeam])\n```\n\nHowever, you can achieve the same result with a nested write:\n\n```\nconst updateTeam = await prisma.team.update({  where: {    id: 1,  },  data: {    name: 'Aurora Adventures Ltd', // Update team name    members: {      updateMany: {        // Update team members that do not have a name        data: {          name: 'Unknown User',        },        where: {          name: {            equals: null,          },        },      },    },  },})\n```\n\n##### Can I perform multiple nested writes - for example, create two new teams and assign users?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-perform-multiple-nested-writes---for-example-create-two-new-teams-and-assign-users \"Direct link to Can I perform multiple nested writes - for example, create two new teams and assign users?\")\n\nYes, but this is a combination of scenarios and techniques:\n\n*   Creating a team and assigning users is a dependent write - use nested writes\n*   Creating all teams and users at the same time is an independent write because team/user combination #1 and team/user combination #2 are unrelated writes - use the `$transaction([])` API\n\n```\n// Nested writeconst createOne = prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})// Nested writeconst createTwo = prisma.team.create({  data: {    name: 'Cool Crew',    members: {      create: {        email: 'elsa@prisma.io',      },    },  },})// $transaction([]) APIawait prisma.$transaction([createTwo, createOne])\n```\n\n## Independent writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#independent-writes \"Direct link to Independent writes\")\n\nWrites are considered **independent** if they do not rely on the result of a previous operation. The following groups of independent writes can occur in any order:\n\n*   Updating the status field of a list of orders to \"Dispatched\"\n*   Marking a list of emails as \"Read\"\n\n> **Note**: Independent writes may have to occur in a specific order if constraints are present - for example, you must delete blog posts before the blog author if the post have a mandatory `authorId` field. However, they are still considered independent writes because no operations depend on the _result_ of a previous operation, such as the database returning a generated ID.\n\nDepending on your requirements, Prisma Client has four options for handling independent writes that should succeed or fail together.\n\n### Bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#bulk-operations \"Direct link to Bulk operations\")\n\nBulk writes allow you to write multiple records of the same type in a single transaction - if any operation fails, Prisma Client rolls back the entire transaction. Prisma Client currently supports:\n\n*   `updateMany()`\n*   `deleteMany()`\n*   `createMany()`\n*   `createManyAndReturn()`\n\n#### When to use bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-bulk-operations \"Direct link to When to use bulk operations\")\n\nConsider bulk operations as a solution if:\n\n*   ✔ You want to update a batch of the _same type_ of record, like a batch of emails\n\n#### Scenario: Marking emails as read[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-marking-emails-as-read \"Direct link to Scenario: Marking emails as read\")\n\nYou are building a service like gmail.com, and your customer wants a **\"Mark as read\"** feature that allows users to mark all emails as read. Each update to the status of an email is an independent write because the emails do not depend on one another - for example, the \"Happy Birthday! 🍰\" email from your aunt is unrelated to the promotional email from IKEA.\n\nIn the following schema, a `User` can have many received emails (a one-to-many relationship):\n\n```\nmodel User {  id    Int       @id @default(autoincrement())  email           String @unique  receivedEmails  Email[] // Many emails}model Email {  id      Int     @id @default(autoincrement())  user    User    @relation(fields: [userId], references: [id])  userId  Int  subject String  body    String  unread  Boolean}\n```\n\nBased on this schema, you can use `updateMany` to mark all unread emails as read:\n\n```\nawait prisma.email.updateMany({  where: {    user: {      id: 10,    },    unread: true,  },  data: {    unread: false,  },})\n```\n\n#### Can I use nested writes with bulk operations?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-use-nested-writes-with-bulk-operations \"Direct link to Can I use nested writes with bulk operations?\")\n\nNo - neither `updateMany` nor `deleteMany` currently supports nested writes. For example, you cannot delete multiple teams and all of their members (a cascading delete):\n\n```\nawait prisma.team.deleteMany({  where: {    id: {      in: [2, 99, 2, 11],    },  },  data: {    members: {}, // Cannot access members here  },})\n```\n\n#### Can I use bulk operations with the `$transaction([])` API?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-use-bulk-operations-with-the-transaction-api \"Direct link to can-i-use-bulk-operations-with-the-transaction-api\")\n\nYes — for example, you can include multiple `deleteMany` operations inside a `$transaction([])`.\n\n### `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api \"Direct link to transaction-api\")\n\nThe `$transaction([])` API is generic solution to independent writes that allows you to run multiple operations as a single, atomic operation - if any operation fails, Prisma Client rolls back the entire transaction.\n\nIts also worth noting that operations are executed according to the order they are placed in the transaction.\n\n```\nawait prisma.$transaction([iRunFirst, iRunSecond, iRunThird])\n```\n\n> **Note**: Using a query in a transaction does not influence the order of operations in the query itself.\n\nAs Prisma Client evolves, use cases for the `$transaction([])` API will increasingly be replaced by more specialized bulk operations (such as `createMany`) and nested writes.\n\n#### When to use the `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-the-transaction-api \"Direct link to when-to-use-the-transaction-api\")\n\nConsider the `$transaction([])` API if:\n\n*   ✔ You want to update a batch that includes different types of records, such as emails and users. The records do not need to be related in any way.\n*   ✔ You want to batch raw SQL queries (`$executeRaw`) - for example, for features that Prisma Client does not yet support.\n\n#### Scenario: Privacy legislation[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-privacy-legislation \"Direct link to Scenario: Privacy legislation\")\n\nGDPR and other privacy legislation give users the right to request that an organization deletes all of their personal data. In the following example schema, a `User` can have many posts and private messages:\n\n```\nmodel User {  id              Int              @id @default(autoincrement())  posts           Post[]  privateMessages PrivateMessage[]}model Post {  id      Int    @id @default(autoincrement())  user    User   @relation(fields: [userId], references: [id])  userId  Int  title   String  content String}model PrivateMessage {  id      Int    @id @default(autoincrement())  user    User   @relation(fields: [userId], references: [id])  userId  Int  message String}\n```\n\nIf a user invokes the right to be forgotten, we must delete three records: the user record, private messages, and posts. It is critical that _all_ delete operations succeed together or not at all, which makes this a use case for a transaction. However, using a single bulk operation like `deleteMany` is not possible in this scenario because we need to delete across three models. Instead, we can use the `$transaction([])` API to run three operations together - two `deleteMany` and one `delete`:\n\n```\nconst id = 9 // User to be deletedconst deletePosts = prisma.post.deleteMany({  where: {    userId: id,  },})const deleteMessages = prisma.privateMessage.deleteMany({  where: {    userId: id,  },})const deleteUser = prisma.user.delete({  where: {    id: id,  },})await prisma.$transaction([deletePosts, deleteMessages, deleteUser]) // Operations succeed or fail together\n```\n\n#### Scenario: Pre-computed IDs and the `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-pre-computed-ids-and-the-transaction-api \"Direct link to scenario-pre-computed-ids-and-the-transaction-api\")\n\nDependent writes are not supported by the `$transaction([])` API - if operation A relies on the ID generated by operation B, use [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes). However, if you _pre-computed_ IDs (for example, by generating GUIDs), your writes become independent. Consider the sign-up flow from the nested writes example:\n\n```\nawait prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})\n```\n\nInstead of auto-generating IDs, change the `id` fields of `Team` and `User` to a `String` (if you do not provide a value, a UUID is generated automatically). This example uses UUIDs:\n\n```\nmodel Team {  id      Int    @id @default(autoincrement())  id      String @id @default(uuid())  name    String  members User[]}model User {  id    Int    @id @default(autoincrement())  id    String @id @default(uuid())  email String @unique  teams Team[]}\n```\n\nRefactor the sign-up flow example to use the `$transaction([])` API instead of nested writes:\n\n```\nimport { v4 } from 'uuid'const teamID = v4()const userID = v4()await prisma.$transaction([  prisma.user.create({    data: {      id: userID,      email: 'alice@prisma.io',      team: {        id: teamID,      },    },  }),  prisma.team.create({    data: {      id: teamID,      name: 'Aurora Adventures',    },  }),])\n```\n\nTechnically you can still use nested writes with pre-computed APIs if you prefer that syntax:\n\n```\nimport { v4 } from 'uuid'const teamID = v4()const userID = v4()await prisma.team.create({  data: {    id: teamID,    name: 'Aurora Adventures',    members: {      create: {        id: userID,        email: 'alice@prisma.io',        team: {          id: teamID,        },      },    },  },})\n```\n\nThere's no compelling reason to switch to manually generated IDs and the `$transaction([])` API if you are already using auto-generated IDs and nested writes.\n\n## Read, modify, write[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#read-modify-write \"Direct link to Read, modify, write\")\n\nIn some cases you may need to perform custom logic as part of an atomic operation - also known as the [read-modify-write pattern](https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write). The following is an example of the read-modify-write pattern:\n\n*   Read a value from the database\n*   Run some logic to manipulate that value (for example, contacting an external API)\n*   Write the value back to the database\n\nAll operations should **succeed or fail together** without making unwanted changes to the database, but you do not necessarily need to use an actual database transaction. This section of the guide describes two ways to work with Prisma Client and the read-modify-write pattern:\n\n*   Designing idempotent APIs\n*   Optimistic concurrency control\n\n### Idempotent APIs[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#idempotent-apis \"Direct link to Idempotent APIs\")\n\nIdempotency is the ability to run the same logic with the same parameters multiple times with the same result: the **effect on the database** is the same whether you run the logic once or one thousand times. For example:\n\n*   **NOT IDEMPOTENT**: Upsert (update-or-insert) a user in the database with email address `\"letoya@prisma.io\"`. The `User` table **does not** enforce unique email addresses. The effect on the database is different if you run the logic once (one user created) or ten times (ten users created).\n*   **IDEMPOTENT**: Upsert (update-or-insert) a user in the database with the email address `\"letoya@prisma.io\"`. The `User` table **does** enforce unique email addresses. The effect on the database is the same if you run the logic once (one user created) or ten times (existing user is updated with the same input).\n\nIdempotency is something you can and should actively design into your application wherever possible.\n\n#### When to design an idempotent API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-design-an-idempotent-api \"Direct link to When to design an idempotent API\")\n\n*   ✔ You need to be able to retry the same logic without creating unwanted side-effects in the databases\n\n#### Scenario: Upgrading a Slack team[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-upgrading-a-slack-team \"Direct link to Scenario: Upgrading a Slack team\")\n\nYou are creating an upgrade flow for Slack that allows teams to unlock paid features. Teams can choose between different plans and pay per user, per month. You use Stripe as your payment gateway, and extend your `Team` model to store a `stripeCustomerId`. Subscriptions are managed in Stripe.\n\n```\nmodel Team {  id               Int     @id @default(autoincrement())  name             String  User             User[]  stripeCustomerId String?}\n```\n\nThe upgrade flow looks like this:\n\n1.  Count the number of users\n2.  Create a subscription in Stripe that includes the number of users\n3.  Associate the team with the Stripe customer ID to unlock paid features\n\n```\nconst teamId = 9const planId = 'plan_id'// Count team membersconst numTeammates = await prisma.user.count({  where: {    teams: {      some: {        id: teamId,      },    },  },})// Create a customer in Stripe for plan-9454549const customer = await stripe.customers.create({  externalId: teamId,  plan: planId,  quantity: numTeammates,})// Update the team with the customer id to indicate that they are a customer// and support querying this customer in Stripe from our application code.await prisma.team.update({  data: {    customerId: customer.id,  },  where: {    id: teamId,  },})\n```\n\nThis example has a problem: you can only run the logic _once_. Consider the following scenario:\n\n1.  Stripe creates a new customer and subscription, and returns a customer ID\n    \n2.  Updating the team **fails** - the team is not marked as a customer in the Slack database\n    \n3.  The customer is charged by Stripe, but paid features are not unlocked in Slack because the team lacks a valid `customerId`\n    \n4.  Running the same code again either:\n    \n    *   Results in an error because the team (defined by `externalId`) already exists - Stripe never returns a customer ID\n    *   If `externalId` is not subject to a unique constraint, Stripe creates yet another subscription (**not idempotent**)\n\nYou cannot re-run this code in case of an error and you cannot change to another plan without being charged twice.\n\nThe following refactor (highlighted) introduces a mechanism that checks if a subscription already exists, and either creates the description or updates the existing subscription (which will remain unchanged if the input is identical):\n\n```\n// Calculate the number of users times the cost per userconst numTeammates = await prisma.user.count({  where: {    teams: {      some: {        id: teamId,      },    },  },})// Find customer in Stripelet customer = await stripe.customers.get({ externalId: teamID })if (customer) {  // If team already exists, update  customer = await stripe.customers.update({    externalId: teamId,    plan: 'plan_id',    quantity: numTeammates,  })} else {  customer = await stripe.customers.create({    // If team does not exist, create customer    externalId: teamId,    plan: 'plan_id',    quantity: numTeammates,  })}// Update the team with the customer id to indicate that they are a customer// and support querying this customer in Stripe from our application code.await prisma.team.update({  data: {    customerId: customer.id,  },  where: {    id: teamId,  },})\n```\n\nYou can now retry the same logic multiple times with the same input without adverse effect. To further enhance this example, you can introduce a mechanism whereby the subscription is cancelled or temporarily deactivated if the update does not succeed after a set number of attempts.\n\n### Optimistic concurrency control[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#optimistic-concurrency-control \"Direct link to Optimistic concurrency control\")\n\nOptimistic concurrency control (OCC) is a model for handling concurrent operations on a single entity that does not rely on 🔒 locking. Instead, we **optimistically** assume that a record will remain unchanged in between reading and writing, and use a concurrency token (a timestamp or version field) to detect changes to a record.\n\nIf a ❌ conflict occurs (someone else has changed the record since you read it), you cancel the transaction. Depending on your scenario, you can then:\n\n*   Re-try the transaction (book another cinema seat)\n*   Throw an error (alert the user that they are about to overwrite changes made by someone else)\n\nThis section describes how to build your own optimistic concurrency control. See also: Plans for [application-level optimistic concurrency control on GitHub](https://github.com/prisma/prisma/issues/4988)\n\ninfo\n\n*   If you use version 4.4.0 or earlier, you cannot use optimistic concurrency control on `update` operations, because you cannot filter on non-unique fields. The `version` field you need to use with optimistic concurrency control is a non-unique field.\n    \n*   Since version 5.0.0 you are able to [filter on non-unique fields in `update` operations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput) so that optimistic concurrency control is being used. The feature was also available via the Preview flag `extendedWhereUnique` from versions 4.5.0 to 4.16.2.\n    \n\n#### When to use optimistic concurrency control[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-optimistic-concurrency-control \"Direct link to When to use optimistic concurrency control\")\n\n*   ✔ You anticipate a high number of concurrent requests (multiple people booking cinema seats)\n*   ✔ You anticipate that conflicts between those concurrent requests will be rare\n\nAvoiding locks in a application with a high number of concurrent requests makes the application more resilient to load and more scalable overall. Although locking is not inherently bad, locking in a high concurrency environment can lead to unintended consequences - even if you are locking individual rows, and only for a short amount of time. For more information, see:\n\n*   [Why ROWLOCK Hints Can Make Queries Slower and Blocking Worse in SQL Server](https://littlekendra.com/2016/02/04/why-rowlock-hints-can-make-queries-slower-and-blocking-worse-in-sql-server/)\n*   [The High Concurrency strategy](https://www.ibm.com/developerworks/library/j-ts5/index.html)\n\n#### Scenario: Reserving a seat at the cinema[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-reserving-a-seat-at-the-cinema \"Direct link to Scenario: Reserving a seat at the cinema\")\n\nYou are creating a booking system for a cinema. Each movie has a set number of seats. The following schema models movies and seats:\n\n```\nmodel Seat {  id        Int   @id @default(autoincrement())  userId    Int?  claimedBy User? @relation(fields: [userId], references: [id])  movieId   Int  movie     Movie @relation(fields: [movieId], references: [id])}model Movie {  id    Int    @id     @default(autoincrement())  name  String @unique  seats Seat[]}\n```\n\nThe following sample code finds the first available seat and assigns that seat to a user:\n\n```\nconst movieName = 'Hidden Figures'// Find first available seatconst availableSeat = await prisma.seat.findFirst({  where: {    movie: {      name: movieName,    },    claimedBy: null,  },})// Throw an error if no seats are availableif (!availableSeat) {  throw new Error(`Oh no! ${movieName} is all booked.`)}// Claim the seatawait prisma.seat.update({  data: {    claimedBy: userId,  },  where: {    id: availableSeat.id,  },})\n```\n\nHowever, this code suffers from the \"double-booking problem\" - it is possible for two people to book the same seats:\n\n1.  Seat 3A returned to Sorcha (`findFirst`)\n2.  Seat 3A returned to Ellen (`findFirst`)\n3.  Seat 3A claimed by Sorcha (`update`)\n4.  Seat 3A claimed by Ellen (`update` - overwrites Sorcha's claim)\n\nEven though Sorcha has successfully booked the seat, the system ultimately stores Ellen's claim. To solve this problem with optimistic concurrency control, add a `version` field to the seat:\n\n```\nmodel Seat {  id        Int   @id @default(autoincrement())  userId    Int?  claimedBy User? @relation(fields: [userId], references: [id])  movieId   Int  movie     Movie @relation(fields: [movieId], references: [id])  version   Int}\n```\n\nNext, adjust the code to check the `version` field before updating:\n\n```\nconst userEmail = 'alice@prisma.io'const movieName = 'Hidden Figures'// Find the first available seat// availableSeat.version might be 0const availableSeat = await client.seat.findFirst({  where: {    Movie: {      name: movieName,    },    claimedBy: null,  },})if (!availableSeat) {  throw new Error(`Oh no! ${movieName} is all booked.`)}// Only mark the seat as claimed if the availableSeat.version// matches the version we're updating. Additionally, increment the// version when we perform this update so all other clients trying// to book this same seat will have an outdated version.const seats = await client.seat.updateMany({  data: {    claimedBy: userEmail,    version: {      increment: 1,    },  },  where: {    id: availableSeat.id,    version: availableSeat.version, // This version field is the key; only claim seat if in-memory version matches database version, indicating that the field has not been updated  },})if (seats.count === 0) {  throw new Error(`That seat is already booked! Please try again.`)}\n```\n\nIt is now impossible for two people to book the same seat:\n\n1.  Seat 3A returned to Sorcha (`version` is 0)\n2.  Seat 3A returned to Ellen (`version` is 0)\n3.  Seat 3A claimed by Sorcha (`version` is incremented to 1, booking succeeds)\n4.  Seat 3A claimed by Ellen (in-memory `version` (0) does not match database `version` (1) - booking does not succeed)\n\n### Interactive transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions-1 \"Direct link to Interactive transactions\")\n\nIf you have an existing application, it can be a significant undertaking to refactor your application to use optimistic concurrency control. Interactive Transactions offers a useful escape hatch for cases like this.\n\nTo create an interactive transaction, pass an async function into [$transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api).\n\nThe first argument passed into this async function is an instance of Prisma Client. Below, we will call this instance `tx`. Any Prisma Client call invoked on this `tx` instance is encapsulated into the transaction.\n\nIn the example below, Alice and Bob each have $100 in their account. If they try to send more money than they have, the transfer is rejected.\n\nThe expected outcome would be for Alice to make 1 transfer for $100 and the other transfer would be rejected. This would result in Alice having $0 and Bob having $200.\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function transfer(from: string, to: string, amount: number) {  return await prisma.$transaction(async (tx) => {    // 1. Decrement amount from the sender.    const sender = await tx.account.update({      data: {        balance: {          decrement: amount,        },      },      where: {        email: from,      },    })    // 2. Verify that the sender's balance didn't go below zero.    if (sender.balance < 0) {      throw new Error(`${from} doesn't have enough to send ${amount}`)    }    // 3. Increment the recipient's balance by amount    const recipient = tx.account.update({      data: {        balance: {          increment: amount,        },      },      where: {        email: to,      },    })    return recipient  })}async function main() {  // This transfer is successful  await transfer('alice@prisma.io', 'bob@prisma.io', 100)  // This transfer fails because Alice doesn't have enough funds in her account  await transfer('alice@prisma.io', 'bob@prisma.io', 100)}main()\n```\n\nIn the example above, both `update` queries run within a database transaction. When the application reaches the end of the function, the transaction is **committed** to the database.\n\nIf the application encounters an error along the way, the async function will throw an exception and automatically **rollback** the transaction.\n\nYou can learn more about interactive transactions in this [section](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions).\n\nwarning\n\n**Use interactive transactions with caution**. Keeping transactions open for a long time hurts database performance and can even cause deadlocks. Try to avoid performing network requests and executing slow queries inside your transaction functions. We recommend you get in and out as quick as possible!\n\n## Conclusion[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#conclusion \"Direct link to Conclusion\")\n\nPrisma Client supports multiple ways of handling transactions, either directly through the API or by supporting your ability to introduce optimistic concurrency control and idempotency into your application. If you feel like you have use cases in your application that are not covered by any of the suggested options, please open a [GitHub issue](https://github.com/prisma/prisma/issues/new/choose) to start a discussion.",
    "title": "Transactions and batch queries (Reference) | Prisma Documentation",
    "description": "This page explains the transactions API of Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields",
    "markdown": "# Excluding fields | Prisma Documentation\n\nBy default Prisma Client returns all fields from a model. You can use `select` to narrow the result set, but that can be unwieldy if you have a large model and you only want to exclude one or two fields.\n\ninfo\n\nAs of Prisma ORM 5.16.0, excluding fields globally and locally is supported via the `omitApi` Preview feature.\n\n## Excluding a field globally using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-globally-using-omit \"Direct link to excluding-a-field-globally-using-omit\")\n\nThe following is a type-safe way to exclude a field globally using the [`omitApi` Preview feature](https://www.prisma.io/docs/orm/reference/preview-features):\n\n*   Schema\n*   Code\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"omitApi\"]}model User {  id        Int      @id @default(autoincrement())  firstName String  lastName  String  email     String   @unique  password  String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n## Excluding a field locally using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-locally-using-omit \"Direct link to excluding-a-field-locally-using-omit\")\n\nThe following is a type-safe way to exclude a field locally using the `omitApi` Preview feature:\n\n*   Schema\n*   Code\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"omitApi\"]}model User {  id        Int      @id @default(autoincrement())  firstName String  lastName  String  email     String   @unique  password  String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n## How to omit multiple fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-omit-multiple-fields \"Direct link to How to omit multiple fields\")\n\nOmitting multiple fields works the same as selecting multiple fields: add multiple key-value pairs to the omit option. Using the same schema as before, you could omit password and email with the following:\n\n```\nconst prisma = new PrismaClient()// password and email are excludedconst user = await prisma.user.findUnique({  omit: {    email: true,    password: true,  },  where: {    id: 1,  },})\n```\n\nMultiple fields can be omitted locally and globally.\n\n## How to select a previously omitted field[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-select-a-previously-omitted-field \"Direct link to How to select a previously omitted field\")\n\nIf you [omit a field globally](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-globally-using-omit), you can \"override\" by either selecting the field specifically or by setting `omit` to `false` in a query.\n\n*   Explicit Select\n*   Omit False\n\n```\nconst user = await prisma.user.findUnique({  select: {    firstName: true,    lastName: true,    password: true // The password field is now selected.  },  where: {    id: 1  }})\n```\n\n## When to use `omit` globally or locally[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#when-to-use-omit-globally-or-locally \"Direct link to when-to-use-omit-globally-or-locally\")\n\nIt's important to understand when to omit a field globally or locally:\n\n*   If you are omitting a field in order to prevent it from accidentally being included in a query, it's best to omit it globally. For example: Globally omitting the password field from a User model so that sensitive information doesn't accidentally get exposed.\n*   If you are omitting a field because it's not needed in a query, it's best to omit it locally.\n\nLocal omit (when an `omit` option is provided in a query) only applies to the query it is defined in, while a global omit applies to every query made with the same Prisma Client instance, [unless a specific select is used or the omit is overridden](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-select-a-previously-omitted-field).\n\n## Excluding the password field without using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-the-password-field-without-using-omit \"Direct link to excluding-the-password-field-without-using-omit\")\n\nnote\n\nThe `omitApi` Preview feature, released in Prisma ORM 5.13.0, is the preferred way of omitting fields from a query result. The ability to globally omit fields was added to the `omitApi` Preview feature in Prisma ORM 5.16.0. This documentation is still relevant for versions of Prisma ORM prior to 5.13.0.\n\nThe following is a type-safe `exclude` function returns a user without the `password` field.\n\n*   TypeScript\n*   JavaScript\n\n```\n// Exclude keys from userfunction exclude<User, Key extends keyof User>(  user: User,  keys: Key[]): Omit<User, Key> {  return Object.fromEntries(    Object.entries(user).filter(([key]) => !keys.includes(key))  )}function main() {  const user = await prisma.user.findUnique({ where: 1 })  const userWithoutPassword = exclude(user, ['password'])}\n```\n\nIn the TypeScript example, we've provided two generics: `User` and `Key`. The `Key` generic is defined as the keys of a `User` (e.g. `email`, `password`, `firstName`, etc.).\n\nThese generics flow through the logic, returning a `User` that omits the list of `Key`s provided.",
    "title": "Excluding fields | Prisma Documentation",
    "description": "This page explains how to exclude sensitive fields from Prisma Client",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity",
    "markdown": "# Case sensitivity (Reference) | Prisma Documentation\n\nCase sensitivity affects **filtering** and **sorting** of data, and is determined by your [database collation](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#database-collation-and-case-sensitivity). Sorting and filtering data yields different results depending on your settings:\n\n| Action | Case sensitive | Case insensitive |\n| --- | --- | --- |\n| Sort ascending | `Apple`, `Banana`, `apple pie`, `banana pie` | `Apple`, `apple pie`, `Banana`, `banana pie` |\n| Match `\"apple\"` | `apple` | `Apple`, `apple` |\n\nIf you use a **relational database connector**, [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) respects your database collation. Options and recommendations for supporting **case-insensitive** filtering and sorting with Prisma Client depend on your [database provider](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering).\n\nIf you use the MongoDB connector, [Prisma Client](https://www.prisma.io/docs/orm/prisma-client/queries) uses RegEx rules to enable case-insensitive filtering. The connector _does not_ use [MongoDB collation](https://docs.mongodb.com/manual/reference/collation/).\n\n> **Note**: Follow the progress of [case-insensitive sorting on GitHub](https://github.com/prisma/prisma-client-js/issues/841).\n\n## Database collation and case sensitivity[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#database-collation-and-case-sensitivity \"Direct link to Database collation and case sensitivity\")\n\ninfo\n\nIn the context of Prisma Client, the following section refers to relational database connectors only.\n\nCollation specifies how data is **sorted and compared** in a database, which includes casing. Collation is something you choose when you set up a database.\n\nThe following example demonstrates how to view the collation of a MySQL database:\n\n```\nSELECT @@character_set_database, @@collation_database;\n```\n\nThe example collation, [`utf8mb4_0900_ai_ci`](https://dev.mysql.com/doc/refman/8.0/en/charset-collation-names.html), is:\n\n*   Accent-insensitive (`ai`)\n*   Case-insensitive (`ci`).\n\nThis means that `prisMa` will match `prisma`, `PRISMA`, `priSMA`, and so on:\n\n```\nSELECT id, email FROM User WHERE email LIKE \"%prisMa%\"\n```\n\nThe same query with Prisma Client:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      contains: 'prisMa',    },  },  select: {    id: true,    name: true,  },})\n```\n\n## Options for case-insensitive filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering \"Direct link to Options for case-insensitive filtering\")\n\nThe recommended way to support case-insensitive filtering with Prisma Client depends on your underlying provider.\n\n### PostgreSQL provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#postgresql-provider \"Direct link to PostgreSQL provider\")\n\nPostgreSQL uses [deterministic collation](https://www.postgresql.org/docs/current/collation.html#COLLATION-NONDETERMINISTIC) by default, which means that filtering is **case-sensitive**. To support case-insensitive filtering, use the `mode: 'insensitive'` property on a per-field basis.\n\nUse the `mode` property on a filter as shown:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },  },})\n```\n\nSee also: [Filtering (Case-insensitive filtering)](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering)\n\n#### Caveats[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#caveats \"Direct link to Caveats\")\n\n*   You cannot use case-insensitive filtering with C collation\n*   [`citext`](https://www.postgresql.org/docs/12/citext.html) columns are always case-insensitive and are not affected by `mode`\n\n#### Performance[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#performance \"Direct link to Performance\")\n\nIf you rely heavily on case-insensitive filtering, consider [creating indexes in the PostgreSQL database](https://www.postgresql.org/docs/current/indexes.html) to improve performance:\n\n*   [Create an expression index](https://www.postgresql.org/docs/current/indexes-expressional.html) for Prisma Client queries that use `equals` or `not`\n*   Use the `pg_trgm` module to [create a trigram-based index](https://www.postgresql.org/docs/12/pgtrgm.html#id-1.11.7.40.7) for Prisma Client queries that use `startsWith`, `endsWith`, `contains` (maps to`LIKE` / `ILIKE` in PostgreSQL)\n\n### MySQL provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#mysql-provider \"Direct link to MySQL provider\")\n\nMySQL uses **case-insensitive collation** by default. Therefore, filtering with Prisma Client and MySQL is case-insensitive by default.\n\n`mode: 'insensitive'` property is not required and therefore not available in the generated Prisma Client API.\n\n#### Caveats[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#caveats-1 \"Direct link to Caveats\")\n\n*   You _must_ use a case-insensitive (`_ci`) collation in order to support case-insensitive filtering. Prisma Client does no support the `mode` filter property for the MySQL provider.\n\n### MongoDB provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#mongodb-provider \"Direct link to MongoDB provider\")\n\nTo support case-insensitive filtering, use the `mode: 'insensitive'` property on a per-field basis:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },  },})\n```\n\nThe MongoDB uses a RegEx rule for case-insensitive filtering.\n\n### SQLite provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#sqlite-provider \"Direct link to SQLite provider\")\n\nBy default, text fields created by Prisma Client in SQLite databases do not support case-insensitive filtering. In SQLite, only [case-insensitive comparisons of ASCII characters](https://www.sqlite.org/faq.html#q18) are possible.\n\nTo enable limited support (ASCII only) for case-insensitive filtering on a per-column basis, you will need to add `COLLATE NOCASE` when you define a text column.\n\n#### Adding case-insensitive filtering to a new column.[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#adding-case-insensitive-filtering-to-a-new-column \"Direct link to Adding case-insensitive filtering to a new column.\")\n\nTo add case-insensitive filtering to a new column, you will need to modify the migration file that is created by Prisma Client.\n\nTaking the following Prisma Schema model:\n\n```\nmodel User {  id    Int    @id  email String}\n```\n\nand using `prisma migrate dev --create-only` to create the following migration file:\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL);\n```\n\nYou would need to add `COLLATE NOCASE` to the `email` column in order to make case-insensitive filtering possible:\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    //highlight-next-line    \"email\" TEXT NOT NULL COLLATE NOCASE);\n```\n\n#### Adding case-insensitive filtering to an existing column.[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#adding-case-insensitive-filtering-to-an-existing-column \"Direct link to Adding case-insensitive filtering to an existing column.\")\n\nSince columns cannot be updated in SQLite, `COLLATE NOCASE` can only be added to an existing column by creating a blank migration file and migrating data to a new table.\n\nTaking the following Prisma Schema model:\n\n```\nmodel User {  id    Int    @id  email String}\n```\n\nand using `prisma migrate dev --create-only` to create an empty migration file, you will need to rename the current `User` table and create a new `User` table with `COLLATE NOCASE`.\n\n```\n-- UpdateTableALTER TABLE \"User\" RENAME TO \"User_old\";CREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL COLLATE NOCASE);INSERT INTO \"User\" (id, email)SELECT id, email FROM \"User_old\";DROP TABLE \"User_old\";\n```\n\n### Microsoft SQL Server provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#microsoft-sql-server-provider \"Direct link to Microsoft SQL Server provider\")\n\nMicrosoft SQL Server uses **case-insensitive collation** by default. Therefore, filtering with Prisma Client and Microsoft SQL Server is case-insensitive by default.\n\n`mode: 'insensitive'` property is not required and therefore not available in the generated Prisma Client API.",
    "title": "Case sensitivity (Reference) | Prisma Documentation",
    "description": "How Prisma Client handles case sensitivity when filtering and sorting.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/custom-models",
    "markdown": "# Custom models | Prisma Documentation\n\nAs your application grows, you may find the need to group related logic together. We suggest either:\n\n*   Creating static methods using a [Prisma Client extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions)\n*   Wrapping a model in a class\n*   Extending Prisma Client model object\n\n## Static methods with Prisma Client extensions[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#static-methods-with-prisma-client-extensions \"Direct link to Static methods with Prisma Client extensions\")\n\nThe following example demonstrates how to create a Prisma Client extension that adds a `signUp` and `findManyByDomain` methods to a User model.\n\n*   Prisma Client extension\n*   Prisma schema\n\n```\nimport bcrypt from 'bcryptjs'import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient().$extends({  model: {    user: {      async signUp(email: string, password: string) {        const hash = await bcrypt.hash(password, 10)        return prisma.user.create({          data: {            email,            password: {              create: {                hash,              },            },          },        })      },      async findManyByDomain(domain: string) {        return prisma.user.findMany({          where: { email: { endsWith: `@${domain}` } },        })      },    },  },})async function main() {  // Example usage  await prisma.user.signUp('user2@example2.com', 's3cret')  await prisma.user.findManyByDomain('example2.com')}\n```\n\n## Wrap a model in a class[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#wrap-a-model-in-a-class \"Direct link to Wrap a model in a class\")\n\nIn the example below, you'll see how you can wrap the `user` model in the Prisma Client within a `Users` class.\n\n```\nimport { PrismaClient, User } from '@prisma/client'type Signup = {  email: string  firstName: string  lastName: string}class Users {  constructor(private readonly prismaUser: PrismaClient['user']) {}  // Signup a new user  async signup(data: Signup): Promise<User> {    // do some custom validation...    return this.prismaUser.create({ data })  }}async function main() {  const prisma = new PrismaClient()  const users = new Users(prisma.user)  const user = await users.signup({    email: 'alice@prisma.io',    firstName: 'Alice',    lastName: 'Prisma',  })}\n```\n\nWith this new `Users` class, you can define custom functions like `signup`:\n\nNote that in the example above, you're only exposing a `signup` method from Prisma Client. The Prisma Client is hidden within the `Users` class, so you're no longer be able to call methods like `findMany` and `upsert`.\n\nThis approach works well when you have a large application and you want to intentionally limit what your models can do.\n\n## Extending Prisma Client model object[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#extending-prisma-client-model-object \"Direct link to Extending Prisma Client model object\")\n\nBut what if you don't want to hide existing functionality but still want to group custom functions together? In this case, you can use `Object.assign` to extend Prisma Client without limiting its functionality:\n\n```\nimport { PrismaClient, User } from '@prisma/client'type Signup = {  email: string  firstName: string  lastName: string}function Users(prismaUser: PrismaClient['user']) {  return Object.assign(prismaUser, {    /**     * Signup the first user and create a new team of one. Return the User with     * a full name and without a password     */    async signup(data: Signup): Promise<User> {      return prismaUser.create({ data })    },  })}async function main() {  const prisma = new PrismaClient()  const users = Users(prisma.user)  const user = await users.signup({    email: 'alice@prisma.io',    firstName: 'Alice',    lastName: 'Prisma',  })  const numUsers = await users.count()  console.log(user, numUsers)}\n```\n\nNow you can use your custom `signup` method alongside `count`, `updateMany`, `groupBy()` and all of the other wonderful methods that Prisma Client provides. Best of all, it's all type-safe!\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#going-further \"Direct link to Going further\")\n\nWe recommend using [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to extend your models with [custom model methods](https://github.com/prisma/prisma-client-extensions/tree/main/instance-methods).",
    "title": "Custom models | Prisma Documentation",
    "description": "This page explains how to wrap Prisma Client in custom models",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access",
    "markdown": "# Raw database access | Prisma Documentation\n\nWhile Prisma ORM aims to make all your database queries intuitive, type-safe, and convenient, there may be situations where you need to drop down to raw queries.\n\nThis may happen for several reasons, e.g., because you need to optimize the performance of a specific query or because your data requirements can't be expressed by Prisma Client's query API.\n\nIn that case, you can use one of Prisma Client's escape hatches, such as `$queryRaw` or `$executeRaw`, to send raw queries to the database.\n\nWhen using relational databases, you can use **community tools** that can still vastly improve the developer experience writing raw SQL, e.g., by enabling type safety or providing auto-completion for your SQL queries:\n\n*   [`prisma-extension-kysely`](https://github.com/eoin-obrien/prisma-extension-kysely): A Client extension that uses the [Kysely](https://kysely.dev/) SQL query builder API to compose SQL queries in TypeScript, with auto-completion and type safety, and submits them through Prisma Client's connection pool.\n*   [SafeQL](https://safeql.dev/compatibility/prisma.html): An ESLint plugin enabling syntax highlighting and type safety for SQL strings inside Prisma ORM's raw SQL escape hatches. For a tutorial on using SafeQL, visit this [page](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries).\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access#in-this-section \"Direct link to In this section\")\n\n[\n\n## Raw queries\n\n](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries)\n\n[\n\n## Custom & type-safe queries\n\n](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries)",
    "title": "Raw database access | Prisma Documentation",
    "description": "Raw database access with Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance",
    "markdown": "# Query optimization | Prisma Documentation\n\nThis guide describes ways to optimize query performance, debug performance issues, and how to tackle common performance issues such as the [n+1 problem](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-the-n1-problem).\n\n## Debugging performance issues[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#debugging-performance-issues \"Direct link to Debugging performance issues\")\n\nTo help you debug and diagnose performance issues, you can [log query events at client level](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging#event-based-logging), which allows you to see the generated queries, parameters, and durations.\n\nAlternatively, if you are only interested in the time taken to run a query, you can implement [logging middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware).\n\n## Solving the n+1 problem[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-the-n1-problem \"Direct link to Solving the n+1 problem\")\n\nThe n+1 problem occurs when you loop through the results of a query and perform one additional query **per result**, resulting in `n` number of queries plus the original (n+1). This is a common problem with ORMs, particularly in combination with GraphQL, because it is not always immediately obvious that your code is generating inefficient queries.\n\n### Solving n+1 in GraphQL with `findUnique()` and Prisma Client's dataloader[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader \"Direct link to solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader\")\n\nThe Prisma Client dataloader automatically _batches_ `findUnique()` queries that occur in the same [tick](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#processnexttick) and have the same `where` and `include` parameters if:\n\n*   All criteria of the `where` filter are on scalar fields (unique or non-unique) of the same model you're querying.\n*   All criteria use the `equal` filter, whether that's via the shorthand or explicit syntax `(where: { field: <val>, field1: { equals: <val> } })`.\n*   No boolean operators or relation filters are present.\n\nAutomatic batching of `findUnique()` is particularly useful in a **GraphQL context**. GraphQL runs a separate resolver function for every field, which can make it difficult to optimize a nested query.\n\nFor example - the following GraphQL runs the `allUsers` resolver to get all users, and the `posts` resolver **once per user** to get each user's posts (n+1):\n\n```\nquery {  allUsers {    id,    posts {      id    }  }}\n```\n\nThe `allUsers` query uses `user.findMany(..)` to return all users:\n\n```\nconst Query = objectType({  name: 'Query',  definition(t) {    t.nonNull.list.nonNull.field('allUsers', {      type: 'User',      resolve: (_parent, _args, context) => {        return context.prisma.user.findMany()      },    })  },})\n```\n\nThis results in a single SQL query:\n\n```\n{  timestamp: 2021-02-19T09:43:06.332Z,  query: 'SELECT `dev`.`User`.`id`, `dev`.`User`.`email`, `dev`.`User`.`name` FROM `dev`.`User` WHERE 1=1 LIMIT ? OFFSET ?',  params: '[-1,0]',  duration: 0,  target: 'quaint::connector::metrics'}\n```\n\nHowever, the resolver function for `posts` is then invoked **once per user**. This results in a `findMany()` query **✘ per user** rather than a single `findMany()` to return all posts by all users (expand CLI output to see queries).\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.nonNull.int('id')    t.string('name')    t.nonNull.string('email')    t.nonNull.list.nonNull.field('posts', {      type: 'Post',      resolve: (parent, _, context) => {        return context.prisma.post.findMany({          where: { authorId: parent.id || undefined },        })      },    })  },})\n```\n\nInstead, use `findUnique()` in combination with [the fluent API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api) (`.posts()`) as shown to return a user's posts. Even though the resolver is called once per user, the Prisma dataloader in Prisma Client **✔ batches the `findUnique()` queries**.\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.nonNull.int('id')    t.string('name')    t.nonNull.string('email')    t.nonNull.list.nonNull.field('posts', {      type: 'Post',      resolve: (parent, _, context) => {        return context.prisma.post.findMany({          where: { authorId: parent.id || undefined },        })        return context.prisma.user          .findUnique({            where: { id: parent.id || undefined },          })          .posts()      },    })  },})\n```\n\nIf the `posts` resolver is invoked once per user, the dataloader in Prisma Client groups `findUnique()` queries with the same parameters and selection set. Each group is optimized into a single `findMany()`.\n\n#### Do I have to use the fluent API to enable batching of queries?[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#do-i-have-to-use-the-fluent-api-to-enable-batching-of-queries \"Direct link to Do I have to use the fluent API to enable batching of queries?\")\n\nIt may seem counterintitive to use a `prisma.user.findUnique(...).posts()` query to return posts instead of `prisma.posts.findMany()` - particularly as the former results in two queries rather than one.\n\nThe **only** reason you need to use the fluent API (`user.findUnique(...).posts()`) to return posts is that the dataloader in Prisma Client batches `findUnique()` queries and does not currently [batch `findMany()` queries](https://github.com/prisma/prisma/issues/1477).\n\nWhen the dataloader batches `findMany()` queries, you no longer need to use `findUnique()` with the fluent API in this way.\n\n### n+1 in other contexts[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#n1-in-other-contexts \"Direct link to n+1 in other contexts\")\n\nThe n+1 problem is most commonly seen in a GraphQL context because you have to find a way to optimize a single query across multiple resolvers. However, you can just as easily introduce the n+1 problem by looping through results with `forEach` in your own code.\n\nThe following code results in n+1 queries - one `findMany()` to get all users, and one `findMany()` **per user** to get each user's posts:\n\n```\n// One query to get all usersconst users = await prisma.user.findMany({})// One query PER USER to get all postsusers.forEach(async (usr) => {  const posts = await prisma.post.findMany({    where: {      authorId: usr.id,    },  })  // Do something with each users' posts})\n```\n\nThis is not an efficient way to query. Instead, you can:\n\n*   Use nested reads ([`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) ) to return users and related posts\n*   Use the [`in`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in) filter\n\n#### Solving n+1 with `include`[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-with-include \"Direct link to solving-n1-with-include\")\n\nYou can use `include` to return each user's posts. This only results in **two** SQL queries - one to get users, and one to get posts. This is known as a [nested read](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads).\n\n```\nconst usersWithPosts = await prisma.user.findMany({  include: {    posts: true,  },})\n```\n\n#### Solving n+1 with `in`[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-with-in \"Direct link to solving-n1-with-in\")\n\nIf you have a list of user IDs, you can use the `in` filter to return all posts where the `authorId` is `in` that list of IDs:\n\n```\nconst users = await prisma.user.findMany({})const userIds = users.map((x) => x.id)const posts = await prisma.post.findMany({  where: {    authorId: {      in: userIds,    },  },})\n```\n\n## Using bulk queries[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#using-bulk-queries \"Direct link to Using bulk queries\")\n\nIt is generally more performant to read and write large amounts of data in bulk - for example, inserting 50,000 records in batches of 1000 rather than as 50,000 separate inserts. Prisma Client supports the following bulk queries:\n\n*   [`createMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany)\n*   [`createManyAndReturn()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmanyandreturn)\n*   [`deleteMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany)\n*   [`updateMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany)\n*   [`findMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany)\n\n## Using `select` to limit number of columns returned[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#using-select-to-limit-number-of-columns-returned \"Direct link to using-select-to-limit-number-of-columns-returned\")\n\nUsing `select` to limit the number of columns that are returned is **unlikely to have an effect on performance** unless you have identified this as a performance bottleneck through testing. For example, reading all fields may negatively affect performance if you have:\n\n*   Tables with a large number of columns\n*   Large columns that are stored in a separate location on disk rather than a row, which results in an additional disk read\n\nFurthermore, if you have a mature product with well-established query patterns and finely tuned indexes, selecting a specific subset of fields may be beneficial as it avoids reading data from disk. However, in most cases, this level of performance tuning is only necessary at a certain scale.",
    "title": "Query optimization | Prisma Documentation",
    "description": "How Prisma optimizes queries under the hood",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries",
    "markdown": "# Raw queries | Prisma Documentation\n\nPrisma Client supports the option of sending raw queries to your database. You may wish to use raw queries if:\n\n*   you want to run a heavily optimized query\n*   you require a feature that Prisma Client does not yet support (please [consider raising an issue](https://github.com/prisma/prisma/issues/new/choose))\n\nRaw queries are available for all relational databases Prisma ORM supports. In addition, from version `3.9.0` raw queries are supported in MongoDB. For more details, see the relevant sections:\n\n*   [Raw queries with relational databases](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-relational-databases)\n*   [Raw queries with MongoDB](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-mongodb)\n\n## Raw queries with relational databases[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-relational-databases \"Direct link to Raw queries with relational databases\")\n\nFor relational databases, Prisma Client exposes four methods that allow you to send raw queries. You can use:\n\n*   `$queryRaw` to return actual records (for example, using `SELECT`).\n*   `$executeRaw` to return a count of affected rows (for example, after an `UPDATE` or `DELETE`).\n*   `$queryRawUnsafe` to return actual records (for example, using `SELECT`) using a raw string.\n*   `$executeRawUnsafe` to return a count of affected rows (for example, after an `UPDATE` or `DELETE`) using a raw string.\n\nThe methods with \"Unsafe\" in the name are a lot more flexible but are at **significant risk of making your code vulnerable to SQL injection**.\n\nThe other two methods are safe to use with a simple template tag, no string building, and no concatenation. **However**, caution is required for more complex use cases as it is still possible to introduce SQL injection if these methods are used in certain ways. For more details, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n> **Note**: All methods in the above list can only run **one** query at a time. You cannot append a second query - for example, calling any of them with `select 1; select 2;` will not work.\n\n### `$queryRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryraw \"Direct link to queryraw\")\n\n`$queryRaw` returns actual database records. For example, the following `SELECT` query returns all fields for each record in the `User` table:\n\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User`\n```\n\nThe method is implemented as a [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates), which allows you to pass a template literal where you can easily insert your [variables](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables). In turn, Prisma Client creates prepared statements that are safe from SQL injections:\n\n```\nconst email = 'emelie@prisma.io'const result = await prisma.$queryRaw`SELECT * FROM User WHERE email = ${email}`\n```\n\nYou can also use the [`Prisma.sql`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers) helper, in fact, the `$queryRaw` method will **only accept** a template string or the `Prisma.sql` helper:\n\n```\nconst email = 'emelie@prisma.io'const result = await prisma.$queryRaw(  Prisma.sql`SELECT * FROM User WHERE email = ${email}`)\n```\n\nwarning\n\nIf you use string building to incorporate untrusted input into queries passed to this method, then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion. The prefered mechanism would be to include the text of the query at the point that you run this method. For more information on this risk and also examples of how to prevent it, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n#### Considerations[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations \"Direct link to Considerations\")\n\nBe aware that:\n\n*   Template variables cannot be used inside SQL string literals. For example, the following query would **not** work:\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`SELECT 'My name is ${name}';`\n    ```\n    \n    Instead, you can either pass the whole string as a variable, or use string concatenation:\n    \n    ```\n    const name = 'My name is Bob'await prisma.$queryRaw`SELECT ${name};`\n    ```\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`SELECT 'My name is ' || ${name};`\n    ```\n    \n*   Template variables can only be used for data values (such as `email` in the example above). Variables cannot be used for identifiers such as column names, table names or database names, or for SQL keywords. For example, the following two queries would **not** work:\n    \n    ```\n    const myTable = 'user'await prisma.$queryRaw`SELECT * FROM ${myTable};`\n    ```\n    \n    ```\n    const ordering = 'desc'await prisma.$queryRaw`SELECT * FROM Table ORDER BY ${ordering};`\n    ```\n    \n*   Prisma maps any database values returned by `$queryRaw` and `$queryRawUnsafe` to their corresponding JavaScript types. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping).\n    \n*   `$queryRaw` does not support dynamic table names in PostgreSQL databases. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#dynamic-table-names-in-postgresql)\n    \n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type \"Direct link to Return type\")\n\n`$queryRaw` returns an array. Each object corresponds to a database record:\n\n```\n[  { id: 1, email: 'emelie@prisma.io', name: 'Emelie' },  { id: 2, email: 'yin@prisma.io', name: 'Yin' },]\n```\n\nYou can also [type the results of `$queryRaw`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#typing-queryraw-results).\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature \"Direct link to Signature\")\n\n```\n$queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;\n```\n\n#### Typing `$queryRaw` results[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#typing-queryraw-results \"Direct link to typing-queryraw-results\")\n\n`PrismaPromise<T>` uses a [generic type parameter `T`](https://www.typescriptlang.org/docs/handbook/generics.html). You can determine the type of `T` when you invoke the `$queryRaw` method. In the following example, `$queryRaw` returns `User[]`:\n\n```\n// import the generated `User` type from the `@prisma/client` moduleimport { User } from '@prisma/client'const result = await prisma.$queryRaw<User[]>`SELECT * FROM User`// result is of type: `User[]`\n```\n\n> **Note**: If you do not provide a type, `$queryRaw` defaults to `unknown`.\n\nIf you are selecting **specific fields** of the model or want to include relations, refer to the documentation about [leveraging Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#problem-using-variations-of-the-generated-model-type) if you want to make sure that the results are properly typed.\n\n#### Type caveats when using raw SQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#type-caveats-when-using-raw-sql \"Direct link to Type caveats when using raw SQL\")\n\nWhen you type the results of `$queryRaw`, the raw data might not always match the suggested TypeScript type. For example, the following Prisma model includes a `Boolean` field named `published`:\n\n```\nmodel Post {  id        Int     @id @default(autoincrement())  published Boolean @default(false)  title     String  content   String?}\n```\n\nThe following query returns all posts. It then prints out the value of the `published` field for each `Post`:\n\n```\nconst result = await prisma.$queryRaw<Post[]>`SELECT * FROM Post`result.forEach((x) => {  console.log(x.published)})\n```\n\nFor regular CRUD queries, the Prisma Client query engine standardizes the return type for all databases. **Using the raw queries does not**. If the database provider is MySQL, the returned values are `1` or `0`. However, if the database provider is PostgreSQL, the values are `true` or `false`.\n\n> **Note**: Prisma sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input. If you use `$queryRaw` in conjunction with a PostgreSQL database, update the input types to `INT8`, or cast your query parameters to `INT4`.\n\n#### Dynamic table names in PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#dynamic-table-names-in-postgresql \"Direct link to Dynamic table names in PostgreSQL\")\n\n[It is not possible to interpolate table names](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations). This means that you cannot use dynamic table names with `$queryRaw`. Instead, you must use [`$queryRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe), as follows:\n\n```\nlet userTable = 'User'let result = await prisma.$queryRawUnsafe(`SELECT * FROM ${userTable}`)\n```\n\nNote that if you use `$queryRawUnsafe` in conjunction with user inputs, you risk SQL injection attacks. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe).\n\n### `$queryRawUnsafe()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe \"Direct link to queryrawunsafe\")\n\nThe `$queryRawUnsafe()` method allows you to pass a raw string (or template string) to the database.\n\nwarning\n\nIf you use this method with user inputs (in other words, `SELECT * FROM table WHERE columnx = ${userInput}`), then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion.\n\nWherever possible you should use the `$queryRaw` method instead. When used correctly `$queryRaw` method is significantly safer but note that the `$queryRaw` method can also be made vulnerable in certain circumstances. For more information, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\nThe following query returns all fields for each record in the `User` table:\n\n```\n// import the generated `User` type from the `@prisma/client` moduleimport { User } from '@prisma/client'const result = await prisma.$queryRawUnsafe('SELECT * FROM User')\n```\n\nYou can also run a parameterized query. The following example returns all users whose email contains the string `emelie@prisma.io`:\n\n```\nprisma.$queryRawUnsafe(  'SELECT * FROM users WHERE email = $1',  'emelie@prisma.io')\n```\n\n> **Note**: Prisma sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input. If you use a parameterized `$queryRawUnsafe` query in conjunction with a PostgreSQL database, update the input types to `INT8`, or cast your query parameters to `INT4`.\n\nFor more details on using parameterized queries, see the [parameterized queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries) section below.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-1 \"Direct link to Signature\")\n\n```\n$queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\n```\n\n### `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executeraw \"Direct link to executeraw\")\n\n`$executeRaw` returns the _number of rows affected by a database operation_, such as `UPDATE` or `DELETE`. This function does **not** return database records. The following query updates records in the database and returns a count of the number of records that were updated:\n\n```\nconst result: number =  await prisma.$executeRaw`UPDATE User SET active = true WHERE emailValidated = true`\n```\n\nThe method is implemented as a [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates), which allows you to pass a template literal where you can easily insert your [variables](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables). In turn, Prisma Client creates prepared statements that are safe from SQL injections:\n\n```\nconst emailValidated = trueconst active = trueconst result: number =  await prisma.$executeRaw`UPDATE User SET active = ${active} WHERE emailValidated = ${emailValidated};`\n```\n\nwarning\n\nIf you use string building to incorporate untrusted input into queries passed to this method, then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion. The prefered mechanism would be to include the text of the query at the point that you run this method. For more information on this risk and also examples of how to prevent it, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n#### Considerations[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations-1 \"Direct link to Considerations\")\n\nBe aware that:\n\n*   `$executeRaw` does not support multiple queries in a single string (for example, `ALTER TABLE` and `CREATE TABLE` together).\n    \n*   Prisma Client submits prepared statements, and prepared statements only allow a subset of SQL statements. For example, `START TRANSACTION` is not permitted. You can learn more about [the syntax that MySQL allows in Prepared Statements here](https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html).\n    \n*   [`PREPARE` does not support `ALTER`](https://www.postgresql.org/docs/current/sql-prepare.html) - see the [workaround](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#alter-limitation-postgresql).\n    \n*   Template variables cannot be used inside SQL string literals. For example, the following query would **not** work:\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`UPDATE user SET greeting = 'My name is ${name}';`\n    ```\n    \n    Instead, you can either pass the whole string as a variable, or use string concatenation:\n    \n    ```\n    const name = 'My name is Bob'await prisma.$queryRaw`UPDATE user SET greeting = ${name};`\n    ```\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`UPDATE user SET greeting = 'My name is ' || ${name};`\n    ```\n    \n*   Template variables can only be used for data values (such as `email` in the example above). Variables cannot be used for identifiers such as column names, table names or database names, or for SQL keywords. For example, the following two queries would **not** work:\n    \n    ```\n    const myTable = 'user'await prisma.$queryRaw`UPDATE ${myTable} SET active = true;`\n    ```\n    \n    ```\n    const ordering = 'desc'await prisma.$queryRaw`UPDATE User SET active = true ORDER BY ${desc};`\n    ```\n    \n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-1 \"Direct link to Return type\")\n\n`$executeRaw` returns a `number`.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-2 \"Direct link to Signature\")\n\n```\n$executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;\n```\n\n### `$executeRawUnsafe()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe \"Direct link to executerawunsafe\")\n\nThe `$executeRawUnsafe()` method allows you to pass a raw string (or template string) to the database. Like `$executeRaw`, it does **not** return database records, but returns the number of rows affected.\n\nwarning\n\nIf you use this method with user inputs (in other words, `SELECT * FROM table WHERE columnx = ${userInput}`), then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion.\n\nWherever possible you should use the `$executeRaw` method instead. When used correctly `$executeRaw` method is significantly safer but note that the `$executeRaw` method can also be made vulnerable in certain circumstances. For more information, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\nThe following example uses a template string to update records in the database. It then returns a count of the number of records that were updated:\n\n```\nconst emailValidated = trueconst active = trueconst result = await prisma.$executeRawUnsafe(  `UPDATE User SET active = ${active} WHERE emailValidated = ${emailValidated}`)\n```\n\nThe same can be written as a parameterized query:\n\n```\nconst result = prisma.$executeRawUnsafe(  'UPDATE User SET active = $1 WHERE emailValidated = $2',  'yin@prisma.io',  true)\n```\n\nFor more details on using parameterized queries, see the [parameterized queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries) section below.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-3 \"Direct link to Signature\")\n\n```\n$executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;\n```\n\n### Raw query type mapping[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping \"Direct link to Raw query type mapping\")\n\nPrisma maps any database values returned by `$queryRaw` and `$queryRawUnsafe`to their corresponding [JavaScript types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures). This behavior is the same as for regular Prisma query methods like `findMany()`.\n\ninfo\n\n**Feature availability:**\n\n*   In v3.14.x and v3.15.x, raw query type mapping was available with the preview feature `improvedQueryRaw`. We made raw query type mapping [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) in version 4.0.0, so you do not need to use `improvedQueryRaw` in version 4.0.0 or later.\n*   Before version 4.0.0, raw query type mapping was not available for SQLite.\n\nAs an example, take a raw query that selects columns with `BigInt`, `Bytes`, `Decimal` and `Date` types from a table:\n\n```\nconst result =  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM \"Table\";`console.log(result)\n```\n\nIn the `result` object, the database values have been mapped to the corresponding JavaScript types.\n\nThe following table shows the conversion between types used in the database and the JavaScript type returned by the raw query:\n\n| Database type | JavaScript type |\n| --- | --- |\n| Text | `String` |\n| 32-bit integer | `Number` |\n| Floating point number | `Number` |\n| Double precision number | `Number` |\n| 64-bit integer | `BigInt` |\n| Decimal / numeric | `Decimal` |\n| Bytes | `Buffer` |\n| Json | `Object` |\n| DateTime | `Date` |\n| Date | `Date` |\n| Time | `Date` |\n| Uuid | `String` |\n| Xml | `String` |\n\nNote that the exact name for each database type will vary between databases – for example, the boolean type is known as `boolean` in PostgreSQL and `STRING` in CockroachDB. See the [Scalar types reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for full details of type names for each database.\n\n### Raw query typecasting behavior[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-typecasting-behavior \"Direct link to Raw query typecasting behavior\")\n\nRaw queries with Prisma Client might require parameters to be in the expected types of the SQL function or query. Prisma Client does not do subtle, implicit casts.\n\nAs an example, take the following query using PostgreSQL's `LENGTH` function, which only accepts the `text` type as an input:\n\n```\nawait prisma.$queryRaw`SELECT LENGTH(${42});`\n```\n\nThis query returns an error:\n\n```\n// ERROR: function length(integer) does not exist// HINT: No function matches the given name and argument types. You might need to add explicit type casts.\n```\n\nThe solution in this case is to explicitly cast `42` to the `text` type:\n\n```\nawait prisma.$queryRaw`SELECT LENGTH(${42}::text);`\n```\n\ninfo\n\n**Feature availability:** This funtionality is [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) since version 4.0.0. In v3.14.x and v3.15.x, it was available with the preview feature `improvedQueryRaw`.\n\nFor the example above before version 4.0.0, Prisma ORM silently coerces `42` to `text` and does not require the explicit cast.\n\nOn the other hand the following raw query now works correctly, returning an integer result, and failed before:\n\n```\nawait prisma.$queryRaw`SELECT ${1.5}::int as int`// Now: [{ int: 2 }]// Before: db error: ERROR: incorrect binary data format in bind parameter 1\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#transactions \"Direct link to Transactions\")\n\nIn 2.10.0 and later, you can use `.$executeRaw()` and `.$queryRaw()` inside a [transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).\n\n### Using variables[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables \"Direct link to Using variables\")\n\n`$executeRaw` and `$queryRaw` are implemented as [**tagged templates**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates). Tagged templates are the recommended way to use variables with raw SQL in the Prisma Client.\n\nThe following example includes a placeholder named `${userId}`:\n\n```\nconst userId = 42const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${userId};`\n```\n\n✔ Benefits of using the tagged template versions of `$queryRaw` and `$executeRaw` include:\n\n*   Prisma Client escapes all variables.\n*   Tagged templates are database-agnostic - you do not need to remember if variables should be written as `$1` (PostgreSQL) or `?` (MySQL).\n*   [SQL Template Tag](https://github.com/blakeembrey/sql-template-tag) give you access to [useful helpers](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers).\n*   Embedded, named variables are easier to read.\n\n> **Note**: You cannot pass a table or column name into a tagged template placeholder. For example, you cannot `SELECT ?` and pass in `*` or `id, name` based on some condition.\n\n#### Tagged template helpers[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers \"Direct link to Tagged template helpers\")\n\nPrisma Client specifically uses [SQL Template Tag](https://github.com/blakeembrey/sql-template-tag), which exposes a number of helpers. For example, the following query uses `join()` to pass in a list of IDs:\n\n```\nimport { Prisma } from '@prisma/client'const ids = [1, 3, 5, 10, 20]const result =  await prisma.$queryRaw`SELECT * FROM User WHERE id IN (${Prisma.join(ids)})`\n```\n\nThe following example uses the `empty` and `sql` helpers to change the query depending on whether `userName` is empty:\n\n```\nimport { Prisma } from '@prisma/client'const userName = ''const result = await prisma.$queryRaw`SELECT * FROM User ${  userName ? Prisma.sql`WHERE name = ${userName}` : Prisma.empty // Cannot use \"\" or NULL here!}`\n```\n\n#### `ALTER` limitation (PostgreSQL)[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#alter-limitation-postgresql \"Direct link to alter-limitation-postgresql\")\n\nPostgreSQL [does not support using `ALTER` in a prepared statement](https://www.postgresql.org/docs/current/sql-prepare.html), which means that the following queries **will not work**:\n\n```\nawait prisma.$executeRaw`ALTER USER prisma WITH PASSWORD \"${password}\"`await prisma.$executeRaw(  Prisma.sql`ALTER USER prisma WITH PASSWORD \"${password}\"`)\n```\n\nYou can use the following query, but be aware that this is potentially **unsafe** as `${password}` is not escaped:\n\n```\nawait prisma.$executeRawUnsafe('ALTER USER prisma WITH PASSWORD \"$1\"', password})\n```\n\n### Unsupported types[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#unsupported-types \"Direct link to Unsupported types\")\n\n[`Unsupported` types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) need to be cast to Prisma Client supported types before using them in `$queryRaw` or `$queryRawUnsafe`. For example, take the following model, which has a `location` field with an `Unsupported` type:\n\n```\nmodel Country {  location  Unsupported(\"point\")?}\n```\n\nThe following query on the unsupported field will **not** work:\n\n```\nawait prisma.$queryRaw`SELECT location FROM Country;`\n```\n\nInstead, cast `Unsupported` fields to any supported Prisma Client type, **if your `Unsupported` column supports the cast**.\n\nThe most common type you may want to cast your `Unsupported` column to is `String`. For example, on PostgreSQL, this would map to the `text` type:\n\n```\nawait prisma.$queryRaw`SELECT location::text FROM Country;`\n```\n\nThe database will thus provide a `String` representation of your data which Prisma Client supports.\n\nFor details of supported Prisma types, see the [Prisma connector overview](https://www.prisma.io/docs/orm/overview/databases) for the relevant database.\n\n## SQL injection prevention[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention \"Direct link to SQL injection prevention\")\n\nThe ideal way to avoid SQL injection in Prisma Client is to use the ORM models to perform queries wherever possible.\n\nWhere this is not possible and raw queries are required, Prisma Client provides various raw methods, but it is important to use these methods safely.\n\nThis section will provide various examples of using these methods safely and unsafely. You can test these examples in the [Prisma Playground](https://playground.prisma.io/examples).\n\n### In `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#in-queryraw-and-executeraw \"Direct link to in-queryraw-and-executeraw\")\n\n#### Simple, safe use of `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#simple-safe-use-of-queryraw-and-executeraw \"Direct link to simple-safe-use-of-queryraw-and-executeraw\")\n\nThese methods can mitigate the risk of SQL injection by escaping all variables when you use tagged templates and sends all queries as prepared statements.\n\n```\n$queryRaw`...` // Tagged template$executeRaw`...` // Tagged template\n```\n\nThe following example is safe ✅ from SQL Injection:\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result =  await prisma.$queryRaw`SELECT id, name FROM \"User\" WHERE name = ${inputString}`console.log(result)\n```\n\n#### Unsafe use of `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#unsafe-use-of-queryraw-and-executeraw \"Direct link to unsafe-use-of-queryraw-and-executeraw\")\n\nHowever, it is also possible to use these methods in unsafe ways.\n\nOne way is by artificially generating a tagged template that unsafely concatenates user input.\n\nThe following example is vulnerable ❌ to SQL Injection:\n\n```\n// Unsafely generate query textconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"` // SQL Injectionconst query = `SELECT id, name FROM \"User\" WHERE name = ${inputString}`// Version for Typescriptconst stringsArray: any = [...[query]]// Version for Javascriptconst stringsArray = [...[query]]// Use the `raw` property to impersonate a tagged templatestringsArray.raw = [query]// Use queryRawconst result = await prisma.$queryRaw(stringsArray)console.log(result)\n```\n\nAnother way to make these methods vulnerable is misuse of the `Prisma.raw` function.\n\nThe following examples are all vulnerable ❌ to SQL Injection:\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result =  await prisma.$queryRaw`SELECT id, name FROM \"User\" WHERE name = ${Prisma.raw(    inputString  )}`console.log(result)\n```\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result = await prisma.$queryRaw(  Prisma.raw(`SELECT id, name FROM \"User\" WHERE name = ${inputString}`))console.log(result)\n```\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const query = Prisma.raw(  `SELECT id, name FROM \"User\" WHERE name = ${inputString}`)const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n#### Safely using `$queryRaw` and `$executeRaw` in more complex scenarios[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#safely-using-queryraw-and-executeraw-in-more-complex-scenarios \"Direct link to safely-using-queryraw-and-executeraw-in-more-complex-scenarios\")\n\n##### Building raw queries separate to query execution[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#building-raw-queries-separate-to-query-execution \"Direct link to Building raw queries separate to query execution\")\n\nIf you want to build your raw queries elsewhere or separate to your parameters you will need to use one of the following methods.\n\nIn this example, the `sql` helper method is used to build the query text by safely including the variable. It is safe ✅ from SQL Injection:\n\n```\n// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`// Safe if the text query below is completely trusted contentconst query = Prisma.sql`SELECT id, name FROM \"User\" WHERE name = ${inputString}`const result = await prisma.$queryRaw(query)console.log(result)\n```\n\nIn this example which is safe ✅ from SQL Injection, the `sql` helper method is used to build the query text including a parameter marker for the input value. Each variable is represented by a marker symbol (`?` for MySQL, `$1`, `$2`, and so on for PostgreSQL). Note that the examples just show PostgreSQL queries.\n\n```\n// Version for Typescriptconst query: any// Version for Javascriptconst query// Safe if the text query below is completely trusted contentquery = Prisma.sql`SELECT id, name FROM \"User\" WHERE name = $1`// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`query.values = [inputString]const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n> **Note**: PostgreSQL variables are represented by `$1`, etc\n\n##### Building raw queries elsewhere or in stages[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#building-raw-queries-elsewhere-or-in-stages \"Direct link to Building raw queries elsewhere or in stages\")\n\nIf you want to build your raw queries somewhere other than where the query is executed, the ideal way to do this is to create an `Sql` object from the segments of your query and pass it the parameter value.\n\nIn the following example we have two variables to parameterize. The example is safe ✅ from SQL Injection as long as the query strings being passed to `Prisma.sql` only contain trusted content:\n\n```\n// Example is safe if the text query below is completely trusted contentconst query1 = `SELECT id, name FROM \"User\" WHERE name = ` // The first parameter would be inserted after this stringconst query2 = ` OR name = ` // The second parameter would be inserted after this stringconst inputString1 = \"Fred\"const inputString2 = `'Sarah' UNION SELECT id, title FROM \"Post\"`const query = Prisma.sql([query1, query2, \"\"], inputString1, inputString2)const result = await prisma.$queryRaw(query);console.log(result);\n```\n\n> Note: Notice that the string array being passed as the first parameter `Prisma.sql` needs to have an empty string at the end as the `sql` function expects one more query segment than the number of parameters.\n\nIf you want to build your raw queries into one large string, this is still possible but requires some care as it is uses the potentially dangerous `Prisma.raw` method. You also need to build your query using the correct parameter markers for your database as Prisma won't be able to provide markers for the relevant database as it usually is.\n\nThe following example is safe ✅ from SQL Injection as long as the query strings being passed to `Prisma.raw` only contain trusted content:\n\n```\n// Version for Typescriptconst query: any// Version for Javascriptconst query// Example is safe if the text query below is completely trusted contentconst query1 = `SELECT id, name FROM \"User\" `const query2 = `WHERE name = $1 `query = Prisma.raw(`${query1}${query2}`)// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`query.values = [inputString]const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n### In `$queryRawUnsafe` and `$executeRawUnsafe`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#in-queryrawunsafe-and-executerawunsafe \"Direct link to in-queryrawunsafe-and-executerawunsafe\")\n\n#### Using `$queryRawUnsafe` and `$executeRawUnsafe` unsafely[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-queryrawunsafe-and-executerawunsafe-unsafely \"Direct link to using-queryrawunsafe-and-executerawunsafe-unsafely\")\n\nIf you cannot use tagged templates, you can instead use [`$queryRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe) or [`$executeRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe) but **be aware that your these functions make it much more likely that your code will be vulnerable to SQL injection**.\n\nThe following example concatenates `query` and `inputString`. Prisma Client ❌ **cannot** escape `inputString` in this example, which makes it vulnerable to SQL injection:\n\n```\nconst inputString = '\"Sarah\" UNION SELECT id, title, content FROM Post' // SQL Injectionconst query = 'SELECT id, name, email FROM User WHERE name = ' + inputStringconst result = await prisma.$queryRawUnsafe(query)console.log(result)\n```\n\n#### Parameterized queries[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries \"Direct link to Parameterized queries\")\n\nAs an alternative to tagged templates, `$queryRawUnsafe` supports standard parameterized queries where each variable is represented by a symbol (`?` for MySQL, `$1`, `$2`, and so on for PostgreSQL). Note that the examples just show PostgreSQL queries.\n\nThe following example is safe ✅ from SQL Injection:\n\n```\nconst userName = 'Sarah'const email = 'sarah@prisma.io'const result = await prisma.$queryRawUnsafe(  'SELECT * FROM User WHERE (name = $1 OR email = $2)',  userName,  email)\n```\n\n> **Note**: PostgreSQL variables are represented by `$1` and `$2`\n\nAs with tagged templates, Prisma Client escapes all variables when they are provided in this way.\n\n> **Note**: You cannot pass a table or column name as a variable into a parameterized query. For example, you cannot `SELECT ?` and pass in `*` or `id, name` based on some condition.\n\n##### Parameterized PostgreSQL `ILIKE` query[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-postgresql-ilike-query \"Direct link to parameterized-postgresql-ilike-query\")\n\nWhen you use `ILIKE`, the `%` wildcard character(s) should be included in the variable itself, not the query (`string`). This example is safe ✅ from SQL Injection.\n\n```\nconst userName = 'Sarah'const emailFragment = 'prisma.io'const result = await prisma.$queryRawUnsafe(  'SELECT * FROM \"User\" WHERE (name = $1 OR email ILIKE $2)',  userName,  `%${emailFragment}`)\n```\n\n> **Note**: Using `%$2` as an argument would not work\n\n## Raw queries with MongoDB[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-mongodb \"Direct link to Raw queries with MongoDB\")\n\nFor MongoDB in versions `3.9.0` and later, Prisma Client exposes three methods that allow you to send raw queries. You can use:\n\n*   `$runCommandRaw` to run a command against the database\n*   `<model>.findRaw` to find zero or more documents that match the filter.\n*   `<model>.aggregateRaw` to perform aggregation operations on a collection.\n\n### `$runCommandRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#runcommandraw \"Direct link to runcommandraw\")\n\n`$runCommandRaw()` runs a raw MongoDB command against the database. As input, it accepts all [MongoDB database commands](https://www.mongodb.com/docs/manual/reference/command/), with the following exceptions:\n\n*   `find` (use [`findRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw) instead)\n*   `aggregate` (use [`aggregateRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw) instead)\n\nWhen you use `$runCommandRaw()` to run a MongoDB database command, note the following:\n\n*   The object that you pass when you invoke `$runCommandRaw()` must follow the syntax of the MongoDB database command.\n*   You must connect to the database with an appropriate role for the MongoDB database command.\n\nIn the following example, a query inserts two records with the same `_id`. This bypasses normal document validation.\n\n```\nprisma.$runCommandRaw({  insert: 'Pets',  bypassDocumentValidation: true,  documents: [    {      _id: 1,      name: 'Felinecitas',      type: 'Cat',      breed: 'Russian Blue',      age: 12,    },    {      _id: 1,      name: 'Nao Nao',      type: 'Dog',      breed: 'Chow Chow',      age: 2,    },  ],})\n```\n\nwarning\n\nDo not use `$runCommandRaw()` for queries which contain the `\"find\"` or `\"aggregate\"` commands, because you might be unable to fetch all data. This is because MongoDB returns a [cursor](https://docs.mongodb.com/manual/tutorial/iterate-a-cursor/) that is attached to your MongoDB session, and you might not hit the same MongoDB session every time. For these queries, you should use the specialised [`findRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw) and [`aggregateRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw) methods instead.\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-2 \"Direct link to Return type\")\n\n`$runCommandRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-4 \"Direct link to Signature\")\n\n```\n$runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\n```\n\n### `findRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw \"Direct link to findraw\")\n\n`<model>.findRaw()` returns actual database records. It will find zero or more documents that match the filter on the `User` collection:\n\n```\nconst result = await prisma.user.findRaw({  filter: { age: { $gt: 25 } },  options: { projection: { _id: false } },})\n```\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-3 \"Direct link to Return type\")\n\n`<model>.findRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-5 \"Direct link to Signature\")\n\n```\n<model>.findRaw(args?: {filter?: InputJsonObject, options?: InputJsonObject}): PrismaPromise<JsonObject>;\n```\n\n*   `filter`: The query predicate filter. If unspecified, then all documents in the collection will match the [predicate](https://docs.mongodb.com/manual/reference/operator/query).\n*   `options`: Additional options to pass to the [`find` command](https://docs.mongodb.com/manual/reference/command/find/#command-fields).\n\n### `aggregateRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw \"Direct link to aggregateraw\")\n\n`<model>.aggregateRaw()` returns aggregated database records. It will perform aggregation operations on the `User` collection:\n\n```\nconst result = await prisma.user.aggregateRaw({  pipeline: [    { $match: { status: 'registered' } },    { $group: { _id: '$country', total: { $sum: 1 } } },  ],})\n```\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-4 \"Direct link to Return type\")\n\n`<model>.aggregateRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-6 \"Direct link to Signature\")\n\n```\n<model>.aggregateRaw(args?: {pipeline?: InputJsonObject[], options?: InputJsonObject}): PrismaPromise<JsonObject>;\n```\n\n*   `pipeline`: An array of aggregation stages to process and transform the document stream via the [aggregation pipeline](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline).\n*   `options`: Additional options to pass to the [`aggregate` command](https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields).",
    "title": "Raw queries | Prisma Documentation",
    "description": "Learn how you can send raw SQL and MongoDB queries to your database using the raw() methods from the Prisma Client API.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose",
    "markdown": "# How to migrate from Mongoose to Prisma ORM\n\nThis guide describes how to migrate from Mongoose to Prisma ORM. It uses an extended version of the [Mongoose Express example](https://github.com/Automattic/mongoose/tree/master/examples/express) as a [sample project](https://github.com/prisma/migrate-from-mongoose-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-mongoose-to-prisma).\n\nYou can learn how Prisma ORM compares to Mongoose on the [Prisma ORM vs Mongoose](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Mongoose to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  [Install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation)\n2.  [Introspect your database](https://www.prisma.io/docs/orm/prisma-schema/introspection)\n3.  [Install and generate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client)\n4.  Gradually replace your Mongoose queries with Prisma Client\n\nThese steps apply whether you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Mongoose for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Mongoose to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Mongoose to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-mongoose-to-prisma) to migrate to Prisma ORM. It has three documents and one sub-document (embedded document):\n\n*   post.js\n*   user.js\n*   category.js\n\n```\nconst mongoose = require('mongoose')const Schema = mongoose.Schemaconst PostSchema = new Schema({  title: String,  content: String,  published: {    type: Boolean,    default: false,  },  author: {    type: Schema.Types.ObjectId,    ref: 'author',    required: true,  },  categories: [    {      type: Schema.Types.ObjectId,      ref: 'Category',    },  ],})module.exports = mongoose.model('Post', PostSchema)\n```\n\nThe models/documents have the following types of relationships:\n\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n*   Sub-document/ Embedded document: `User` ↔ `Profile`\n\nIn the example used in this guide, the route handlers are located in the `src/controllers` directory. The models are located in the `src/models` directory. From there, the models are pulled into a central `src/routes.js` file, which is used to define the required routes in `src/index.js`:\n\n```\n└── blog-mongoose    ├── package.json    └──src        ├── controllers        │   ├── post.js        │   └── user.js        ├── models        │   ├── category.js        │   ├── post.js        │   └── user.js        ├── index.js        ├── routes.js        └── seed.js\n```\n\nThe example repository contains a `seed` script inside the `package.json` file.\n\nRun `npm run seed` to populate your database with the sample data in the `./src/seed.js` file.\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\nIntrospection is a process of inspecting the structure of a database, used in Prisma ORM to generate a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema).\n\n### 2.1. Set up Prisma[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#21-set-up-prisma \"Direct link to 2.1. Set up Prisma\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma ORM to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\n```\nnpx prisma init --datasource-provider mongodb\n```\n\nThis command creates:\n\n*   A new directory called `prisma` that contains a `schema.prisma` file; your Prisma schema specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) file at the root of your project (if it doesn't already exist), used to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\n  \n\ntip\n\nFor an optimal development experience when working with Prisma ORM, refer to [editor setup](https://www.prisma.io/docs/orm/more/development-environment/editor-setup) to learn about syntax highlighting, formatting, auto-completion, and many more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nConfigure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls#mongodb) in the `.env` file.\n\nThe format of the connection URL that Mongoose uses is similar to the one Prisma ORM uses.\n\n.env\n\n```\nDATABASE_URL=\"mongodb://alice:myPassword43@localhost:27017/blog-mongoose\"\n```\n\nRefer to the [MongoDB connection URL specification](https://www.mongodb.com/docs/manual/reference/connection-string/#connection-string-options) for further details.\n\n### 2.3. Run Prisma ORM's introspection[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#23-run-prisma-orms-introspection \"Direct link to 2.3. Run Prisma ORM's introspection\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\n> **Note**: MongoDB is a _schemaless_ database. To incrementally adopt Prisma ORM in your project, ensure your database is populated with sample data. Prisma ORM introspects a MongoDB schema by sampling data stored and inferring the schema from the data in the database.\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String}model posts {  id         String   @id @default(auto()) @map(\"_id\") @db.ObjectId  v          Int      @map(\"__v\")  author     String   @db.ObjectId  categories String[] @db.ObjectId  content    String  published  Boolean  title      String}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?}\n```\n\nThe generated Prisma models represent the MongoDB collections and are the foundation of your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Update the relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#24-update-the-relations \"Direct link to 2.4. Update the relations\")\n\nMongoDB doesn't support relations between different collections. However, you can create references between documents using the [`ObjectId`](https://www.prisma.io/docs/orm/overview/databases/mongodb#using-objectid) field type or from one document to many using an array of `ObjectIds` in the collection. The reference will store id(s) of the related document(s). You can use the `populate()` method that Mongoose provides to populate the reference with the data of the related document.\n\nUpdate the 1-n relationship between `Post` <-> `User` as follows:\n\n*   Rename the existing `author` reference in the `posts` model to `authorId` and add the `@map(\"author\")` attribute\n*   Add the `author` relation field in the `posts` model and it's `@relation` attribute specifying the `fields` and `references`\n*   Add the `posts` relation in the `users` model\n\n*   diff\n*   schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String}model posts {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean  v         Int     @map(\"__v\")  -  author     String   @db.ObjectId  +  author     users  @relation(fields: [authorId], references: [id])  +  authorId   String @map(\"author\") @db.ObjectId  categories String[] @db.ObjectId}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?  +  posts   posts[]}\n```\n\nUpdate the m-n between `Post` <-> `Category` references as follows:\n\n*   Rename the `categories` field to `categoryIds` and map it using `@map(\"categories\")` in the `posts` model\n*   Add a new `categories` relation field in the `posts` model\n*   Add the `postIds` scalar list field in the `categories` model\n*   Add the `posts` relation in the `categories` model\n*   Add a [relation scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) on both models\n*   Add the `@relation` attribute specifying the `fields` and `references` arguments on both sides\n\n*   diff\n*   schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String  +  posts    posts[]  @relation(fields: [postIds], references: [id])  +  postIds String[] @db.ObjectId}model posts {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean  v         Int     @map(\"__v\")  author   users  @relation(fields: [authorId], references: [id])  authorId String @map(\"author\") @db.ObjectId  -  categories  String[] @db.ObjectId  +  categories  categories[] @relation(fields: [categoryIds], references: [id])  +  categoryIds String[] @map(\"categories\") @db.ObjectId}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?  posts   posts[]}\n```\n\n### 2.5 Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#25-adjust-the-prisma-schema-optional \"Direct link to 2.5 Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database collections. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nSome of these adjustments are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of Prisma models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by [_mapping_](https://www.prisma.io/docs/orm/overview/databases/mongodb#using-objectid) the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`, respectively.\n\ntip\n\nYou can use the [rename symbol](https://code.visualstudio.com/docs/editor/refactoring#_rename-symbol) operation to refactor model names by highlighting the model name, pressing F2, and finally typing the desired name. This will rename all instances where it is referenced and add the `@@map()` attribute to the existing model with its former name.\n\nIf your schema includes a [`versionKey`](https://mongoosejs.com/docs/guide.html#versionKey), update it by adding the `@default(0)` and `@ignore` attributes to the `v` field. This means the field will be excluded from the generated Prisma Client and will have a default value of 0. Prisma ORM does not handle document versioning.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, the `post` field on the `user` model is a _list_, so a better name for this field would be `posts` to indicate that it's plural.\n\nUpdate the `published` field by including the `@default` attribute to define the default value of the field.\n\nYou can also rename the `UserProfile` composite type to `Profile`.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}type Profile {  bio String}model Category {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  name String  v    Int    @default(0) @map(\"__v\") @ignore  posts    Post[]   @relation(fields: [post_ids], references: [id])  post_ids String[] @db.ObjectId  @@map(\"categories\")}model Post {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean @default(false)  v         Int     @default(0) @map(\"__v\") @ignore  author   User   @relation(fields: [authorId], references: [id])  authorId String @map(\"author\") @db.ObjectId  categories  Category[] @relation(fields: [categoryIds], references: [id])  categoryIds String[]   @db.ObjectId  @@map(\"posts\")}model User {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int      @default(0) @map(\"__v\") @ignore  email   String   @unique(map: \"email_1\")  name    String  profile Profile?  posts   Post[]  @@map(\"users\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Mongoose:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your Mongoose queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-4-replace-your-mongoose-queries-with-prisma-client \"Direct link to Step 4. Replace your Mongoose queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Mongoose to Prisma Client, based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Mongoose, check out the [Mongoose and Prisma API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers, create a new file named `prisma.js` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()module.exports = prisma\n```\n\nThe imports in our controller files are as follows:\n\nsrc/controllers/post.js\n\n```\nconst Post = require('../models/post')const User = require('../models/user')const Category = require('../models/category')\n```\n\nsrc/controllers/user.js\n\n```\nconst Post = require('../models/post')const User = require('../models/user')\n```\n\nYou'll update the controller imports as you migrate from Mongoose to Prisma:\n\nsrc/controllers/post.js\n\n```\nconst prisma = require('../prisma')\n```\n\nsrc/controllers/user.js\n\n```\nconst prisma = require('../prisma')\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe example REST API used in this guide has four routes that accept `GET` requests:\n\n*   `/feed?searchString={searchString}&take={take}&skip={skip}`: Return all published posts\n    *   Query Parameters (optional):\n        *   `searchString`: Filter posts by `title` or `content`\n        *   `take`: Specifies how many objects should be returned in the list\n        *   `skip`: Specifies how many of the returned objects should be skipped\n*   `/post/:id`: Returns a specific post\n*   `/authors`: Returns a list of authors\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#feed \"Direct link to feed\")\n\nThe `/feed` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const { searchString, skip, take } = req.query    const or =      searchString !== undefined        ? {            $or: [              { title: { $regex: searchString, $options: 'i' } },              { content: { $regex: searchString, $options: 'i' } },            ],          }        : {}    const feed = await Post.find(      {        ...or,        published: true,      },      null,      {        skip,        batchSize: take,      }    )      .populate({ path: 'author', model: User })      .populate('categories')    return res.status(200).json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that each returned `Post` object includes the relation to the `author` and `category` with which it is associated. With Mongoose, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the JavaScript compiler does not provide any safety here.\n\nHere is how the same route handler is implemented using Prisma Client:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const { searchString, skip, take } = req.query    const or = searchString      ? {          OR: [            { title: { contains: searchString } },            { content: { contains: searchString } },          ],        }      : {}    const feed = await prisma.post.findMany({      where: {        published: true,        ...or,      },      include: { author: true, categories: true },      take: Number(take) || undefined,      skip: Number(skip) || undefined,    })    return res.status(200).json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that the way in which Prisma Client includes the `author` relation is absolutely type-safe. The JavaScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/post/:id`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postid \"Direct link to postid\")\n\nThe `/post/:id` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { id } = req.params  try {    const post = await Post.findById(id)      .populate({ path: 'author', model: User })      .populate('categories')    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { id } = req.params  try {    const post = await prisma.post.findUnique({      where: { id },      include: {        author: true,        category: true,      },    })    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `User` record\n*   `/user/:id/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#user \"Direct link to user\")\n\nThe `/user` handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await User.create({      name,      email,    })    return res.status(201).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await prisma.user.create({      data: {        name,        email,      },    })    return res.status(201).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#post \"Direct link to post\")\n\nThe `/post` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const author = await User.findOne({ email: authorEmail })    if (!author) return res.status(404).json({ message: 'Author not found' })    const draft = await Post.create({      title,      content,      author: author._id,    })    res.status(201).json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const draft = await prisma.post.create({      data: {        title,        content,        author: {          connect: {            email: authorEmail,          },        },      },    })    res.status(201).json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Prisma Client's nested write here saves the initial query where the `User` record is first retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:id/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#useridprofile \"Direct link to useridprofile\")\n\nThe `/user/:id/profile` handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await User.findByIdAndUpdate(      id,      {        profile: {          bio,        },      },      { new: true }    )    if (!user) return res.status(404).json({ message: 'Author not found' })    return res.status(200).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: { id },      data: {        profile: {          bio,        },      },    })    if (!user) return res.status(404).json({ message: 'Author not found' })    return res.status(200).json(user)  } catch (error) {    console.log(error)    return res.status(500).json(error)  }}\n```\n\nAlternatively, you can use the `set` property to update the value of an embedded document as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: {        id,      },      data: {        profile: {          set: { bio },        },      },    })    return res.status(200).json(user)  } catch (error) {    console.log(error)    return res.status(500).json(error)  }}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has two routes that accept a `PUT` request:\n\n*   `/post/:id/:categoryId`: Adds the post with `:id` to the category with `:categoryId`\n*   `/post/:id`: Updates the `published` status of a post to true.\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/post/:id/:categoryId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postidcategoryid \"Direct link to postidcategoryid\")\n\nThe `/post/:id/:categoryId` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { id, categoryId } = req.params  try {    const category = await Category.findById(categoryId)    if (!category)      return res.status(404).json({ message: 'Category not found' })    const post = await Post.findByIdAndUpdate(      { _id: id },      {        categories: [{ _id: categoryId }],      },      { new: true }    )    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { id, categoryId } = req.query  try {    const post = await prisma.post.update({      where: {        id,      },      data: {        categories: {          connect: {            id: categoryId,          },        },      },    })    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    console.log({ error })    return res.status(500).json(error)  }}\n```\n\n#### `/post/:id`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postid-1 \"Direct link to postid-1\")\n\nThe `/post/:id` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst publishDraft = async (req, res) => {  const { id } = req.params  try {    const post = await Post.findByIdAndUpdate(      { id },      { published: true },      { new: true }    )    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst publishDraft = async (req, res) => {  const { id } = req.params  try {    const post = await prisma.post.update({      where: { id },      data: { published: true },    })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#more \"Direct link to More\")\n\n### Embedded documents `_id` field[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#embedded-documents-_id-field \"Direct link to embedded-documents-_id-field\")\n\nBy default, Mongoose assigns each document and embedded document an `_id` field. If you wish to disable this option for embedded documents, you can set the `_id` option to false.\n\n```\nconst ProfileSchema = new Schema(  {    bio: String,  },  {    _id: false,  })\n```\n\n### Document version key[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#document-version-key \"Direct link to Document version key\")\n\nMongoose assigns each document a version when created. You can disable Mongoose from versioning your documents by setting the `versionKey` option of a model to false. It is [not recommended](http://aaronheckmann.blogspot.com/2012/06/mongoose-v3-part-1-versioning.html) to disable this unless you are an advanced user.\n\n```\nconst ProfileSchema = new Schema(  {    bio: String,  },  {    versionKey: false,  })\n```\n\nWhen migrating to Prisma ORM, mark the `versionKey` field as optional ( **?** ) in your Prisma schema and add the `@ignore` attribute to exclude it from Prisma Client.\n\n### Collection name inference[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#collection-name-inference \"Direct link to Collection name inference\")\n\nMongoose infers the collection names by automatically converting the model names to lowercase and plural form.\n\nOn the other hand, Prisma ORM maps the model name to the table name in your database [modeling your data](https://www.prisma.io/docs/orm/prisma-schema/data-model/models).\n\nYou can enforce the collection name in Mongoose to have the same name as the model by setting the [](https://mongoosejs.com/docs/guide.html#collection)option while creating your schema\n\n```\nconst PostSchema = new Schema(  {    title: String,    content: String,    // more fields here  },  {    collection: 'Post',  })\n```\n\n### Modeling relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#modeling-relations \"Direct link to Modeling relations\")\n\nYou can model relations in Mongoose between documents by either using [sub-documents](https://mongoosejs.com/docs/subdocs.html) or storing [a reference to other documents](https://mongoosejs.com/docs/queries.html#refs).\n\nPrisma ORM allows you to model different types of relations between documents when working with MongoDB:\n\n*   [One-to-one relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mongodb)\n*   [One-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#mongodb)\n*   [Many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb)\n*   [Self-relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#mongodb)\n*   [Embedded documents](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types)",
    "title": "How to migrate from Mongoose to Prisma ORM | Prisma Documentation",
    "description": "Learn how to migrate from Mongoose to Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle",
    "markdown": "# How to migrate from Drizzle to Prisma ORM\n\nThis guide describes how to migrate from Drizzle to Prisma ORM. It uses a sample project based off of the [Drizzle Next.js example](https://orm.drizzle.team/learn/tutorials/drizzle-nextjs-neon) as a [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-drizzle-to-prisma).\n\nnote\n\nthis migration guide uses Neon PostgreSQL as the example database, but it equally applies to any other relational database that are [supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to Drizzle on the [Prisma ORM vs Drizzle](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Drizzle to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your Drizzle queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Drizzle for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Drizzle to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Drizzle to Prisma ORM.\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma to your database. Run the following command in the root of your project to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nnote\n\nyou may already have a `.env` file. If so, the `prisma init` command will append lines to it rather than creating a new file.\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Drizzle and Prisma ORM use the same format for connection URLs, so your existing connection URL should work fine.\n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nIf you're using the [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) the following model would be created:\n\nprisma/schema.prisma\n\n```\nmodel todo {  id   Int     @id  text String  done Boolean @default(false)}\n```\n\nThe generated Prisma model represents a database table. Prisma models are the foundation for your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#25-adjust-the-prisma-schema-optional \"Direct link to 2.5. Adjust the Prisma schema (optional)\")\n\nModels that are generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current camelCase notation of Drizzle models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nHere's an example on how you could modify the model above:\n\nprisma/schema.prisma\n\n```\nmodel Todo {  id   Int     @id  text String  done Boolean @default(false)  @@map(\"todo\")}\n```\n\n## Step 3. Install and generate Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-3-install-and-generate-prisma-client \"Direct link to Step 3. Install and generate Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Drizzle:\n\n```\nnpm install @prisma/client\n```\n\nAfter installing, you need to run `generate` in order to have your schema reflected in TypeScript types and autocomplete.\n\n## Step 4. Replace your Drizzle queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-4-replace-your-drizzle-queries-with-prisma-client \"Direct link to Step 4. Replace your Drizzle queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Drizzle to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Drizzle, check out the [comparison page](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle).\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.ts` in the `db` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\ndb/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'export const prisma = new PrismaClient()\n```\n\n### 4.1. Replacing `getData` queries[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#41-replacing-getdata-queries \"Direct link to 41-replacing-getdata-queries\")\n\nThe fullstack Next.js app has several `actions` including `getData`.\n\nThe `getData` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const getData = async () => {  const data = await db.select().from(todo);  return data;};\n```\n\nHere is the same action implemented using Prisma Client:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { prisma } from \"@/db/prisma\";export const getData = async () => {  const data = await prisma.todo.findMany();  return data;};\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) has four actions that are utilized during `POST` requests:\n\n*   `addTodo`: Creates a new `Todo` record\n*   `deleteTodo`: Deletes an existing `Todo` record\n*   `toggleTodo`: Toggles the boolean `done` field on an existing `Todo` record\n*   `editTodo`: Edits the `text` field on an existing `Todo` record\n\n#### `addTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#addtodo \"Direct link to addtodo\")\n\nThe `addTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const addTodo = async (id: number, text: string) => {  await db.insert(todo).values({    id: id,    text: text,  });  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const addTodo = async (id: number, text: string) => {  await prisma.todo.create({    data: { id, text },  })  revalidatePath(\"/\");};\n```\n\n#### `deleteTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#deletetodo \"Direct link to deletetodo\")\n\nThe `deleteTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const deleteTodo = async (id: number) => {  await db.delete(todo).where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const deleteTodo = async (id: number) => {  await prisma.todo.delete({ where: { id } });  revalidatePath(\"/\");};\n```\n\n#### `toggleTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#toggletodo \"Direct link to toggletodo\")\n\nThe `ToggleTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq, not } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const toggleTodo = async (id: number) => {  await db    .update(todo)    .set({      done: not(todo.done),    })    .where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const toggleTodo = async (id: number) => {  const todo = await prisma.todo.findUnique({ where: { id } });  if (todo) {    await prisma.todo.update({      where: { id: todo.id },      data: { done: !todo.done },    })    revalidatePath(\"/\");  }};\n```\n\nNote that Prisma ORM does not have the ability to edit a boolean field \"in place\", so the record must be fetched before hand.\n\n#### `editTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#edittodo \"Direct link to edittodo\")\n\nThe `editTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const editTodo = async (id: number, text: string) => {  await db    .update(todo)    .set({      text: text,    })    .where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const editTodo = async (id: number, text: string) => {  await prisma.todo.update({    where: { id },    data: { text },  })  revalidatePath(\"/\");};\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#more \"Direct link to More\")\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nUnlike Drizzle, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example comparing Drizzle with Prisma ORM:\n\nschema.ts\n\n```\nimport { boolean, integer, pgTable, serial, text } from \"drizzle-orm/pg-core\";export const posts = pgTable('post', {  id: serial('serial').primaryKey(),  title: text('title').notNull(),  content: text('content'),  published: boolean('published').default(false).notNull(),});export const categories = pgTable('category', {  id: serial('serial').primaryKey(),  name: text('name').notNull(),});export const postsToCategories = pgTable('posts_to_categories', {  postId: integer('post_id').notNull().references(() => users.id),  categoryId: integer('category_id').notNull().references(() => chatGroups.id),});\n```\n\nThis schema is equivalent to the following Prisma schema:\n\nschema.prisma\n\n```\nmodel Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  postsToCategories PostToCategories[]  @@map(\"post\")}model Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId])  @@index([categoryId])  @@map(\"posts_to_categories\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled _explicitly_ via the relation table `PostToCategories`.\n\nBy instead adhering to the conventions for Prisma ORM relation tables, the relation could look as follows:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  content    String?  published  Boolean    @default(false)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostToCategories` model first.\n\nwarning\n\nIf your database provider requires tables to have primary keys then you have to use explicit syntax, and manually create the join model with a primary key. This is because relation tables (JOIN tables) created by Prisma ORM (expressed via `@relation`) for many-to-many relations using implicit syntax do not have primary keys.",
    "title": "How to migrate from Drizzle to Prisma ORM | Prisma Documentation",
    "description": "Learn how to migrate from Drizzle to Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize",
    "markdown": "# How to migrate from Sequelize to Prisma ORM\n\nThis guide describes how to migrate from Sequelize to Prisma ORM. It uses an extended version of the [Sequelize Express example](https://github.com/sequelize/express-example) as a [sample project](https://github.com/prisma/migrate-from-sequelize-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-sequelize-to-prisma).\n\nThis migration guide uses PostgreSQL as the example database, but it equally applies to any other relational database that's [supported by Prisma](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to Sequelize on the [Prisma ORM vs Sequelize](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Sequelize to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your Sequelize queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Sequelize for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Sequelize to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Sequelize to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-sequelize-to-prisma) to migrate to Prisma ORM. It has four models/entities:\n\n*   User.js\n*   Post.js\n*   Profile.js\n*   Category.js\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const User = sequelize.define('User', {    name: {      type: DataTypes.STRING,    },    email: {      type: DataTypes.STRING,      unique: true,      allowNull: false,    },  })  User.associate = (models) => {    User.hasMany(models.Post, {      foreignKey: 'authorId',      as: 'posts',    })    User.hasOne(models.Profile, {      onDelete: 'CASCADE',      foreignKey: 'userId',    })  }  return User}\n```\n\nThe models have the following relations:\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n\nThe corresponding tables have been created using a generated Sequelize migration.\n\nIn this guide, the route handlers are located in the `src/controllers` directory. The models are located in the `src/models` directory. From there, they are pulled into a central `src/routes.js` file which is used to set up the required routes in `src/index.js`:\n\n```\n└── blog-sequelize    ├── package.json    └──src        ├── controllers        │   ├── post.js        │   └── user.js        ├── models        │   ├── Category.js        │   ├── Post.js        │   ├── Profile.js        │   └── User.js        ├── index.js        └── routes.js\n```\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma ORM to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Here's how the database connection from Sequelize maps to the connection URL format used by Prisma ORM:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nAssume you have the following database connection details in `src/models/index.js`:\n\nsrc/models/index.js\n\n```\nconst sequelize = new Sequelize('blog-sequelize', 'alice', 'myPassword42', {  host: 'localhost',  dialect: 'postgres',})\n```\n\nThe respective connection URL would look as follows in Prisma ORM:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-sequelize\"\n```\n\nNote that you can optionally configure the PostgreSQL [schema](https://www.postgresql.org/docs/9.1/ddl-schemas.html) by appending the `schema` argument to the connection URL:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-sequelize?schema=myschema\"\n```\n\nIf not provided, the default schema called `public` is being used.\n\n  \n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime  updatedAt      DateTime  PostCategories PostCategories[]}model PostCategories {  createdAt  DateTime  updatedAt  DateTime  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime  updatedAt      DateTime  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]}model Profiles {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime  updatedAt DateTime  userId    Int?     @unique  Users     Users?   @relation(fields: [userId], references: [id])}model SequelizeMeta {  name String @id}model Users {  id        Int       @id @default(autoincrement())  name      String?  email     String    @unique  createdAt DateTime  updatedAt DateTime  Posts     Posts[]  Profiles  Profiles?}\n```\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust `createdAt` and `updatedAt` fields[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#25-adjust-createdat-and-updatedat-fields \"Direct link to 25-adjust-createdat-and-updatedat-fields\")\n\nThe generated Prisma models represent your database tables and are the foundation for your programmatic Prisma Client API which allows you to send queries to your database. You'll adjust the `createdAt` and `updatedAt` fields in our models. Sequelize doesn't add the `DEFAULT` constraint to `createdAt` when creating the tables in the database. Therefore, you'll add `@default(now())` and `@updatedAt` attributes to the `createdAt` and `updatedAt` columns respectively. To learn more how Prisma ORM does this, you can read more [`@default(now())`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now) and [`@updatedAt`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat) here. Our updated schema will be as follows:\n\nprisma/schema.prisma\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime         @default(now())  updatedAt      DateTime         @updatedAt  PostCategories PostCategories[]}model PostCategories {  createdAt  DateTime   @default(now())  updatedAt  DateTime   @updatedAt  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime         @default(now())  updatedAt      DateTime         @updatedAt  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]}model Profiles {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  userId    Int?     @unique  Users     Users?   @relation(fields: [userId], references: [id])}model SequelizeMeta {  name String @id}model Users {  id        Int       @id @default(autoincrement())  name      String?  email     String    @unique  createdAt DateTime  @default(now())  updatedAt DateTime  @updatedAt  Posts     Posts[]  Profiles  Profiles?}\n```\n\n### 2.6. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#26-adjust-the-prisma-schema-optional \"Direct link to 2.6. Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of Prisma models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, although we are singularizing the `Posts` model name to `Post`, the `posts` field on the `user` model is a _list_, so it makes sense to keep that named `posts` to indicate that it's plural.\n\nSequelize generates a `SequelizeMeta` model that is used internally by the library that is not needed. Therefore, you'll manually delete it from the schema.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model Category {  id             Int                @id @default(autoincrement())  name           String  createdAt      DateTime           @default(now())  updatedAt      DateTime           @updatedAt  postCategories PostToCategories[]  @@map(\"Categories\")}model PostToCategories {  createdAt  DateTime @default(now())  updatedAt  DateTime @updatedAt  categoryId Int  postId     Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([categoryId, postId])  @@map(\"PostCategories\")}model Post {  id               Int                @id @default(autoincrement())  title            String  content          String?  published        Boolean?           @default(false)  createdAt        DateTime           @default(now())  updatedAt        DateTime           @updatedAt  authorId         Int?  author           User?              @relation(fields: [authorId], references: [id])  postToCategories PostToCategories[]  @@map(\"Posts\")}model Profile {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  userId    Int?     @unique  user      User?    @relation(fields: [userId], references: [id])  @@map(\"Profiles\")}model User {  id        Int      @id @default(autoincrement())  name      String?  email     String   @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  posts     Post[]  profile   Profile?  @@map(\"Users\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Sequelize:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your Sequelize queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-4-replace-your-sequelize-queries-with-prisma-client \"Direct link to Step 4. Replace your Sequelize queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Sequelize to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Sequelize, check out the [API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#api-comparison) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.js` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()module.exports = prisma\n```\n\nThe imports in our controller files are as follows:\n\nsrc/controllers/post.js\n\n```\nconst { Post, User, Category } = require('../models')const { Op } = require('sequelize')\n```\n\nsrc/controllers/user.js\n\n```\nconst { User } = require('../models')\n```\n\nYou'll update the controller imports as you migrate from Sequelize to Prisma:\n\nsrc/controllers/post.js\n\n```\nconst prisma = require('../prisma')\n```\n\nsrc/controllers/user.js\n\n```\nconst prisma = require('../prisma')\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe REST API has four routes that accept `GET` requests:\n\n*   `/feed`: Return all published posts\n*   `/filterPosts?searchString=SEARCH_STRING`: Filter returned posts by `SEARCH_STRING`\n*   `/post/:postId`: Returns a specific post\n*   `/authors`: Returns a list of authors\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#feed \"Direct link to feed\")\n\nThe `/feed` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const feed = await Post.findAll({      where: { published: true },      include: ['author', 'categories'],    })    return res.json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that each returned `Post` object includes the relation to the `author` and `category` it's associated with. With Sequelize, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the JavaScript compiler does not provide any safety here.\n\nHere is how the same route is implemented using Prisma Client:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const feed = await prisma.post.findMany({      where: { published: true },      include: { author: true, postToCategories: true },    })    return res.json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that the way how Prisma Client includes the `author` relation is absolutely type-safe. The JavaScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/filterPosts?searchString=SEARCH_STRING`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#filterpostssearchstringsearch_string \"Direct link to filterpostssearchstringsearch_string\")\n\nThe `/filterPosts` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst filterPosts = async (req, res) => {  const { searchString } = req.query  try {    const filteredPosts = await Post.findAll({      where: {        [Op.or]: [          {            title: {              [Op.like]: `%${searchString}%`,            },          },          {            content: {              [Op.like]: `%${searchString}%`,            },          },        ],      },      include: 'author',    })    res.json(filteredPosts)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst filterPosts = async (req, res) => {  const { searchString } = req.query  try {    const filteredPosts = prisma.post.findMany({      where: {        OR: [          {            title: { contains: searchString },          },          {            content: { contains: searchString },          },        ],      },    })    res.json(filteredPosts)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Sequelize provides [Operator symbols](https://sequelize.org/master/variable/index.html#static-variable-Op) - `Op` - to be used when querying data. Prisma ORM on the other hand [combines several `where` conditions with an implicit `AND` operator](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and), so in this case the Prisma Client query needs to make the `OR` explicit.\n\n#### `/post/:postId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#postpostid \"Direct link to postpostid\")\n\nThe `/post/:postId` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { postId } = req.params  try {    const post = await Post.findOne({      where: { id: postId },      include: 'author',    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { postId } = req.params  try {    const post = await prisma.post.findUnique({      where: { id: Number(postId) },      include: { author: true },    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `User` record\n*   `/user/:userId/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#user \"Direct link to user\")\n\nThe `/user` handler is currently implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await User.create({      name,      email,    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await prisma.user.create({      data: {        name,        email,      },    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#post \"Direct link to post\")\n\nThe `/post` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const user = await User.findOne({ email: authorEmail })    const draft = await Post.create({      title,      content,      authorId: user.id,    })    res.json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const draft = await prisma.post.create({      data: {        title,        content,        author: {          connect: { email: authorEmail },        },      },    })    res.json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Prisma Client's nested write here save an initial query where first the `User` record needs to be retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:userId/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#useruseridprofile \"Direct link to useruseridprofile\")\n\nThe `/user/:userId/profile` handler is currently implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { userId } = req.params  const { bio } = req.body  try {    const user = await User.findOne({      where: {        id: Number(userId),      },    })    const updatedUser = await user.createProfile({ bio })    return res.json(updatedUser)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { userId } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: { id: Number(userId) },      data: {        profile: {          create: { bio },        },      },    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has one route that accept a `PUT` request:\n\n*   `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`: Adds the post with `POST_ID` to the category with `CATEGORY_ID`\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#addposttocategorypostidpost_idcategoryidcategory_id \"Direct link to addposttocategorypostidpost_idcategoryidcategory_id\")\n\nThe `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { postId, categoryId } = req.query  try {    const post = await Post.findOne({      where: { id: postId },    })    const category = await Category.findOne({      where: { id: categoryId },    })    const updatedPost = await post.addCategory(category)    return res.json(updatedPost)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { postId, categoryId } = req.query  try {    const post = await prisma.post.update({      data: {        postToCategories: {          create: {            categories: {              connect: { id: Number(categoryId) },            },          },        },      },      where: {        id: Number(postId),      },    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that this Prisma Client can be made less verbose by modeling the relation as an [implicit many-to-many relation](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#implicit-many-to-many-relations) instead. In that case, the query would look as follows:\n\nsrc/controllers/posts.js\n\n```\nconst post = await prisma.post.update({  data: {    category: {      connect: { id: categoryId },    },  },  where: { id: postId },})\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#more \"Direct link to More\")\n\n### Primary key column[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#primary-key-column \"Direct link to Primary key column\")\n\nBy default, Sequelize defines a `primaryKey` and used `id` with the autoby default if not defined. This is optional. If you would like to set your own primary key, you can use the `primaryKey: true` and define your preferred data type in your field of choice:\n\n```\n// changing the primary key columnmodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    postId: {      type: DataTypes.INTEGER,      primaryKey: true,    },  })  return Post}// changing the id DataTypemodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    id: {      type: DataTypes.UUID, // alternative: DataTypes.STRING      primaryKey: true,    },  })  return Post}\n```\n\n### Table name inference[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#table-name-inference \"Direct link to Table name inference\")\n\nSequelize infers table names from the model name. When the name of a table isn't provided Sequelize automatically pluralizes the model name and uses that as the table name using a library called [inflection](https://www.npmjs.com/package/inflection). Prisma ORM on the other hand maps the model name to the table name in your database [modelling your data](https://www.prisma.io/docs/orm/prisma-schema/data-model/models). If you wish to change this default behaviour in Sequelize, you can either enforce the table name to be equal to the model name or provide the table name directly:\n\n```\n// enforcing table name to be equal to model namemodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define(    'Post',    {      // ... attributes    },    {      freezeTableName: true,    }  )  return Post}\n```\n\n```\n// providing the table name directlymodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define(    'Post',    {      // ... attributes    },    {      tableName: 'Post',    }  )  return Post}\n```\n\n### Timestamps[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#timestamps \"Direct link to Timestamps\")\n\nSequelize automatically adds the fields `createdAt` and `updatedAt` to every model using the data type `DataTypes.DATE`, by default. You can disable this for a model with the `timestamps: false` option:\n\n```\nsequelize.define(  'User',  {    // ... (attributes)  },  {    timestamps: false,  })\n```\n\nPrisma ORM offers you the flexibility to define these fields in your model. You add the `createdAt` and [`updatedAt`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat) fields by defining them explicitly in your model. To set the `createdAt` field in your model, add the `default(now())` attribute to the column. In order to set the `updatedAt` column, update your model by adding the `@updatedAt` attribute to the column.\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  name      String?  email     String   @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nSimilar to the `belongsToMany()` association method in Sequelize, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example with Sequelize:\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    title: {      type: DataTypes.STRING,      allowNull: false,    },    content: {      type: DataTypes.STRING,    },    published: {      type: DataTypes.BOOLEAN,      defaultValue: false,    },  })  Post.associate = (models) => {    Post.belongsTo(models.User, {      foreignKey: 'authorId',      as: 'author',    })    Post.belongsToMany(models.Category, {      through: 'PostCategories',      as: 'categories',    })  }  return Post}\n```\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const Category = sequelize.define('Category', {    name: {      type: DataTypes.STRING,      allowNull: false,    },  })  Category.associate = (models) => {    Category.belongsToMany(models.Post, {      through: 'PostCategories',      as: 'posts',    })  }  return Category}\n```\n\nWhen you start your application, Sequelize will create the the tables for you - based on these models:\n\n```\nExecuting (default): CREATE TABLE IF NOT EXISTS \"PostCategories\"(\"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\"CategoryId\" INTEGER  REFERENCES \"Categories\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\"PostId\" INTEGER  REFERENCES \"Posts\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (\"CategoryId\",\"PostId\"));\n```\n\nIf you introspect the database with Prisma ORM, you'll get the following result in the Prisma schema (note that some relation field names have been adjusted to look friendlier compared to the raw version from introspection):\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime  updatedAt      DateTime  PostCategories PostCategories[]  @@map(\"category\")}model PostCategories {  createdAt  DateTime  updatedAt  DateTime  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])  @@map(\"PostCategories\")}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime  updatedAt      DateTime  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]  @@map(\"post\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled explicitly via the relation table `PostCategories`\n\nBy adhering to the conventions for Prisma relation tables, the relation could look as follows:\n\n```\nmodel Categories {  id    Int     @id @default(autoincrement())  name  String  posts Posts[]  @@map(\"category\")}model Posts {  id         Int          @id @default(autoincrement())  title      String  content    String?  published  Boolean      @default(false)  authorId   Int?  author     User?        @relation(fields: [authorId], references: [id])  categories Categories[]  @@map(\"post\")}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostCategories` model first.",
    "title": "How to migrate from Sequelize to Prisma ORM | Prisma Documentation",
    "description": "Learn how to migrate from Sequelize to Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle",
    "markdown": "# Prisma ORM vs Drizzle | Prisma Documentation\n\nThis page compares Prisma ORM and Drizzle.\n\n## Drizzle vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#drizzle-vs-prisma-orm \"Direct link to Drizzle vs Prisma ORM\")\n\nWhile Prisma ORM and Drizzle solve similar problems, they work in very different ways and have individual pros and cons. Which one to choose will depend on the needs of your project and the exact tradeoffs that are important for it.\n\n**Drizzle** is a traditional SQL query builder that lets you compose SQL queries with JavaScript/TypeScript functions. It can be used to query a database or run migrations. Drizzle also offers a Queries API, which offers a higher level abstraction from SQL and can be used to read nested relations. Drizzle schema is defined in TypeScript files, which are used to generate SQL migrations and are then executed against a database.\n\n**Prisma ORM** mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading. It uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows the generation of SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## Type safety[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#type-safety \"Direct link to Type safety\")\n\nDrizzle is not _fully_ type safe. As quoted on this [comparison study](https://github.com/thetutlage/meta/discussions/8) done by a 3rd party, \"Drizzle gives the impression of type-safety. However, only the query results have type information. You can write invalid queries with Drizzle.\"\n\nWith Prisma, you get _full_ type safety thanks to the generated types. This means, less potential for errors when writing code and collaborating with team members.\n\n## API design & Level of abstraction[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#api-design--level-of-abstraction \"Direct link to API design & Level of abstraction\")\n\nDrizzle and Prisma ORM operate on different levels of abstraction. Drizzle's philosophy is \"If you know SQL, you know Drizzle ORM\". It mirrors SQL in its API while Prisma Client provides a higher-level abstraction that was designed with the common tasks of application developers in mind. Prisma ORM's API design heavily leans on the idea of [making the right thing easy](https://jason.energy/right-thing-easy-thing/).\n\nWhile Prisma Client operates on a higher level of abstraction, you are able to drop down to [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) at any time. However, full use of Prisma ORM and development of your application does not require SQL knowledge. Prisma ORM's goal is to construct a query syntax focused on developer experience and productivity that feels familiar to developers. You can learn more about this here: [Why Prisma](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#application-developers-should-care-about-data--not-sql).\n\nThe following sections examine a few examples of how Prisma ORM's and Drizzle's APIs differ in certain scenarios and what the rationale of Prisma ORM's API design is in these cases.\n\n### Data modeling[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#data-modeling \"Direct link to Data modeling\")\n\nPrisma models are defined in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema), while Drizzle uses TypeScript functions for table definitions. These functions are then exported and used in queries.\n\nPrisma generates a lightweight database client that exposes a tailored and fully type-safe API to read and write data for the models that are defined in the Prisma schema, following the DataMapper ORM pattern.\n\nPrisma ORM's DSL for data modeling is lean, simple and intuitive to use. When modeling data in VS Code, you can further take advantage of Prisma ORM's powerful [VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) with features like autocompletion, quick fixes, jump to definition and other benefits that increase developer productivity. On the other hand, Drizzle's use of TypeScript means that you can lean on the power of TypeScript for additional flexibility (via reused code, for example).\n\n**Prisma ORM**\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  authorId  Int?  author    User?   @relation(fields: [authorId], references: [id])}\n```\n\n**Drizzle**\n\n```\nimport {  boolean,  integer,  pgTable,  serial,  text,  uniqueIndex,  varchar,} from 'drizzle-orm/pg-core'export const users = pgTable('users', {  id: serial('id').primaryKey(),  name: varchar('name', { length: 256 }),  email: varchar('email', { length: 256 }).unique(),})export const posts = pgTable('posts', {  id: serial('id').primaryKey(),  title: varchar('title', { length: 256 }).notNull(),  content: text('content'),  published: boolean('published'),  authorId: integer('author_id').references(() => users.id),})\n```\n\n### Migrations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#migrations \"Direct link to Migrations\")\n\nMigrations work similarly between Drizzle and Prisma ORM. Both tools follow the approach of generating SQL files based on the provided model definitions and provide a CLI to execute them against the database. The SQL files can be modified before the migrations are executed so that any custom database operation can be performed with either migration system.\n\n### Querying[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#querying \"Direct link to Querying\")\n\nPlain queries are natural to construct in both Drizzle and Prisma ORM. Using Drizzle's Queries API, the two approaches are very similar:\n\n**Prisma ORM**\n\n```\n// find all usersconst allUsers = await prisma.user.findMany()// find a single userconst user = await prisma.user.findFirst({  where: { id: 27 },})// find a unique userconst user = await prisma.user.findUnique({  where: { email: 'nilu@prisma.io' },})\n```\n\n**Drizzle**\n\n```\nimport { eq } from 'drizzle-orm'// find all usersconst allUsers = await db.query.users.findMany()// find a single userconst user = await db.query.users.findFirst({  where: eq(users.id, 1),})// find a unique postconst user = await db.query.users.findFirst({  where: eq(users.email, 'nilu@prisma.io'),})\n```\n\nWhen performing a mutation, a `create`, `update`, or `delete`, the Drizzle Queries API is not available. In these cases, you will need to use Drizzle's SQL-like APIs:\n\n**Prisma ORM**\n\n```\n// create a userconst user = await prisma.user.create({  data: {    name: 'Nilu',    email: 'nilu@prisma.io',  },})// update a userconst user = await prisma.user.update({  where: { email: 'nilu@prisma.io' },  data: { name: 'Another Nilu' },})// delete a userconst deletedUser = await prisma.user.delete({  where: { email: 'nilu@prisma.io' },})\n```\n\n**Drizzle**\n\n```\n// create a userconst user = await db.insert(users).values({  name: 'Nilu',  email: 'nilu@prisma.io',})// update a userconst user = await db  .update(users)  .set({ name: 'Another Nilu' })  .where(eq(users.email, 'nilu@prisma.io'))  .returning()// delete a userconst deletedUser = await db  .delete(users)  .where(eq(users.email, 'nilu@prisma.io'))  .returning()\n```\n\n### Relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#relations \"Direct link to Relations\")\n\nWorking with records that are connected via foreign keys can become very complex in SQL. Prisma ORM's concept of [virtual relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) enables an intuitive and convenient way for application developers to work with related data. Some benefits of Prisma ORM's approach are:\n\n*   traversing relationships via the fluent API ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api))\n*   nested writes that enable updating/creating connected records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes))\n*   applying filters on related records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters))\n*   easy and type-safe querying of nested data without worrying about underlying SQL ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads))\n*   creating nested TypeScript typings based on models and their relations ([docs](https://www.prisma.io/docs/orm/prisma-client/type-safety))\n*   intuitive modeling of relations in the data model via relation fields ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations))\n*   implicit handling of relation tables (also sometimes called JOIN, link, pivot or junction tables) ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations))\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  include: {    author: true,  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db.query.posts.findMany({  with: {    author: true,  },})\n```\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#filtering \"Direct link to Filtering\")\n\nDrizzle exposes the underlying filter and conditional operators for a given SQL dialect. Prisma ORM on the other hand, provides a more [generic set of operators](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators) that are intuitive to use.\n\nA good example of how the filtering APIs of both Drizzle and Prisma ORM differ is by looking at `string` filters. While Drizzle provides filters for `like` and `ilike`, Prisma ORM provides more specific operators that developers can use, e.g.: `contains`, `startsWith` and `endsWith`.\n\n**Prisma ORM**\n\n```\n// case sensitive filterconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',  },})// case insensitive filterconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',    mode: 'insensitive',  },})\n```\n\n**Drizzle**\n\n```\n// case sensitive filterconst posts = await db  .select()  .from(posts)  .where(like(posts.title, 'Hello World'))// case insensitive filterconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, 'Hello World'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, '%Hello World%'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      startsWith: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, 'Hello World%'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      endsWith: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, '%Hello World'))\n```\n\nDrizzle only offers limit-offset pagination while Prisma ORM conveniently provides dedicated APIs for both limit-offset but also cursor-based. You can learn more about both approaches in the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) section of the docs.\n\n**Prisma ORM**\n\n```\n// limit-offset paginationconst postPage = await prisma.post.findMany({  where: {    title: 'Hello World',  },  skip: 6,  take: 3,})// cursor-based paginationconst postPage = await prisma.post.findMany({  where: {    title: 'Hello World',  },  cursor: { id: 7 },  take: 3,})\n```\n\n**Drizzle**\n\n```\n// limit-offset pagination (cursor-based not currently possible)const postPage = await db  .select()  .from(users)  .where(ilike(posts.title, 'Hello World%'))  .limit(3)  .offset(6)\n```\n\n### Observability[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#observability \"Direct link to Observability\")\n\nBoth Drizzle and Prisma ORM have the ability to log queries and the underlying SQL generated.\n\nPrisma ORM has additional features built into the client that help teams get a better understanding of their data usage. [Metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) and [tracing](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing) are two features that can be enabled at any time and give you per query information. This information can be integrated with external tools so that you can track performance over time.\n\n## Additional products[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#additional-products \"Direct link to Additional products\")\n\nBoth Drizzle and Prisma offer products alongside an ORM. Prisma Studio was released to allow users to interact with their database via a GUI and also allows for limited self-hosting for use within a team. Drizzle Studio was released to accomplish the same tasks.\n\nIn addition to Prisma Studio, Prisma offers commercial products via the Prisma Data Platform:\n\n*   [Prisma Accelerate](https://prisma.io/data-platform/accelerate): A connection pooler and global cache that integrates with Prisma ORM. Users can take advantage of connection pooling immediately and can control caching at an individual query level.\n*   [Prisma Pulse](https://prisma.io/data-platform/pulse): A change data capture (CDC) service where Prisma Client can subscribe to database changes and receive them in real-time with little to no setup.\n\nThese products work hand-in-hand with Prisma ORM to offer comprehensive data tooling, making building data-driven applications easy by following [Data DX](https://datadx.io/) principles.\n\n## Ecosystem[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#ecosystem \"Direct link to Ecosystem\")\n\nBoth Drizzle and Prisma ORM have cases where users want to do something not directly supported by the library. Drizzle relies on the expressiveness of SQL to avoid these cases, while Prisma ORM has [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to allow any user to add additional behaviors to their instance of Prisma Client. These extensions are also shareable, meaning teams can develop them for use across their projects or even for use by other teams.\n\nWhile Drizzle is a relatively new product, Prisma ORM was [released in 2021](https://www.prisma.io/blog/prisma-the-complete-orm-inw24qjeawmb) and is well established in the JavaScript/TypeScript space. It has proven value and many companies trust [Prisma ORM in production](http://prisma.io/showcase).\n\nPrisma ORM is also included as the data layer tool of choice in many meta-frameworks and development platforms like [Amplication](https://amplication.com/), [Wasp](https://wasp-lang.dev/), [RedwoodJS](https://redwoodjs.com/), [KeystoneJS](https://keystonejs.com/), [Remix](https://remix.run/) and the [t3 stack](https://create.t3.gg/).\n\nThanks to its maturity, Prisma's community has developed a [plethora of useful tools](https://www.prisma.io/ecosystem) that helps with various Prisma workflows. Here are a few highlights:\n\n*   [`zenstack`](https://zenstack.dev/): Toolkit that extends Prisma with access control policies in the Prisma schema, auto-generated CRUD APIs and frontend query hooks.\n*   [`prisma-erd-generator`](https://github.com/keonik/prisma-erd-generator#prisma-entity-relationship-diagram-generator): Visualizes the Prisma schema as an entity-relationship-diagram (ERD).\n*   [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Generates [Zod](https://github.com/colinhacks/zod) schemas from the Prisma schema.\n*   [`bridg`](https://github.com/joeroddy/bridg): Let's you access your database from the frontend using Prisma Client.\n*   [`jest-prisma`](https://github.com/Quramy/jest-prisma): Environment for Prisma integrated testing with [Jest](https://jestjs.io/).\n*   [`prisma-pothos-types`](https://github.com/hayes/pothos/tree/main/packages/plugin-prisma): Creates GraphQL types based on Prisma models when using [GraphQL Pothos](https://github.com/hayes/pothos/tree/main).\n*   [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Creates [tRPC](https://trpc.io/) routers from your Prisma schema.\n*   [`@cerbos/orm-prisma`](https://github.com/cerbos/query-plan-adapters/tree/main/prisma): Filter data based on authorization policies from [Cerbos](https://cerbos.dev/).\n\n## Database support[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#database-support \"Direct link to Database support\")\n\nBoth Drizzle and Prisma ORM support multiple and different kinds of databases. Drizzle achieves this support through driver implementations created by Drizzle, which integrate with existing third-party database drivers.\n\nPrisma ORM has begun adding support for [third-party database drivers](https://www.prisma.io/blog/serverless-database-drivers-KML1ehXORxZV), but primarily uses [built-in drivers](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime) to communicate with an underlying database. Prisma also defaults connections to TLS, which improves security.\n\nAdditionally, Prisma ORM supports CockroachDB, Microsoft SQL Server, and MongoDB, which Drizzle does not currently support. Prisma ORM also offers the [relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode) that allows Prisma ORM to emulate foreign key constraints for those database engines that do not support it. Drizzle currently supports Cloudflare D1, `bun:sqlite`, and SQLite via HTTP Proxy, which Prisma ORM currently does not.\n\n## Benchmarks[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#benchmarks \"Direct link to Benchmarks\")\n\nWe understand that performance is a key consideration when selecting an ORM. To compare performance of various ORMs, you can use the open-source [database latency benchmark tool](https://pris.ly/benchmark) hosted by Vercel.\n\nThis tool allows you to evaluate the latency and throughput of various ORMs under different workloads and configurations. By running the benchmarks against the databases or database providers you are considering, you can get a clear picture of their relative performance characteristics to help make an informed decision.\n\n## Conclusion[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#conclusion \"Direct link to Conclusion\")\n\nBoth Drizzle ORM and Prisma ORM are tools for data access and migrations. Drizzle is focused on being a thin wrapper around a SQL-like syntax while Prisma is focused on a convenient and expressive API. Other important differences include Prisma ORM's support of MSSQL and MongoDB, support for additional features via [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions), additional cloud-ready products, and a robust ecosystem.\n\nFor teams that use SQL daily, Drizzle offers a convenient wrapper that will feel familiar and is type-safe. Prisma ORM's `$queryRaw` feature, while available, does not provide the same level of type safety. However, the experience of writing raw SQL in Prisma ORM can be enhanced using the [SafeQL](https://safeql.dev/compatibility/prisma.html) community plugin for Prisma ORM, offering syntax highlighting and type-checking in your editor as well.\n\nOn the other hand, for teams that are a mix of developers (front-end, back-end, and full-stack) that have varying levels of experience with databases, Prisma ORM offers a comprehensive and easy-to-learn approach for data access and managing database schemas.",
    "title": "Prisma ORM vs Drizzle | Prisma Documentation",
    "description": "Learn how Prisma ORM compares to Drizzle.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm",
    "markdown": "# How to migrate from TypeORM to Prisma ORM\n\nThis guide describes how to migrate from TypeORM to Prisma ORM. It uses an extended version of the [TypeORM Express example](https://github.com/typeorm/typescript-express-example/) as a [sample project](https://github.com/prisma/migrate-from-typeorm-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-typeorm-to-prisma).\n\nThis migration guide uses PostgreSQL as the example database, but it equally applies to any other relational database that's [supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to TypeORM on the [Prisma ORM vs TypeORM](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from TypeORM to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your TypeORM queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses TypeORM for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from TypeORM to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from TypeORM to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-typeorm-to-prisma) to migrate to Prisma ORM. It has four models/entities:\n\n*   User.ts\n*   Post.ts\n*   Profile.ts\n*   Category.ts\n\n```\n@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ nullable: true })  name: string  @Column({ unique: true })  email: string  @OneToMany((type) => Post, (post) => post.author)  posts: Post[]  @OneToOne((type) => Profile, (profile) => profile.user, { cascade: true })  profile: Profile}\n```\n\nThe models have the following relations:\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n\nThe corresponding tables have been created using a generated TypeORM migration.\n\nExpand to view details of the migration\n\nThe migration has been created using\n\n```\ntypeorm migration:generate -n Init\n```\n\nThis created the following migration file:\n\nmigrations/1605698662257-Init.ts\n\n```\nimport { MigrationInterface, QueryRunner } from 'typeorm'export class Init1605698662257 implements MigrationInterface {  name = 'Init1605698662257'  public async up(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(      `CREATE TABLE \"profile\" (\"id\" SERIAL NOT NULL, \"bio\" character varying, \"userId\" integer, CONSTRAINT \"REL_a24972ebd73b106250713dcddd\" UNIQUE (\"userId\"), CONSTRAINT \"PK_3dd8bfc97e4a77c70971591bdcb\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"user\" (\"id\" SERIAL NOT NULL, \"name\" character varying, \"email\" character varying NOT NULL, CONSTRAINT \"UQ_e12875dfb3b1d92d7d7c5377e22\" UNIQUE (\"email\"), CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"post\" (\"id\" SERIAL NOT NULL, \"title\" character varying NOT NULL, \"content\" character varying, \"published\" boolean NOT NULL DEFAULT false, \"authorId\" integer, CONSTRAINT \"PK_be5fda3aac270b134ff9c21cdee\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"category\" (\"id\" SERIAL NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_9c4e4a89e3674fc9f382d733f03\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"post_categories_category\" (\"postId\" integer NOT NULL, \"categoryId\" integer NOT NULL, CONSTRAINT \"PK_91306c0021c4901c1825ef097ce\" PRIMARY KEY (\"postId\", \"categoryId\"))`    )    await queryRunner.query(      `CREATE INDEX \"IDX_93b566d522b73cb8bc46f7405b\" ON \"post_categories_category\" (\"postId\") `    )    await queryRunner.query(      `CREATE INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\" ON \"post_categories_category\" (\"categoryId\") `    )    await queryRunner.query(      `ALTER TABLE \"profile\" ADD CONSTRAINT \"FK_a24972ebd73b106250713dcddd9\" FOREIGN KEY (\"userId\") REFERENCES \"user\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post\" ADD CONSTRAINT \"FK_c6fb082a3114f35d0cc27c518e0\" FOREIGN KEY (\"authorId\") REFERENCES \"user\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" ADD CONSTRAINT \"FK_93b566d522b73cb8bc46f7405bd\" FOREIGN KEY (\"postId\") REFERENCES \"post\"(\"id\") ON DELETE CASCADE ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" ADD CONSTRAINT \"FK_a5e63f80ca58e7296d5864bd2d3\" FOREIGN KEY (\"categoryId\") REFERENCES \"category\"(\"id\") ON DELETE CASCADE ON UPDATE NO ACTION`    )  }  public async down(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" DROP CONSTRAINT \"FK_a5e63f80ca58e7296d5864bd2d3\"`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" DROP CONSTRAINT \"FK_93b566d522b73cb8bc46f7405bd\"`    )    await queryRunner.query(      `ALTER TABLE \"post\" DROP CONSTRAINT \"FK_c6fb082a3114f35d0cc27c518e0\"`    )    await queryRunner.query(      `ALTER TABLE \"profile\" DROP CONSTRAINT \"FK_a24972ebd73b106250713dcddd9\"`    )    await queryRunner.query(`DROP INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\"`)    await queryRunner.query(`DROP INDEX \"IDX_93b566d522b73cb8bc46f7405b\"`)    await queryRunner.query(`DROP TABLE \"post_categories_category\"`)    await queryRunner.query(`DROP TABLE \"category\"`)    await queryRunner.query(`DROP TABLE \"post\"`)    await queryRunner.query(`DROP TABLE \"user\"`)    await queryRunner.query(`DROP TABLE \"profile\"`)  }}\n```\n\nAs mentioned before, this guide is an extended variation of the TypeORM Express example and uses the same file structure. The route handlers are located in the `src/controller` directory. From there, they are pulled into a central `src/routes.ts` file which is used to set up the required routes in `src/index.ts`:\n\n```\n└── blog-typeorm    ├── ormconfig.json    ├── package.json    ├── src    │   ├── controllers    │   │   ├── AddPostToCategoryAction.ts    │   │   ├── CreateDraftAction.ts    │   │   ├── CreateUserAction.ts    │   │   ├── FeedAction.ts    │   │   ├── FilterPostsAction.ts    │   │   ├── GetPostByIdAction.ts    │   │   └── SetBioForUserAction.ts    │   ├── entity    │   │   ├── Category.ts    │   │   ├── Post.ts    │   │   ├── Profile.ts    │   │   └── User.ts    │   ├── index.ts    │   ├── migration    │   │   └── 1605698662257-Init.ts    │   └── routes.ts    └── tsconfig.json\n```\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Here's how the database connection from TypeORM maps to the connection URL format used by Prisma ORM:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nAssume you have the following database connection details in `ormconfig.json`:\n\normconfig.json\n\n```\n{  \"type\": \"postgres\",  \"host\": \"localhost\",  \"port\": 5432,  \"username\": \"alice\",  \"password\": \"myPassword42\",  \"database\": \"blog-typeorm\"}\n```\n\nThe respective connection URL would look as follows in Prisma ORM:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-typeorm\"\n```\n\nNote that you can optionally configure the PostgreSQL [schema](https://www.postgresql.org/docs/9.1/ddl-schemas.html) by appending the `schema` argument to the connection URL:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-typeorm?schema=myschema\"\n```\n\nIf not provided, the default schema called `public` is being used.\n\n  \n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\nmodel typeorm_migrations {  id        Int    @id @default(autoincrement())  timestamp Int  name      String  @@map(\"_typeorm_migrations\")}model category {  id                       Int                        @id @default(autoincrement())  name                     String  post_categories_category post_categories_category[]}model post {  id                       Int                        @id @default(autoincrement())  title                    String  content                  String?  published                Boolean                    @default(false)  authorId                 Int?  user                     user?                      @relation(fields: [authorId], references: [id])  post_categories_category post_categories_category[]}model post_categories_category {  postId     Int  categoryId Int  category   category @relation(fields: [categoryId], references: [id])  post       post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")}model profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int?    @unique  user   user?   @relation(fields: [userId], references: [id])}model user {  id      Int      @id @default(autoincrement())  name    String?  email   String   @unique  post    post[]  profile profile?}\n```\n\nThe generated Prisma models represent your database tables and are the foundation for your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#25-adjust-the-prisma-schema-optional \"Direct link to 2.5. Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of TypeORM models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, the `post` field on the `user` model is a _list_, so a better name for this field would be `posts` to indicate that it's plural.\n\nYou can further completely remove model that represents the TypeORM migrations table (called `_typeorm_migrations` here) from the Prisma schema.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\nmodel Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  authorId          Int?  author            User?              @relation(fields: [authorId], references: [id])  postsToCategories PostToCategories[]  @@map(\"post\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")  @@map(\"post_categories_category\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int?    @unique  user   User?   @relation(fields: [userId], references: [id])  @@map(\"profile\")}model User {  id      Int      @id @default(autoincrement())  name    String?  email   String   @unique  posts   Post[]  profile Profile?  @@map(\"user\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with TypeORM:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your TypeORM queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-4-replace-your-typeorm-queries-with-prisma-client \"Direct link to Step 4. Replace your TypeORM queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from TypeORM to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from TypeORM, check out the [API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-comparison) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.ts` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'export const prisma = new PrismaClient()\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe REST API has three routes that accept `GET` requests:\n\n*   `/feed`: Return all published posts\n*   `/filterPosts?searchString=SEARCH_STRING`: Filter returned posts by `SEARCH_STRING`\n*   `/post/:postId`: Returns a specific post\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#feed \"Direct link to feed\")\n\nThe `/feed` handler is currently implemented as follows:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'export async function feedAction(req, res) {  const postRepository = getManager().getRepository(Post)  const publishedPosts = await postRepository.find({    where: { published: true },    relations: ['author'],  })  res.send(publishedPosts)}\n```\n\nNote that each returned `Post` object includes the relation to the `author` it's associated with. With TypeORM, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the TypeScript compiler does not provide any safety here.\n\nHere is how the same route is implemented using Prisma Client:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { prisma } from '../prisma'export async function feedAction(req, res) {  const publishedPosts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.send(publishedPosts)}\n```\n\nNote that the way how Prisma Client includes the `author` relation is absolutely type-safe. The TypeScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/filterPosts?searchString=SEARCH_STRING`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#filterpostssearchstringsearch_string \"Direct link to filterpostssearchstringsearch_string\")\n\nThe `/filterPosts` handler is currently implemented as follows:\n\nsrc/controllers/FilterPostsActions.ts\n\n```\nimport { getManager, Like } from 'typeorm'import { Post } from '../entity/Post'export async function filterPostsAction(req, res) {  const { searchString } = req.query  const postRepository = getManager().getRepository(Post)  const filteredPosts = await postRepository.find({    where: [      { title: Like(`%${searchString}%`) },      { content: Like(`%${searchString}%`) },    ],  })  res.send(filteredPosts)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/FilterPostsActions.ts\n\n```\nimport { prisma } from '../prisma'export async function filterPostsAction(req, res) {  const { searchString } = req.query  const filteredPosts = prisma.post.findMany({    where: {      OR: [        {          title: { contains: searchString },        },        {          content: { contains: searchString },        },      ],    },  })  res.send(filteredPosts)}\n```\n\nNote that TypeORM by default combines several `where` conditions with an implicit `OR` operator. Prisma ORM on the other hand [combines several `where` conditions with an implicit `AND` operator](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and), so in this case the Prisma Client query needs to make the `OR` explicit.\n\n#### `/post/:postId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#postpostid \"Direct link to postpostid\")\n\nThe `/post/:postId` handler is currently implemented as follows:\n\nsrc/controllers/GetPostByIdAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'export async function getPostByIdAction(req, res) {  const { postId } = req.params  const postRepository = getManager().getRepository(Post)  const post = await postRepository.findOne(postId)  res.send(post)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/GetPostByIdAction.ts\n\n```\nimport { prisma } from '../prisma'export async function getPostByIdAction(req, res) {  const { postId } = req.params  const post = await prisma.post.findUnique({    where: { id: postId },  })  res.send(post)}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `Post` record\n*   `/user/:userId/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#user \"Direct link to user\")\n\nThe `/user` handler is currently implemented as follows:\n\nsrc/controllers/CreateUserAction.ts\n\n```\nimport { getManager } from 'typeorm'import { User } from '../entity/User'export async function createUserAction(req, res) {  const { name, email } = req.body  const userRepository = getManager().getRepository(User)  const newUser = new User()  newUser.name = name  newUser.email = email  userRepository.save(newUser)  res.send(newUser)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/CreateUserAction.ts\n\n```\nimport { prisma } from '../prisma'export async function createUserAction(req, res) {  const { name, email } = req.body  const newUser = await prisma.user.create({    data: {      name,      email,    },  })  res.send(newUser)}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#post \"Direct link to post\")\n\nThe `/post` handler is currently implemented as follows:\n\nsrc/controllers/CreateDraftAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'import { User } from '../entity/User'export async function createDraftAction(req, res) {  const { title, content, authorEmail } = req.body  const userRepository = getManager().getRepository(User)  const user = await userRepository.findOne({ email: authorEmail })  const postRepository = getManager().getRepository(Post)  const newPost = new Post()  newPost.title = title  newPost.content = content  newPost.author = user  postRepository.save(newPost)  res.send(newPost)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/CreateDraftAction.ts\n\n```\nimport { prisma } from '../prisma'export async function createDraftAction(req, res) {  const { title, content, authorEmail } = req.body  const newPost = await prisma.post.create({    data: {      title,      content,      author: {        connect: { email: authorEmail },      },    },  })  res.send(newPost)}\n```\n\nNote that Prisma Client's nested write here save an initial query where first the `User` record needs to be retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:userId/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#useruseridprofile \"Direct link to useruseridprofile\")\n\nThe `/user/:userId/profile` handler is currently implemented as follows:\n\nsrc/controllers/SetBioForUserAction.ts.ts\n\n```\nimport { getManager } from 'typeorm'import { Profile } from '../entity/Profile'import { User } from '../entity/User'export async function setBioForUserAction(req, res) {  const { userId } = req.params  const { bio } = req.body  const userRepository = getManager().getRepository(User)  const user = await userRepository.findOne(userId, {    relations: ['profile'],  })  const profileRepository = getManager().getRepository(Profile)  user.profile.bio = bio  profileRepository.save(user.profile)  res.send(user)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/SetBioForUserAction.ts.ts\n\n```\nimport { prisma } from '../prisma'export async function setBioForUserAction(req, res) {  const { userId } = req.params  const { bio } = req.body  const user = await prisma.user.update({    where: { id: userId },    data: {      profile: {        update: {          bio,        },      },    },  })  res.send(user)}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has one route that accept a `PUT` request:\n\n*   `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`: Adds the post with `POST_ID` to the category with `CATEGORY_ID`\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#addposttocategorypostidpost_idcategoryidcategory_id \"Direct link to addposttocategorypostidpost_idcategoryidcategory_id\")\n\nThe `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID` handler is currently implemented as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'import { Category } from '../entity/Category'export async function addPostToCategoryAction(req, res) {  const { postId, categoryId } = req.query  const postRepository = getManager().getRepository(Post)  const post = await postRepository.findOne(postId, {    relations: ['categories'],  })  const categoryRepository = getManager().getRepository(Category)  const category = await categoryRepository.findOne(categoryId)  post.categories.push(category)  postRepository.save(post)  res.send(post)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nimport { prisma } from '../prisma'export async function addPostToCategoryAction(req, res) {  const { postId, categoryId } = req.query  const post = await prisma.post.update({    data: {      postsToCategories: {        create: {          category: {            connect: { id: categoryId },          },        },      },    },    where: {      id: postId,    },  })  res.send(post)}\n```\n\nNote that this Prisma Client can be made less verbose by modeling the relation as an [implicit many-to-many relation](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#implicit-many-to-many-relations) instead. In that case, the query would look as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nconst post = await prisma.post.update({  data: {    categories: {      connect: { id: categoryId },    },  },  where: { id: postId },})\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#more \"Direct link to More\")\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nSimilar to the `@manyToMany` decorator in TypeORM, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example with TypeORM:\n\n```\nimport {  Entity,  PrimaryGeneratedColumn,  Column,  ManyToMany,  JoinTable,} from 'typeorm'import { Category } from './Category'@Entity()export class Post {  @PrimaryGeneratedColumn()  id: number  @ManyToMany((type) => Category, (category) => category.posts)  @JoinTable()  categories: Category[]}\n```\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column, ManyToMany } from 'typeorm'import { Post } from './Post'@Entity()export class Category {  @PrimaryGeneratedColumn()  id: number  @ManyToMany((type) => Post, (post) => post.categories)  posts: Post[]}\n```\n\nIf you generate and run a migration with TypeORM based on these models, TypeORM will automatically create the following relation table for you:\n\n```\n-- Table Definition ----------------------------------------------CREATE TABLE post_categories_category (    \"postId\" integer REFERENCES post(id) ON DELETE CASCADE,    \"categoryId\" integer REFERENCES category(id) ON DELETE CASCADE,    CONSTRAINT \"PK_91306c0021c4901c1825ef097ce\" PRIMARY KEY (\"postId\", \"categoryId\"));-- Indices -------------------------------------------------------CREATE UNIQUE INDEX \"PK_91306c0021c4901c1825ef097ce\" ON post_categories_category(\"postId\" int4_ops,\"categoryId\" int4_ops);CREATE INDEX \"IDX_93b566d522b73cb8bc46f7405b\" ON post_categories_category(\"postId\" int4_ops);CREATE INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\" ON post_categories_category(\"categoryId\" int4_ops);\n```\n\nIf you introspect the database with Prisma ORM, you'll get the following result in the Prisma schema (note that some relation field names have been adjusted to look friendlier compared to the raw version from introspection):\n\nschema.prisma\n\n```\nmodel Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  authorId          Int?  author            User?              @relation(fields: [authorId], references: [id])  postsToCategories PostToCategories[]  @@map(\"post\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")  @@map(\"post_categories_category\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled _explicitly_ via the relation table `PostToCategories`.\n\nBy adhering to the conventions for Prisma ORM relation tables, the relation could look as follows:\n\nschema.prisma\n\n```\nmodel Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]  @@map(\"category\")}model Post {  id         Int        @id @default(autoincrement())  title      String  content    String?  published  Boolean    @default(false)  authorId   Int?  author     User?      @relation(fields: [authorId], references: [id])  categories Category[]  @@map(\"post\")}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostToCategories` model first.\n\nwarning\n\nIf your database provider requires tables to have primary keys then you have to use explicit syntax, and manually create the join model with a primary key. This is because relation tables (JOIN tables) created by Prisma ORM (expressed via `@relation`) for many-to-many relations using implicit syntax do not have primary keys.",
    "title": "How to migrate from TypeORM to Prisma ORM | Prisma Documentation",
    "description": "Learn how to migrate from TypeORM to Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma",
    "markdown": "# Deploying Prisma ORM-based projects | Prisma Documentation\n\n## Deploy Prisma ORM\n\nProjects using Prisma Client can be deployed to many different cloud platforms. Given the variety of cloud platforms and different names, it's noteworthy to mention the different deployment paradigms, as they affect the way you deploy an application using Prisma Client.\n\n## Deployment paradigms[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#deployment-paradigms \"Direct link to Deployment paradigms\")\n\nEach paradigm has different tradeoffs that affect the performance, scalability, and operational costs of your application.\n\nMoreover, the user traffic pattern of your application is also an important factor to consider. For example, any application with consistent user traffic may be better suited for a [continuously running paradigm](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#traditional-servers), whereas an application with sudden spikes may be better suited to [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions).\n\n### Traditional servers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#traditional-servers \"Direct link to Traditional servers\")\n\nYour application is [traditionally deployed](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional) if a Node.js process is continuously running and handles multiple requests at the same time. Your application could be deployed to a Platform-as-a-Service (PaaS) like [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku), [Koyeb](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb), as a Docker container to Kubernetes, or as a Node.js process on a virtual machine, or good old bare metal server.\n\nSee also: [Connection management in long-running processes](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes)\n\n### Serverless Functions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions \"Direct link to Serverless Functions\")\n\nYour application is [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless) if the Node.js processes of your application (or subsets of it broken into functions) are started as requests come in, and each function only handles one request at a time. Your application would most likely be deployed to a Function-as-a-Service (FaaS) offering, such as [AWS Lambda](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda) or [Azure Functions](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions)\n\nServerless environments have the concept of warm starts, which means that for subsequent invocations of the same function, it may use an already existing container that has the allocated processes, memory, file system (`/tmp` is writable on AWS Lambda), and even DB connection still available.\n\nTypically, any piece of code [outside the handler](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-features.html#gettingstarted-features-programmingmodel) remains initialized.\n\nSee also: [Connection management in serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas)\n\n### Edge Functions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#edge-functions \"Direct link to Edge Functions\")\n\nYour application is [edge deployed](https://www.prisma.io/docs/orm/prisma-client/deployment/edge) if your application is [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions) and the functions are distributed across one or more regions close to the user.\n\nTypically, edge environments also have a different runtime than a traditional or serverless environment, leading to common APIs being unavailable.",
    "title": "Deploying Prisma ORM-based projects | Prisma Documentation",
    "description": "Learn more about the different deployment paradigms for Node.js applications and how they affect deploying an application using Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/traditional",
    "markdown": "# Deploy Prisma ORM apps to traditional (PaaS) servers\n\nIf your application is deployed via a Platform-as-a-Service (PaaS) provider, whether containerized or not, it is a traditionally-deployed app. Common deployment examples include [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku) and [Koyeb](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb).\n\n## Traditional (PaaS) guides[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional#traditional-paas-guides \"Direct link to Traditional (PaaS) guides\")\n\n[\n\n## Deploy to Heroku\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku)\n\n[\n\n## Deploy to Koyeb\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb)",
    "title": "Deploy Prisma ORM apps to traditional (PaaS) servers | Prisma Documentation",
    "description": "Learn how to deploy your Prisma-backed apps to PaaS providers like Heroku, Koyeb, or AWS EC2",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless",
    "markdown": "# Deploy Prisma ORM apps to serverless function (FaaS) providers\n\n## Serverless functions\n\nIf your application is deployed via a \"Serverless Function\" or \"Function-as-a-Service (FaaS)\" offering and uses a standard Node.js runtime, it is a serverless app. Common deployment examples include [AWS Lambda](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda) and [Vercel Serverless Functions](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel).\n\n## Guides for Serverless Function providers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless#guides-for-serverless-function-providers \"Direct link to Guides for Serverless Function providers\")\n\n[\n\n## Deploy to Azure Functions\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions)\n\n[\n\n## Deploy to Vercel\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel)\n\n[\n\n## Deploy to AWS Lambda\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda)\n\n[\n\n## Deploy to Netlify\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify)",
    "title": "Deploy Prisma ORM apps to serverless function (FaaS) providers | Prisma Documentation",
    "description": "Learn how to deploy your Prisma ORM-backed apps to FaaS providers like AWS Lambda, Netlify, or Vercel Serverless Functions",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge",
    "markdown": "# Deploy Prisma ORM apps to edge function (distributed FaaS) providers\n\n## Edge functions\n\nIf your application is deployed via an \"Edge Function\" offering or is deployed from a [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless) offering and has a non-standard runtime, it is a _edge-deployed_ app. Common examples for such offerings include [Cloudflare Workers or Pages](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare), [Vercel Edge Functions or Edge Middleware](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel), and [Deno Deploy](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy).\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge#in-this-section \"Direct link to In this section\")\n\n[\n\n## Overview\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview)\n\n[\n\n## Deploy to Cloudflare\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare)\n\n[\n\n## Deploy to Vercel\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel)\n\n[](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy)",
    "title": "Deploy Prisma ORM apps to edge function (distributed FaaS) providers | Prisma Documentation",
    "description": "Learn how to deploy your Prisma ORM-backed apps to edge functions like Cloudflare Workers or Vercel Edge Functions",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/module-bundlers",
    "markdown": "# Module bundlers (Reference) | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-client/deployment/module-bundlers#overview \"Direct link to Overview\")\n\n_Module bundlers_ bundle JavaScript modules into a single JavaScript file. Most bundlers work by copying over the JavaScript code from a variety of source files into the target file.\n\nSince Prisma Client is not only based on JavaScript code, but also relies on the [**query engine binary file**](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-file) to be available, you need to make sure that your bundled code has access to the binary file.\n\nTo do so, you can use plugins that let you copy over static assets:\n\n| Bundler | Plugin |\n| --- | --- |\n| Webpack | [`copy-webpack-plugin`](https://github.com/webpack-contrib/copy-webpack-plugin#copy-webpack-plugin) |\n| Webpack (with [Next.js monorepo](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo)) | [`nextjs-monorepo-workaround-plugin`](https://www.npmjs.com/package/@prisma/nextjs-monorepo-workaround-plugin) |\n| Parcel | [`parcel-plugin-static-files-copy`](https://github.com/elwin013/parcel-plugin-static-files-copy#readme) |",
    "title": "Module bundlers (Reference) | Prisma Documentation",
    "description": "This page gives an overview of the most important things to be aware of when using a module bundler to bundle an application that uses Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-migrations-from-a-local-environment",
    "markdown": "# Deploy migrations from a local environment\n\nThere are two scenarios where you might consider deploying migrations directly from a local environment to a production environment.\n\nThis page outlines some examples of how you can do that and **why we would generally not recommend it**.\n\nIf you do not have an automated CI/CD process, you can technically deploy new migrations from your local environment to production in the following ways:\n\n```\n//delete-next-lineDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/my_local_database\"//add-next-lineDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/my_production_database\"\n```\n\nThe pipeline should handle deployment to staging and production environments, and use `migrate deploy` in a pipeline step. See the [deployment guides](https://www.prisma.io/docs/orm/prisma-client/deployment) for examples.\n\nWhen you add Prisma Migrate to an **existing database**, you must [baseline](https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining) the production database. Baselining is performed **once**, and can be done from a local instance.",
    "title": "Deploy migrations from a local environment | Prisma Documentation",
    "description": "Learn how to deploy Node.js and TypeScript applications that are using Prisma Client locally.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate",
    "markdown": "# Deploying database changes with Prisma Migrate\n\nTo apply pending migrations to staging, testing, or production environments, run the `migrate deploy` command as part of your CI/CD pipeline:\n\n```\nnpx prisma migrate deploy\n```\n\ninfo\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate deploy`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\nExactly when to run `prisma migrate deploy` depends on your platform. For example, a simplified [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku) workflow includes:\n\n1.  Ensuring the `./prisma/migration` folder is in source control\n2.  Running `prisma migrate deploy` during the [release phase](https://devcenter.heroku.com/articles/release-phase)\n\nIdeally, `migrate deploy` should be part of an automated CI/CD pipeline, and we do not generally recommend running this command locally to deploy changes to a production database (for example, by temporarily changing the `DATABASE_URL` environment variable). It is not generally considered good practice to store the production database URL locally.\n\nBeware that in order to run the `prisma migrate deploy` command, you need access to the `prisma` dependency that is typically added to the `devDependencies`. Some platforms like Vercel, prune development dependencies during the build, thereby preventing you from calling the command. This can be worked around by making the `prisma` a production dependency, by moving it to `dependencies` in your `package.json`. For more information about the `migrate deploy` command, see:\n\n*   [`migrate deploy` reference](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-deploy)\n*   [How `migrate deploy` works](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#production-and-testing-environments)\n*   [Production troubleshooting](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n\n## Deploying database changes using GitHub Actions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate#deploying-database-changes-using-github-actions \"Direct link to Deploying database changes using GitHub Actions\")\n\nAs part of your CI/CD, you can run `prisma migrate deploy` as part of your pipeline to apply pending migrations to your production database.\n\nHere is an example action that will run your migrations against your database:\n\ndeploy.yml\n\n```\nname: Deployon:  push:    paths:      - prisma/migrations/** # Only run this workflow when migrations are updated    branches:      - mainjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout repo        uses: actions/checkout@v3      - name: Setup Node        uses: actions/setup-node@v3      - name: Install dependencies        run: npm install      - name: Apply all pending migrations to the database        run: npx prisma migrate deploy        env:          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n```\n\nEnsure you have the `DATABASE_URL` variable [set as a secret in your repository](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions), without quotes around the connection string.",
    "title": "Deploying database changes with Prisma Migrate | Prisma Documentation",
    "description": "Learn how to deploy database changes with Prisma Migrate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms",
    "markdown": "# Caveats when deploying to AWS platforms\n\nThe following describes some caveats you might face when deploying to different AWS platforms.\n\n## AWS RDS Proxy[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-rds-proxy \"Direct link to AWS RDS Proxy\")\n\nPrisma ORM is compatible with AWS RDS Proxy. However, there is no benefit in using it for connection pooling with Prisma ORM due to the way RDS Proxy pins connections:\n\n> \"Your connections to the proxy can enter a state known as pinning. When a connection is pinned, each later transaction uses the same underlying database connection until the session ends. Other client connections also can't reuse that database connection until the session ends. The session ends when Prisma Client's connection is dropped.\" - [AWS RDS Proxy Docs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy-managing.html#rds-proxy-pinning)\n\n[Prepared statements (of any size) or query statements greater than 16 KB cause RDS Proxy to pin the session.](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy-managing.html#rds-proxy-pinning.all) Because Prisma ORM uses prepared statements for all queries, you won't see any benefit when using RDS Proxy with Prisma ORM.\n\n## AWS Elastic Beanstalk[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-elastic-beanstalk \"Direct link to AWS Elastic Beanstalk\")\n\nAWS Elastic Beanstalk is a PaaS-like deployment service that abstracts away infrastructure and allows you to deploy applications to AWS quickly.\n\nWhen deploying an app using Prisma Client to AWS Elastic Beanstalk, Prisma ORM generates the Prisma Client code into `node_modules`. This is typically done in the `postinstall` hook.\n\nBecause Beanstalk limits the ability to write to the filesystem in the `postinstall` hook, you need to create an [`.npmrc`](https://docs.npmjs.com/cli/v6/configuring-npm/npmrc) file in the root of your project and add the following configuration:\n\n.npmrc\n\nEnabling `unsafe-perm` forces _npm_ to run as _root_, avoiding the filesystem access problem, thereby allowing the `prisma generate` command in the `postinstall` hook to generate code into `node_modules`.\n\n### Error: @prisma/client did not initialize yet[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#error-prismaclient-did-not-initialize-yet \"Direct link to Error: @prisma/client did not initialize yet\")\n\nThis error happens because AWS Elastic Beanstalk doesn't install `devDependencies`, which means that it doesn't pick up the Prisma CLI. To remedy this you can either:\n\n1.  Add the `prisma` CLI package to your `dependencies` instead of the `devDependencies`. (Making sure to run `npm install` afterward to update the `package-lock.json`).\n2.  Or install your `devDependencies` on AWS Elastic Beanstalk instances. To do this you must set the AWS Elastic Beanstalk `NPM_USE_PRODUCTION` environment property to false.\n\n## AWS Lambda upload limit[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-lambda-upload-limit \"Direct link to AWS Lambda upload limit\")\n\nAWS Lambda defines an **deployment package upload limit**, which includes:\n\n*   All application code\n*   Binaries like the [Prisma ORM query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines)\n\nThe [deployment package (.zip) size limit for lambdas is 50MB](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html). When you prepare a deployment package, remove any files that the function does not require in production to keep the final .zip as small as possible. This includes some [Prisma ORM engine binaries](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#deleting-prisma-orm-engines-that-are-not-required).\n\n### Deleting Prisma ORM engines that are not required[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#deleting-prisma-orm-engines-that-are-not-required \"Direct link to Deleting Prisma ORM engines that are not required\")\n\nPrisma CLI downloads additional engine binaries that are **not required** in production. You can delete the following files and folders:\n\n1.  The entire `node_modules/@prisma/engines` folder (refer to the [sample bash script](https://github.com/prisma/ecosystem-tests/blob/13e74dc47eababa5d3c8f488b73fe7fc8bffead7/platforms-serverless/lambda/run.sh#L16) used by the Prisma end-to-end tests)\n    \n2.  The **local engine file** for your development platform from the `node_modules/.prisma/client` folder. For example, your schema might define the following `binaryTargets` if you develop on Debian (`native`) but deploy to AWS Lambda (`rhel-openssl-3.0.x`):\n    \n    ```\n    binaryTargets = [\"native\", \"rhel-openssl-3.0.x\"]\n    ```\n    \n    In this scenario:\n    \n    *   Keep `node_modules/.prisma/client/query-engine-rhel-openssl-3.0.x`, which is the engine file used by AWS Lambda\n        \n    *   Delete `node_modules/.prisma/client/query-engine-debian-openssl-1.1.x`, which is only required locally\n        \n    \n    > **Note**: When using Node.js 18 or earlier, the correct `binaryTarget` for AWS Lambda is `rhel-openssl-1.0.x`. `rhel-openssl-3.0.x` is the correct `binaryTarget` for Node.js versions greater than 18.",
    "title": "Caveats when deploying to AWS platforms | Prisma Documentation",
    "description": "Known caveats when deploying to an AWS platform",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware",
    "markdown": "# Middleware (Reference) | Prisma Documentation\n\nwarning\n\n**Deprecated**: Middleware is deprecated in version 4.16.0.\n\nWe recommend using the [Prisma Client extensions `query` component type](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query) as an alternative to middleware. Prisma Client extensions were first introduced into Preview in version 4.7.0 and made Generally Available in 4.16.0.\n\nPrisma Client extensions allow you to create independent Prisma Client instances and bind each client to a specific filter or user. For example, you could bind clients to specific users to provide user isolation. Prisma Client extensions also provide end-to-end type safety.\n\nMiddlewares act as query-level lifecycle hooks, which allow you to perform an action before or after a query runs. Use the [`prisma.$use`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#use) method to add middleware, as follows:\n\n```\nconst prisma = new PrismaClient()// Middleware 1prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})// Middleware 2prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})// Queries here\n```\n\nwarning\n\nDo not invoke `next` multiple times within a middleware when using [batch transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations). This will cause you to break out of the transaction and lead to unexpected results.\n\n[`params`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#params) represent parameters available in the middleware, such as the name of the query, and [`next`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#next) represents [the next middleware in the stack _or_ the original Prisma Client query](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#running-order-and-the-middleware-stack).\n\nPossible use cases for middleware include:\n\n*   Setting or overwriting a field value - for example, [setting the context language of a blog post comment](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/session-data-middleware)\n*   Validating input data - for example, check user input for inappropriate language via an external service\n*   Intercept a `delete` query and change it to an `update` in order to perform a [soft delete](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware)\n*   [Log the time taken to perform a query](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware)\n\nThere are many more use cases for middleware - this list serves as inspiration for the types of problems that middleware is designed to address.\n\n## Samples[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#samples \"Direct link to Samples\")\n\nThe following sample scenarios show how to use middleware in practice:\n\n[\n\n## Middleware sample: soft delete\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware)\n\n[\n\n## Middleware sample: logging\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware)\n\n[\n\n## Middleware sample: session data\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/session-data-middleware)\n\n## Where to add middleware[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#where-to-add-middleware \"Direct link to Where to add middleware\")\n\nAdd Prisma Client middleware **outside the context of the request handler**, otherwise each request adds a new _instance_ of the middleware to the stack. The following example demonstrates where to add Prisma Client middleware in the context of an Express app:\n\n```\nimport express from 'express'import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})const app = express()app.get('/feed', async (req, res) => {  // NO MIDDLEWARE HERE  const posts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.json(posts)})\n```\n\n## Running order and the middleware stack[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#running-order-and-the-middleware-stack \"Direct link to Running order and the middleware stack\")\n\nIf you have multiple middlewares, the running order for **each separate query** is:\n\n1.  All logic **before** `await next(params)` in each middleware, in descending order\n2.  All logic **after** `await next(params)` in each middleware, in ascending order\n\nDepending on where you are in the stack, `await next(params)` either:\n\n*   Runs the next middleware (in middlewares #1 and #2 in the example) _or_\n*   Runs the original Prisma Client query (in middleware #3)\n\n```\nconst prisma = new PrismaClient()// Middleware 1prisma.$use(async (params, next) => {  console.log(params.args.data.title)  console.log('1')  const result = await next(params)  console.log('6')  return result})// Middleware 2prisma.$use(async (params, next) => {  console.log('2')  const result = await next(params)  console.log('5')  return result})// Middleware 3prisma.$use(async (params, next) => {  console.log('3')  const result = await next(params)  console.log('4')  return result})const create = await prisma.post.create({  data: {    title: 'Welcome to Prisma Day 2020',  },})const create2 = await prisma.post.create({  data: {    title: 'How to Prisma!',  },})\n```\n\nOutput:\n\n```\nWelcome to Prisma Day 2020123456How to Prisma!123456\n```\n\n## Performance and appropriate use cases[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#performance-and-appropriate-use-cases \"Direct link to Performance and appropriate use cases\")\n\nMiddleware executes for **every** query, which means that overuse has the potential to negatively impact performance. To avoid adding performance overheads:\n\n*   Check the `params.model` and `params.action` properties early in your middleware to avoid running logic unnecessarily:\n    \n    ```\n    prisma.$use(async (params, next) => {  if (params.model == 'Post' && params.action == 'delete') {    // Logic only runs for delete action and Post model  }  return next(params)})\n    ```\n    \n*   Consider whether middleware is the appropriate solution for your scenario. For example:\n    \n    *   If you need to populate a field, can you use the [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute?\n    *   If you need to set the value of a `DateTime` field, can you use the `now()` function or the `@updatedAt` attribute?\n    *   If you need to perform more complex validation, can you use a `CHECK` constraint in the database itself?",
    "title": "Middleware (Reference) | Prisma Documentation",
    "description": "Prisma Client middleware allows you to perform actions before or after any query on any model with the prisma.$use method.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-to-a-different-os",
    "markdown": "# Deploy to a different OS\n\nPrisma Client depends on the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) that is running as a binary on the same host as your application.\n\nThe query engine is implemented in Rust and is used by Prisma Client in the form of executable binary files. The binary is downloaded when `prisma generate` is called.\n\nIf you have developed your application on a Windows machine for example, and wish to upload to AWS Lambda, which is a Linux environment, you may encounter issues and be presented with some warnings in your terminal.\n\nTo solve this, if you know ahead of time that you will be deploying to a different environment, you can use the [binary targets](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets) and specify which of the [supported operating systems](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) binaries should be included.\n\n> **Note**: If your OS isn't supported you can include a [custom binary](https://www.prisma.io/docs/orm/more/under-the-hood/engines#using-custom-engine-libraries-or-binaries).",
    "title": "Deploy to a different OS | Prisma Documentation",
    "description": "Learn how to deploy Node.js and TypeScript applications that are using Prisma Client to a different operating system.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors",
    "markdown": "# Handling exceptions and errors (Reference)\n\nIn order to handle different types of errors you can use `instanceof` to check what the error is and handle it accordingly.\n\nThe following example tries to create a user with an already existing email record. This will throw an error because the `email` field has the `@unique` attribute applied to it.\n\nUse the `Prisma` namespace to access the error type. The [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes) can then be checked and a message can be printed.\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const client = new PrismaClient()try {  await client.user.create({ data: { email: 'alreadyexisting@mail.com' } })} catch (e) {  if (e instanceof Prisma.PrismaClientKnownRequestError) {    // The .code property can be accessed in a type-safe manner    if (e.code === 'P2002') {      console.log(        'There is a unique constraint violation, a new user cannot be created with this email'      )    }  }  throw e}\n```\n\nSee [Errors reference](https://www.prisma.io/docs/orm/reference/error-reference) for a detailed breakdown of the different error types and their codes.",
    "title": "Handling exceptions and errors (Reference) | Prisma Documentation",
    "description": "This page covers how to handle exceptions and errors",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/overview/generators",
    "markdown": "# Generators (Reference) | Prisma Documentation\n\nA Prisma schema can have one or more generators, represented by the [`generator`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generator) block:\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"./generated/prisma-client-js\"}\n```\n\nA generator determines which assets are created when you run the `prisma generate` command. The main property `provider` defines which **Prisma Client (language specific)** is created - currently, only `prisma-client-js` is available. Alternatively you can define any npm package that follows our generator specification. Additionally and optionally you can define a custom output folder for the generated assets with `output`.\n\n## Prisma Client: `prisma-client-js`[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#prisma-client-prisma-client-js \"Direct link to prisma-client-prisma-client-js\")\n\nThe generator for Prisma's JavaScript Client accepts multiple additional properties:\n\n*   `previewFeatures`: [Preview features](https://www.prisma.io/docs/orm/reference/preview-features) to include\n*   `binaryTargets`: Engine binary targets for `prisma-client-js` (for example, `debian-openssl-1.1.x` if you are deploying to Ubuntu 18+, or `native` if you are working locally)\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"sample-preview-feature\"]  binaryTargets   = [\"linux-musl\"]}\n```\n\n### Binary targets[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets \"Direct link to Binary targets\")\n\nPrisma Client JS (`prisma-client-js`) uses several [engines](https://github.com/prisma/prisma-engines). Engines are implemented in Rust and are used by Prisma Client in the form of executable, platform dependent engine files. Depending on which platform you are executing your code on, you need the correct file. \"Binary targets\" are used to define which files should be present for the target platform(s).\n\nThe correct file is particularly important when [deploying](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma) your application to production, which often differs from your local development environment.\n\n#### The `native` binary target[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#the-native-binary-target \"Direct link to the-native-binary-target\")\n\nThe `native` binary target is special. It doesn't map to a concrete operating system. Instead, when `native` is specified in `binaryTargets`, Prisma Client detects the _current_ operating system and automatically specifies the correct binary target for it.\n\nAs an example, assume you're running **macOS** and you specify the following generator:\n\n```\ngenerator client {  provider      = \"prisma-client-js\"  binaryTargets = [\"native\"]}\n```\n\nIn that case, Prisma Client detects your operating system and finds the right binary file for it based on the [list of supported operating systems](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) . If you use macOS Intel x86 (`darwin`), then the binary file that was compiled for `darwin` will be selected. If you use macOS ARM64 (`darwin-arm64`), then the binary file that was compiled for `darwin-arm64` will be selected.\n\n> **Note**: The `native` binary target is the default. You can set it explicitly if you wish to include additional [binary targets](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) for deployment to different environments.\n\nThe following is a list of community created generators. If you want to create your own generator, you can use the [`create-prisma-generator`](https://github.com/YassinEldeeb/create-prisma-generator) CLI built by our community member [Yassin Eldeep](https://github.com/YassinEldeeb).\n\n> **Note**: Community projects are not maintained or officially supported by Prisma and some features may be out of sync. Use at your own discretion. If you create a community generator, please use this naming convention: `prisma-generator-<custom-name>`.\n\n*   [`prisma-dbml-generator`](https://notiz.dev/blog/prisma-dbml-generator): Transforms the Prisma schema into [Database Markup Language](https://dbml.dbdiagram.io/home/) (DBML) which allows for an easy visual representation\n*   [`prisma-docs-generator`](https://github.com/pantharshit00/prisma-docs-generator): Generates an individual API reference for Prisma Client\n*   [`prisma-json-schema-generator`](https://github.com/valentinpalkovic/prisma-json-schema-generator): Transforms the Prisma schema in [JSON schema](https://json-schema.org/)\n*   [`prisma-json-types-generator`](https://github.com/arthurfiorette/prisma-json-types-generator): Adds support for [Strongly Typed `Json`](https://github.com/arthurfiorette/prisma-json-types-generator#readme) fields for all databases. It goes on `prisma-client-js` output and changes the json fields to match the type you provide. Helping with code generators, intellisense and much more. All of that without affecting any runtime code.\n*   [`typegraphql-prisma`](https://github.com/MichalLytek/typegraphql-prisma#readme): Generates [TypeGraphQL](https://typegraphql.com/) CRUD resolvers for Prisma models\n*   [`typegraphql-prisma-nestjs`](https://github.com/EndyKaufman/typegraphql-prisma-nestjs#readme): Fork of [`typegraphql-prisma`](https://github.com/MichalLytek/typegraphql-prisma), which also generates CRUD resolvers for Prisma models but for NestJS\n*   [`prisma-typegraphql-types-gen`](https://github.com/YassinEldeeb/prisma-tgql-types-gen): Generates [TypeGraphQL](https://typegraphql.com/) class types and enums from your prisma type definitions, the generated output can be edited without being overwritten by the next gen and has the ability to correct you when you mess up the types with your edits.\n*   [`nexus-prisma`](https://github.com/prisma/nexus-prisma/): Allows to project Prisma models to GraphQL via [GraphQL Nexus](https://nexusjs.org/docs/)\n*   [`prisma-nestjs-graphql`](https://github.com/unlight/prisma-nestjs-graphql): Generates object types, inputs, args, etc. from the Prisma Schema for usage with `@nestjs/graphql` module\n*   [`prisma-appsync`](https://github.com/maoosi/prisma-appsync): Generates a full-blown GraphQL API for [AWS AppSync](https://aws.amazon.com/appsync/)\n*   [`prisma-kysely`](https://github.com/valtyr/prisma-kysely): Generates type definitions for Kysely, a TypeScript SQL query builder. This can be useful to perform queries against your database from an edge runtime, or to write more complex SQL queries not possible in Prisma without dropping type safety.\n*   [`prisma-generator-nestjs-dto`](https://github.com/vegardit/prisma-generator-nestjs-dto): Generates DTO and Entity classes with relation `connect` and `create` options for use with [NestJS Resources](https://docs.nestjs.com/recipes/crud-generator) and [@nestjs/swagger](https://www.npmjs.com/package/@nestjs/swagger)\n*   [`prisma-erd-generator`](https://github.com/keonik/prisma-erd-generator): Generates an entity relationship diagram\n*   [`prisma-class-generator`](https://github.com/kimjbstar/prisma-class-generator): Generates classes from your Prisma Schema that can be used as DTO, Swagger Response, TypeGraphQL and so on.\n*   [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Creates Zod schemas from your Prisma models.\n*   [`prisma-pothos-types`](https://github.com/hayes/pothos/tree/main/packages/plugin-prisma): Makes it easier to define Prisma-based object types, and helps solve n+1 queries for relations. It also has integrations for the Relay plugin to make defining nodes and connections easy and efficient.\n*   [`prisma-generator-pothos-codegen`](https://github.com/Cauen/prisma-generator-pothos-codegen): Auto generate input types (for use as args) and auto generate decoupled type-safe base files makes it easy to create customizable objects, queries and mutations for [Pothos](https://pothos-graphql.dev/) from Prisma schema. Optionally generate all crud at once from the base files.\n*   [`prisma-joi-generator`](https://github.com/omar-dulaimi/prisma-joi-generator): Generate full Joi schemas from your Prisma schema.\n*   [`prisma-yup-generator`](https://github.com/omar-dulaimi/prisma-yup-generator): Generate full Yup schemas from your Prisma schema.\n*   [`prisma-class-validator-generator`](https://github.com/omar-dulaimi/prisma-class-validator-generator): Emit TypeScript models from your Prisma schema with class validator validations ready.\n*   [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.\n*   [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers.\n*   [`prisma-json-server-generator`](https://github.com/omar-dulaimi/prisma-json-server-generator): Emit a JSON file that can be run with json-server.\n*   [`prisma-trpc-shield-generator`](https://github.com/omar-dulaimi/prisma-trpc-shield-generator): Emit a tRPC shield from your Prisma schema.\n*   [`prisma-custom-models-generator`](https://github.com/omar-dulaimi/prisma-custom-models-generator): Emit custom models from your Prisma schema, based on Prisma recommendations.\n*   [`nestjs-prisma-graphql-crud-gen`](https://github.com/mk668a/nestjs-prisma-graphql-crud-gen): Generate CRUD resolvers from GraphQL schema with NestJS and Prisma.\n*   [`prisma-generator-dart`](https://github.com/FredrikBorgstrom/abcx3/tree/master/libs/prisma-generator-dart): Generates Dart/Flutter class files with to- and fromJson methods.\n*   [`prisma-generator-graphql-typedef`](https://github.com/mavvy22/prisma-generator-graphql-typedef): Generates graphql schema.\n*   [`prisma-markdown`](https://github.com/samchon/prisma-markdown): Generates markdown document composed with ERD diagrams and their descriptions. Supports pagination of ERD diagrams through `@namespace` comment tag.\n*   [`prisma-models-graph`](https://github.com/dangchinh25/prisma-models-graph): Generates a bi-directional models graph for schema without strict relationship defined in the schema, works via a custom schema annotation.\n*   [`prisma-generator-fake-data`](https://github.com/luisrudge/prisma-generator-fake-data): Generates realistic-looking fake data for your Prisma models that can be used in unit/integration tests, demos, and more.\n*   [`prisma-generator-drizzle`](https://github.com/farreldarian/prisma-generator-drizzle): A Prisma generator for generating Drizzle schema with ease.\n*   [`prisma-generator-express`](https://github.com/multipliedtwice/prisma-generator-express): Generates Express CRUD and Router generator function.\n*   [`prismabox`](https://github.com/m1212e/prismabox): Generates versatile [typebox](https://github.com/sinclairzx81/typebox) schema from your Prisma models.",
    "title": "Generators (Reference) | Prisma Documentation",
    "description": "Generators in your Prisma schema specify what assets are generated when the `prisma generate` command is invoked. This page explains how to configure generators.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing",
    "markdown": "# Integration testing with Prisma | Prisma Documentation\n\nIntegration tests focus on testing how separate parts of the program work together. In the context of applications using a database, integration tests usually require a database to be available and contain data that is convenient to the scenarios intended to be tested.\n\nOne way to simulate a real world environment is to use [Docker](https://www.docker.com/get-started) to encapsulate a database and some test data. This can be spun up and torn down with the tests and so operate as an isolated environment away from your production databases.\n\n> **Note:** This [blog post](https://www.prisma.io/blog/testing-series-2-xPhjjmIEsM) offers a comprehensive guide on setting up an integration testing environment and writing integration tests against a real database, providing valuable insights for those looking to explore this topic.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#prerequisites \"Direct link to Prerequisites\")\n\nThis guide assumes you have [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on your machine as well as `Jest` setup in your project.\n\nThe following ecommerce schema will be used throughout the guide. This varies from the traditional `User` and `Post` models used in other parts of the docs, mainly because it is unlikely you will be running integration tests against your blog.\n\nEcommerce schema\n\nschema.prisma\n\n```\n// Can have 1 customer// Can have many order detailsmodel CustomerOrder {  id           Int            @id @default(autoincrement())  createdAt    DateTime       @default(now())  customer     Customer       @relation(fields: [customerId], references: [id])  customerId   Int  orderDetails OrderDetails[]}// Can have 1 order// Can have many productsmodel OrderDetails {  id        Int           @id @default(autoincrement())  products  Product       @relation(fields: [productId], references: [id])  productId Int  order     CustomerOrder @relation(fields: [orderId], references: [id])  orderId   Int  total     Decimal  quantity  Int}// Can have many order details// Can have 1 categorymodel Product {  id           Int            @id @default(autoincrement())  name         String  description  String  price        Decimal  sku          Int  orderDetails OrderDetails[]  category     Category       @relation(fields: [categoryId], references: [id])  categoryId   Int}// Can have many productsmodel Category {  id       Int       @id @default(autoincrement())  name     String  products Product[]}// Can have many ordersmodel Customer {  id      Int             @id @default(autoincrement())  email   String          @unique  address String?  name    String?  orders  CustomerOrder[]}\n```\n\nThe guide uses a singleton pattern for Prisma Client setup. Refer to the [singleton](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#singleton) docs for a walk through of how to set that up.\n\n## Add Docker to your project[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#add-docker-to-your-project \"Direct link to Add Docker to your project\")\n\n![Docker compose code pointing towards image of container holding a Postgres database](https://www.prisma.io/docs/assets/images/Docker_Diagram_V1-c836b310ed1106c721c48224b5404a99.png)\n\nWith Docker and Docker compose both installed on your machine you can use them in your project.\n\n1.  Begin by creating a `docker-compose.yml` file at your projects root. Here you will add a Postgres image and specify the environments credentials.\n\ndocker-compose.yml\n\n```\n# Set the version of docker compose to useversion: '3.9'# The containers that compose the projectservices:  db:    image: postgres:13    restart: always    container_name: integration-tests-prisma    ports:      - '5433:5432'    environment:      POSTGRES_USER: prisma      POSTGRES_PASSWORD: prisma      POSTGRES_DB: tests\n```\n\n> **Note**: The compose version used here (`3.9`) is the latest at the time of writing, if you are following along be sure to use the same version for consistency.\n\nThe `docker-compose.yml` file defines the following:\n\n*   The Postgres image (`postgres`) and version tag (`:13`). This will be downloaded if you do not have it locally available.\n*   The port `5433` is mapped to the internal (Postgres default) port `5432`. This will be the port number the database is exposed on externally.\n*   The database user credentials are set and the database given a name.\n\n2.  To connect to the database in the container, create a new connection string with the credentials defined in the `docker-compose.yml` file. For example:\n\n.env.test\n\n```\nDATABASE_URL=\"postgresql://prisma:prisma@localhost:5433/tests\"\n```\n\ninfo\n\nThe above `.env.test` file is used as part of a multiple `.env` file setup. Checkout the [using multiple .env files.](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files) section to learn more about setting up your project with multiple `.env` files\n\n3.  To create the container in a detached state so that you can continue to use the terminal tab, run the following command:\n\n4.  Next you can check that the database has been created by executing a `psql` command inside the container. Make a note of the container id.\n    \n\n> **Note**: The container id is unique to each container, you will see a different id displayed.\n\n5.  Using the container id from the previous step, run `psql` in the container, login with the created user and check the database is created:\n    \n    ```\n    docker exec -it 1322e42d833f psql -U prisma tests\n    ```\n    \n\n## Integration testing[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#integration-testing \"Direct link to Integration testing\")\n\nIntegration tests will be run against a database in a **dedicated test environment** instead of the production or development environments.\n\n### The flow of operations[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-flow-of-operations \"Direct link to The flow of operations\")\n\nThe flow for running said tests goes as follows:\n\n1.  Start the container and create the database\n2.  Migrate the schema\n3.  Run the tests\n4.  Destroy the container\n\nEach test suite will seed the database before all the test are run. After all the tests in the suite have finished, the data from all the tables will be dropped and the connection terminated.\n\n### The function to test[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-function-to-test \"Direct link to The function to test\")\n\nThe ecommerce application you are testing has a function which creates an order. This function does the following:\n\n*   Accepts input about the customer making the order\n*   Accepts input about the product being ordered\n*   Checks if the customer has an existing account\n*   Checks if the product is in stock\n*   Returns an \"Out of stock\" message if the product doesn't exist\n*   Creates an account if the customer doesn't exist in the database\n*   Create the order\n\nAn example of how such a function might look can be seen below:\n\ncreate-order.ts\n\n```\nimport prisma from '../client'export interface Customer {  id?: number  name?: string  email: string  address?: string}export interface OrderInput {  customer: Customer  productId: number  quantity: number}/** * Creates an order with customer. * @param input The order parameters */export async function createOrder(input: OrderInput) {  const { productId, quantity, customer } = input  const { name, email, address } = customer  // Get the product  const product = await prisma.product.findUnique({    where: {      id: productId,    },  })  // If the product is null its out of stock, return error.  if (!product) return new Error('Out of stock')  // If the customer is new then create the record, otherwise connect via their unique email  await prisma.customerOrder.create({    data: {      customer: {        connectOrCreate: {          create: {            name,            email,            address,          },          where: {            email,          },        },      },      orderDetails: {        create: {          total: product.price,          quantity,          products: {            connect: {              id: product.id,            },          },        },      },    },  })}\n```\n\n### The test suite[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-test-suite \"Direct link to The test suite\")\n\nThe following tests will check if the `createOrder` function works as it should do. They will test:\n\n*   Creating a new order with a new customer\n*   Creating an order with an existing customer\n*   Show an \"Out of stock\" error message if a product doesn't exist\n\nBefore the test suite is run the database is seeded with data. After the test suite has finished a [`deleteMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) is used to clear the database of its data.\n\ntip\n\nUsing `deleteMany` may suffice in situations where you know ahead of time how your schema is structured. This is because the operations need to be executed in the correct order according to how the model relations are setup.\n\nHowever, this doesn't scale as well as having a more generic solution that maps over your models and performs a truncate on them. For those scenarios and examples of using raw SQL queries see [Deleting all data with raw SQL / `TRUNCATE`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-data-with-raw-sql--truncate)\n\n\\_\\_tests\\_\\_/create-order.ts\n\n```\nimport prisma from '../src/client'import { createOrder, Customer, OrderInput } from '../src/functions/index'beforeAll(async () => {  // create product categories  await prisma.category.createMany({    data: [{ name: 'Wand' }, { name: 'Broomstick' }],  })  console.log('✨ 2 categories successfully created!')  // create products  await prisma.product.createMany({    data: [      {        name: 'Holly, 11\", phoenix feather',        description: 'Harry Potters wand',        price: 100,        sku: 1,        categoryId: 1,      },      {        name: 'Nimbus 2000',        description: 'Harry Potters broom',        price: 500,        sku: 2,        categoryId: 2,      },    ],  })  console.log('✨ 2 products successfully created!')  // create the customer  await prisma.customer.create({    data: {      name: 'Harry Potter',      email: 'harry@hogwarts.io',      address: '4 Privet Drive',    },  })  console.log('✨ 1 customer successfully created!')})afterAll(async () => {  const deleteOrderDetails = prisma.orderDetails.deleteMany()  const deleteProduct = prisma.product.deleteMany()  const deleteCategory = prisma.category.deleteMany()  const deleteCustomerOrder = prisma.customerOrder.deleteMany()  const deleteCustomer = prisma.customer.deleteMany()  await prisma.$transaction([    deleteOrderDetails,    deleteProduct,    deleteCategory,    deleteCustomerOrder,    deleteCustomer,  ])  await prisma.$disconnect()})it('should create 1 new customer with 1 order', async () => {  // The new customers details  const customer: Customer = {    id: 2,    name: 'Hermione Granger',    email: 'hermione@hogwarts.io',    address: '2 Hampstead Heath',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 1,    quantity: 1,  }  // Create the order and customer  await createOrder(order)  // Check if the new customer was created by filtering on unique email field  const newCustomer = await prisma.customer.findUnique({    where: {      email: customer.email,    },  })  // Check if the new order was created by filtering on unique email field of the customer  const newOrder = await prisma.customerOrder.findFirst({    where: {      customer: {        email: customer.email,      },    },  })  // Expect the new customer to have been created and match the input  expect(newCustomer).toEqual(customer)  // Expect the new order to have been created and contain the new customer  expect(newOrder).toHaveProperty('customerId', 2)})it('should create 1 order with an existing customer', async () => {  // The existing customers email  const customer: Customer = {    email: 'harry@hogwarts.io',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 1,    quantity: 1,  }  // Create the order and connect the existing customer  await createOrder(order)  // Check if the new order was created by filtering on unique email field of the customer  const newOrder = await prisma.customerOrder.findFirst({    where: {      customer: {        email: customer.email,      },    },  })  // Expect the new order to have been created and contain the existing customer with an id of 1 (Harry Potter from the seed script)  expect(newOrder).toHaveProperty('customerId', 1)})it(\"should show 'Out of stock' message if productId doesn't exit\", async () => {  // The existing customers email  const customer: Customer = {    email: 'harry@hogwarts.io',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 3,    quantity: 1,  }  // The productId supplied doesn't exit so the function should return an \"Out of stock\" message  await expect(createOrder(order)).resolves.toEqual(new Error('Out of stock'))})\n```\n\n## Running the tests[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#running-the-tests \"Direct link to Running the tests\")\n\nThis setup isolates a real world scenario so that you can test your applications functionality against real data in a controlled environment.\n\nYou can add some scripts to your projects `package.json` file which will setup the database and run the tests, then afterwards manually destroy the container.\n\npackage.json\n\n```\n  \"scripts\": {    \"docker:up\": \"docker compose up -d\",    \"docker:down\": \"docker compose down\",    \"test\": \"yarn docker:up && yarn prisma migrate deploy && jest -i\"  },\n```\n\nThe `test` script does the following:\n\n1.  Runs `docker compose up -d` to create the container with the Postgres image and database.\n2.  Applies the migrations found in `./prisma/migrations/` directory to the database, this creates the tables in the container's database.\n3.  Executes the tests.\n\nOnce you are satisfied you can run `yarn docker:down` to destroy the container, its database and any test data.",
    "title": "Integration testing with Prisma | Prisma Documentation",
    "description": "Learn how to setup and run integration tests with Prisma and Docker",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client",
    "markdown": "# Generating Prisma Client | Prisma Documentation\n\nPrisma Client is an auto-generated database client that's tailored to your database schema. By default, Prisma Client is generated into the `node_modules/.prisma/client` folder, but [you can specify a custom location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path).\n\nTo generate and instantiate Prisma Client:\n\n1.  Ensure that you have [Prisma CLI installed on your machine](https://www.prisma.io/docs/orm/tools/prisma-cli#installation).\n    \n2.  Add the following `generator` definition to your Prisma schema:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}\n    ```\n    \n3.  Install the `@prisma/client` npm package:\n    \n    ```\n    npm install @prisma/client\n    ```\n    \n    warning\n    \n    We recommend that you keep **both** the `prisma` and `@prisma/client` packages in sync to avoid any unexpected errors or behaviors.\n    \n4.  Generate Prisma Client with the following command:\n    \n5.  You can now [instantiate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/instantiate-prisma-client) in your code:\n    \n\n*   TypeScript\n*   JavaScript\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\n> **Important**: You need to re-run the `prisma generate` command after every change that's made to your Prisma schema to update the generated Prisma Client code.\n\nHere is a graphical illustration of the typical workflow for generation of Prisma Client:\n\n![Graphical illustration of the typical workflow for generation of Prisma Client](https://www.prisma.io/docs/assets/images/prisma-client-generation-workflow-3b42c24d27aef3025f2eb4ffc4644642.png)\n\nNote also that `prisma generate` is _automatically_ invoked when you're installing the `@prisma/client` npm package. So, when you're initially setting up Prisma Client, you can typically save the third step from the list above.\n\n## The `@prisma/client` npm package[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package \"Direct link to the-prismaclient-npm-package\")\n\nThe `@prisma/client` npm package consists of two key parts:\n\n*   The `@prisma/client` module itself, which only changes when you re-install the package\n*   The `.prisma/client` folder, which is the [default location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path) for the unique Prisma Client generated from your schema\n\n`@prisma/client/index.d.ts` exports `.prisma/client`:\n\n```\nexport * from '.prisma/client'\n```\n\nThis means that you still import `@prisma/client` in your own `.ts` files:\n\n```\nimport { PrismaClient } from '@prisma/client'\n```\n\nPrisma Client is generated from your Prisma schema and is unique to your project. Each time you change the schema (for example, by performing a [schema migration](https://www.prisma.io/docs/orm/prisma-migrate)) and run `prisma generate`, Prisma Client's code changes:\n\n![The .prisma and @prisma folders](https://www.prisma.io/docs/assets/images/prisma-client-node-module-7c4bfa76f2c2d8d4a02e98ada95a067f.png)\n\nThe `.prisma` folder is unaffected by [pruning](https://docs.npmjs.com/cli/prune.html) in Node.js package managers.\n\n## The location of Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-location-of-prisma-client \"Direct link to The location of Prisma Client\")\n\nIf you do not specify a custom `output` in the `generator` block, Prisma Client is generated into the `./node_modules/.prisma/client` folder by default. There are [some advantages to maintaining the default location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#why-is-prisma-client-generated-into-node_modulesprismaclient-by-default).\n\n### Using a custom `output` path[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path \"Direct link to using-a-custom-output-path\")\n\nYou can also specify a custom `output` path on the `generator` configuration, for example (assuming your `schema.prisma` file is located at the default `prisma` subfolder):\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"../src/generated/client\"}\n```\n\nAfter running `prisma generate` for that schema file, the Prisma Client package will be located in:\n\nTo import the `PrismaClient` from a custom location (for example, from a file named `./src/script.ts`):\n\n```\nimport { PrismaClient } from './generated/client'\n```\n\n### Why is Prisma Client generated into `node_modules/.prisma/client` by default?[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#why-is-prisma-client-generated-into-node_modulesprismaclient-by-default \"Direct link to why-is-prisma-client-generated-into-node_modulesprismaclient-by-default\")\n\n#### Importing Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#importing-prisma-client \"Direct link to Importing Prisma Client\")\n\nBy generating Prisma Client into `node_modules/.prisma/client` and exporting it from `@prisma/client`, you can import it and instantiate Prisma Client in your code as follows:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\nor\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\n#### Keeping the query engine out of version control by default[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#keeping-the-query-engine-out-of-version-control-by-default \"Direct link to Keeping the query engine out of version control by default\")\n\nPrisma Client uses a [_query engine_](https://www.prisma.io/docs/orm/more/under-the-hood/engines) to run queries against the database. This query engine is downloaded when `prisma generate` is invoked and stored in the `output` path together with the generated Client.\n\nBy generating Prisma Client into `node_modules`, the query engine is usually kept out of version control by default since `node_modules` is typically ignored for version control. When using a custom `output` path for the generated Prisma Client, it is advised to exclude it from your version control. For Git, this means adding the `output` path to your `.gitignore` file.\n\n## Generating Prisma Client in the `postinstall` hook of `@prisma/client`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#generating-prisma-client-in-the-postinstall-hook-of-prismaclient \"Direct link to generating-prisma-client-in-the-postinstall-hook-of-prismaclient\")\n\nThe `@prisma/client` package defines its own `postinstall` hook that's being executed whenever the package is being installed. This hook invokes the `prisma generate` command which in turn generates the Prisma Client code into the default location `node_modules/.prisma/client`. Notice that this requires the `prisma` CLI to be available, either as local dependency or as a global installation. It is recommended to always install the `prisma` package as a development dependency, using `npm install prisma --save-dev`, to avoid versioning conflicts.",
    "title": "Generating Prisma Client | Prisma Documentation",
    "description": "This page explains how to generate Prisma Client. It also provides additional context on the generated client, typical workflows and Node.js configuration.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding",
    "markdown": "# Seeding | Prisma Documentation\n\nThis guide describes how to seed your database using Prisma Client and Prisma ORM's integrated seeding functionality. Seeding allows you to consistently re-create the same data in your database and can be used to:\n\n*   Populate your database with data that is required for your application to start, such as a default language or currency.\n*   Provide basic data for validating and using your application in a development environment. This is particularly useful if you are using Prisma Migrate, which sometimes requires resetting your development database.\n\n## How to seed your database in Prisma ORM[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#how-to-seed-your-database-in-prisma-orm \"Direct link to How to seed your database in Prisma ORM\")\n\nPrisma ORM's integrated seeding functionality expects a command in the `\"seed\"` key in the `\"prisma\"` key of your `package.json` file. This can be any command, `prisma db seed` will just execute it. In this guide and as a default, we recommend writing a seed script inside your project's `prisma/` folder and starting it with the command.\n\n*   TypeScript\n*   JavaScript\n\n  \n\n```\n\"prisma\": {  \"seed\": \"ts-node prisma/seed.ts\"},\n```\n\n  \n\ninfo\n\nWith TypeScript,`ts-node` does transpiling and typechecking by default; typechecking can be disabled with the following flag `--transpile-only`.\n\nExample: `\"seed\": \"ts-node --transpile-only prisma/seed.ts\"`\n\nThis can be useful to reduce memory usage (RAM) and increase execution speed of the seed script.\n\n## Integrated seeding with Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#integrated-seeding-with-prisma-migrate \"Direct link to Integrated seeding with Prisma Migrate\")\n\nDatabase seeding happens in two ways with Prisma ORM: manually with `prisma db seed` and automatically in `prisma migrate reset` and (in some scenarios) `prisma migrate dev`.\n\nWith `prisma db seed`, _you_ decide when to invoke the seed command. It can be useful for a test setup or to prepare a new development environment, for example.\n\nPrisma Migrate also integrates seamlessly with your seeds, assuming you follow the steps in the section below. Seeding is triggered automatically when Prisma Migrate resets the development database.\n\nPrisma Migrate resets the database and triggers seeding in the following scenarios:\n\n*   You manually run the `prisma migrate reset` CLI command.\n*   The database is reset interactively in the context of using `prisma migrate dev` - for example, as a result of migration history conflicts or database schema drift.\n*   The database is actually created by `prisma migrate dev`, because it did not exist before.\n\nWhen you want to use `prisma migrate dev` or `prisma migrate reset` without seeding, you can pass the `--skip-seed` flag.\n\n## Example seed scripts[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#example-seed-scripts \"Direct link to Example seed scripts\")\n\nHere we suggest some specific seed scripts for different situations. You are free to customize these in any way, but can also use them as presented here:\n\n### Seeding your database with TypeScript or JavaScript[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-typescript-or-javascript \"Direct link to Seeding your database with TypeScript or JavaScript\")\n\n> If you're using TypeScript with PostgreSQL, SQLite or MySQL see also: [@snaplet/seed](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-snapletseed).\n\n*   TypeScript\n*   JavaScript\n\n1.  Create a new file named `seed.ts`. This can be placed anywhere within your project's folder structure. The example below places it in the `/prisma` folder.\n    \n2.  In the `seed.ts` file, import Prisma Client, initialize it and create some records. As an example, take the following Prisma schema with a `User` and `Post` model:\n    \n    schema.prisma\n    \n    ```\n    model User {  id    Int    @id @default(autoincrement())  email String @unique  name  String  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String  published Boolean  user      User    @relation(fields: [userId], references: [id])  userId    Int}\n    ```\n    \n    Create some new users and posts in your `seed.ts` file:\n    \n    seed.ts\n    \n    ```\n    import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const alice = await prisma.user.upsert({    where: { email: 'alice@prisma.io' },    update: {},    create: {      email: 'alice@prisma.io',      name: 'Alice',      posts: {        create: {          title: 'Check out Prisma with Next.js',          content: 'https://www.prisma.io/nextjs',          published: true,        },      },    },  })  const bob = await prisma.user.upsert({    where: { email: 'bob@prisma.io' },    update: {},    create: {      email: 'bob@prisma.io',      name: 'Bob',      posts: {        create: [          {            title: 'Follow Prisma on Twitter',            content: 'https://twitter.com/prisma',            published: true,          },          {            title: 'Follow Nexus on Twitter',            content: 'https://twitter.com/nexusgql',            published: true,          },        ],      },    },  })  console.log({ alice, bob })}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n    ```\n    \n3.  Add `typescript`, `ts-node` and `@types/node` development dependencies:\n    \n    ```\n    npm install -D typescript ts-node @types/node\n    ```\n    \n\n4.  Add the `prisma.seed` field to your `package.json` file:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"ts-node prisma/seed.ts\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"ts-node\": \"^9.1.1\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n    Some projects may require you to add compile options. When using Next.js for example, you would setup your seed script like so:\n    \n    package.json\n    \n    ```\n    \"prisma\": {  \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"},\n    ```\n    \n5.  To seed the database, run the `db seed` CLI command:\n    \n\n### Seeding your database via raw SQL queries[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-via-raw-sql-queries \"Direct link to Seeding your database via raw SQL queries\")\n\nYou can also make use of raw SQL queries in order to seed the database with data.\n\nWhile you can use a plain-text `.sql` file (such as a data dump) for that, it is often easier to place those raw queries, if they're of short size, into the `seed.js` file because it saves you the hassle of working out database connection strings and creating a dependency on a binary like `psql`.\n\nTo seed additional data to the `schema.prisma` above, add the following to the `seed.js` (or `seed.ts`) file:\n\nseed.js\n\n```\nasync function rawSql() {  const result = await prisma.$executeRaw`INSERT INTO \"User\" (\"id\", \"email\", \"name\") VALUES (3, 'foo@example.com', 'Foo') ON CONFLICT DO NOTHING;`  console.log({ result })}\n```\n\nand chain this function to the promise calls, such as the following change towards the end of the file:\n\nseed.js\n\n```\nmain()  .then(rawSql)  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n### Seeding your database via any language (with a Bash script)[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-via-any-language-with-a-bash-script \"Direct link to Seeding your database via any language (with a Bash script)\")\n\nIn addition to TypeScript and JavaScript, you can also use a Bash script (`seed.sh`) to seed your database in another language such as Go, or plain SQL.\n\n*   Go\n*   SQL\n\nThe following example runs a Go script in the same folder as `seed.sh`:\n\nseed.sh\n\n```\n#!/bin/sh# -e Exit immediately when a command returns a non-zero status.# -x Print commands before they are executedset -ex# Seeding commandgo run ./seed/\n```\n\n### Seeding your database with `@snaplet/seed`[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-snapletseed \"Direct link to seeding-your-database-with-snapletseed\")\n\n[`@snaplet/seed`](https://docs.snaplet.dev/seed/getting-started/overview) offers a toolkit designed to understand your database schema, enabling you to generate production-accurate data and efficiently seed your database. It uses the full power of TypeScript to provide you with a type-safe and auto-completed experience to write your seed scripts.\n\n`@snaplet/seed` supports PostgreSQL, SQLite and MySQL.\n\n1.  Begin by setting up a local database using `npx prisma migrate dev`. This example will use the following Prisma schema featuring a `User` and `Post` model:\n    \n    schema.prisma\n    \n    ```\n    model User {  id    Int    @id @default(autoincrement())  email String @unique  name  String  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String  published Boolean  user      User    @relation(fields: [userId], references: [id])  userId    Int}\n    ```\n    \n2.  Execute `npx @snaplet/seed init prisma/seed` to initialize Snaplet Seed in your Prisma project. This command generates the seed client and creates an example seed file at `prisma/seed/seed.ts`.\n    \n    > **Note:** Snaplet Seed also has an [AI-enhanced version](https://www.snaplet.dev/seed#ai). You can opt in for improved seed data quality with a free Snaplet account.\n    \n3.  Use the generated `@snaplet/seed` client within the `prisma/seed/seed.ts` file to compose your seeds.\n    \n    Here's how to create new users and posts by modifying the initially generated `prisma/seed/seed.ts` file:\n    \n    prisma/seed/seed.ts\n    \n    ```\n    /** * ! Executing this script will delete all data in your database and seed it with 10 users. * ! Make sure to adjust the script to your needs. * Use any TypeScript runner to run this script, for example: `npx tsx seed.ts` * Learn more about the Seed Client by following our guide: https://docs.snaplet.dev/seed/getting-started */import { createSeedClient } from \"@snaplet/seed\";async function main() {  const seed = await createSeedClient();    // Truncate all tables in the database  await seed.$resetDatabase();    // Seed the database with 10 users  await seed.user((createMany) => createMany(10, {    // Create 10 posts for each of those users    posts: (createMany) => createMany(10),  }))    console.log(\"Database seeded successfully!\");    process.exit();};main();\n    ```\n    \n4.  Add `tsx` (or any other typescript runners) as a development dependency:\n    \n5.  Insert the `prisma.seed` field into your `package.json` file and configure commands to seed your database:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"tsx prisma/seed/seed.ts\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"tsx\": \"^4.7.2\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n6.  To seed the database, execute the following CLI command:\n    \n7.  To ensure the seed client remains synchronized with your schema, add a `migrate` and `postmigrate` scripts to the package.json:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"npx tsx prisma/seed/seed.ts\"  },  \"scripts\": {    \"migrate\": \"prisma migrate dev\",    \"postmigrate\": \"npx @snaplet/seed sync\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"tsx\": \"^4.7.2\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n\nNow, instead of `npx prisma migrate dev` you can run `npm run migrate` which will also sync the seed client after schema changes and keep both your database and seed client in sync.\n\n### User-defined arguments[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#user-defined-arguments \"Direct link to User-defined arguments\")\n\n> This feature is available from version 4.15.0 and later.\n\n`prisma db seed` allows you to define custom arguments in your seed file that you can pass to the `prisma db seed` command. For example, you could define your own arguments to seed different data for different environments or partially seeding data in some tables.\n\nHere is an example seed file that defines a custom argument to seed different data in different environments:\n\n\"seed.js\"\n\n```\nimport { parseArgs } from 'node:util'const options = {  environment: { type: 'string' },}async function main() {  const {    values: { environment },  } = parseArgs({ options })  switch (environment) {    case 'development':      /** data for your development */      break    case 'test':      /** data for your test environment */      break    default:      break  }}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nYou can then provide the `environment` argument when using `prisma db seed` by adding a [delimiter](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02) — `--` —, followed by your custom arguments:\n\n```\nnpx prisma db seed -- --environment development\n```\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#going-further \"Direct link to Going further\")\n\nHere's a non-exhaustive list of other tools you can integrate with Prisma ORM in your development workflow to seed your database:\n\n*   [Snaplet](https://docs.snaplet.dev/recipes/prisma)\n*   [Replibyte](https://www.replibyte.com/docs/introduction)",
    "title": "Seeding | Prisma Documentation",
    "description": "Learn how to seed your database using Prisma ORM's integrated seeding functionality and Prisma Client",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database",
    "markdown": "# About the shadow database | Prisma Documentation\n\nThe shadow database is a second, _temporary_ database that is **created and deleted automatically**\\* each time you run `prisma migrate dev` and is primarily used to **detect problems** such as schema drift or potential data loss of the generated migration.\n\n[`migrate diff` command](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) also requires a shadow database when diffing against a local `migrations` directory with `--from-migrations` or `--to-migrations`.\n\n*   If your database does not allow creation and deleting of databases (e.g. in a cloud-hosted environment), you need to [create and configure the shadow database manually](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually).\n\nwarning\n\nThe shadow database is **not** required in production, and is not used by production-focused commands such as `prisma migrate resolve` and `prisma migrate deploy`.\n\nnote\n\nA shadow database is never used for MongoDB as `migrate dev` is not used there.\n\n## How the shadow database works[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#how-the-shadow-database-works \"Direct link to How the shadow database works\")\n\nWhen you run `prisma migrate dev` to create a new migration, Prisma Migrate uses the shadow database to:\n\n*   [Detect schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift), which means checking that no **unexpected changes** have been made to the development database\n*   [Generate new migrations](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations) and evaluate if those could lead to **data loss** when applied\n\n🎨 Expand to see the shadow database explained as a cartoon.\n\n![A cartoon that shows how the shadow database works.](https://www.prisma.io/docs/assets/images/shadow-database-4851f4376ca80c1b94316445aa5bd85b.png)\n\n### Detecting schema drift[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift \"Direct link to Detecting schema drift\")\n\nTo detect drift in development, Prisma Migrate:\n\n1.  Creates a fresh copy of the shadow database (or performs a soft reset if the shadow database is configured via [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource))\n2.  Reruns the **current**, existing migration history in the shadow database.\n3.  **Introspects** the shadow database to generate the 'current state' of your Prisma schema.\n4.  Compares the end state of the current migration history to the development database.\n5.  Reports **schema drift** if the end state of the current migration history (via the shadow database) does not match the development database (for example, due to a manual change)\n\nIf Prisma Migrate does not detect schema drift, it moves on to [generating new migrations](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations).\n\n> **Note**: The shadow database is not responsible for checking if a migration file has been **edited or deleted**. This is done using the `checksum` field in the `_prisma_migrations` table.\n\nIf Prisma Migrate detects schema drift, it outputs detailed information about which parts of the database have drifted. The following example output could be shown when the development database has been modified manually: The `Color` enum is missing the expected variant `RED` and includes the unexpected variant `TRANSPARENT`:\n\n```\n[*] Changed the `Color` enum  [+] Added variant `TRANSPARENT`  [-] Removed variant `RED`\n```\n\n### Generating new migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations \"Direct link to Generating new migrations\")\n\nAssuming Prisma Migrate did not [detect schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift), it moves on to generating new migrations from Prisma schema changes. To generate new migrations, Prisma Migrate:\n\n1.  Calculates the target database schema as a function of the current Prisma schema.\n2.  Compares the end state of the existing migration history and the target schema, and generates steps to get from one to the other.\n3.  Renders these steps to a SQL string and saves it in the new migration file.\n4.  Evaluate data loss caused by the SQL and warns about that.\n5.  Applies the generated migration to the development database (assuming you have not specified the `--create-only` flag)\n6.  Drops the shadow database (shadow databases configured via [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) are not dropped, but are reset at the start of the `migrate dev` command)\n\n## Manually configuring the shadow database[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#manually-configuring-the-shadow-database \"Direct link to Manually configuring the shadow database\")\n\nIn some cases it might make sense (e.g. when [creating and dropping databases is not allowed on cloud-hosted databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually)) to manually define the connection string and name of the database that should be used as the shadow database for `migrate dev`. In such a case you can:\n\n1.  Create a dedicated database that should be used as the shadow database\n2.  Add the connection string of that database your environment variable `SHADOW_DATABASE_URL` (or `.env` file)\n3.  Add the [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) field reading this environment variable:\n\n```\ndatasource db {  provider          = \"postgresql\"  url               = env(\"DATABASE_URL\")  shadowDatabaseUrl = env(\"SHADOW_DATABASE_URL\")}\n```\n\n> **Important**: Do not use the exact same values for `url` and `shadowDatabaseUrl` as that might delete all your database in your database.\n\n## Cloud-hosted shadow databases must be created manually[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually \"Direct link to Cloud-hosted shadow databases must be created manually\")\n\nSome cloud providers do not allow you to drop and create databases with SQL. Some require to create or drop the database via an online interface, and some really limit you to 1 database. If you **develop** in such a cloud-hosted environment, you must:\n\n1.  Create a dedicated cloud-hosted shadow database\n2.  Add the URL to your environment variable `SHADOW_DATABASE_URL`\n3.  Add the [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) field reading this environment variable:\n\n```\ndatasource db {  provider          = \"postgresql\"  url               = env(\"DATABASE_URL\")  shadowDatabaseUrl = env(\"SHADOW_DATABASE_URL\")}\n```\n\n> **Important**: Do not use the same values for `url` and `shadowDatabaseUrl`.\n\n## Shadow database user permissions[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#shadow-database-user-permissions \"Direct link to Shadow database user permissions\")\n\nIn order to create and delete the shadow database when using `migrate dev`, Prisma Migrate currently requires that the database user defined in your `datasource` has permission to **create databases**.\n\n| Database | Database user requirements |\n| --- | --- |\n| SQLite | No special requirements. |\n| MySQL/MariaDB | Database user must have `CREATE, ALTER, DROP, REFERENCES ON *.*` privileges |\n| PostgreSQL | The user must be a super user or have `CREATEDB` privilege. See `CREATE ROLE` ([PostgreSQL official documentation](https://www.postgresql.org/docs/12/sql-createrole.html)) |\n| Microsoft SQL Server | The user must be a site admin or have the `SERVER` securable. See the [official documentation](https://docs.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine?view=sql-server-ver15). |\n\n> If you use a cloud-hosted database for development and can not use these permissions, see: [Cloud-hosted shadow databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually)\n\n> Note: The automatic creation of shadow databases is disabled on Azure SQL for example.\n\nPrisma Migrate throws the following error if it cannot create the shadow database with the credentials your connection URL supplied:\n\n```\nError: A migration failed when applied to the shadow databaseDatabase error: Error querying the database: db error: ERROR: permission denied to create database\n```\n\nTo resolve this error:\n\n*   If you are working locally, we recommend that you update the database user's privileges.\n*   If you are developing against a database that does not allow creating and dropping databases (for any reason) see [Manually configuring the shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#manually-configuring-the-shadow-database)\n*   If you are developing against a cloud-based database (for example, on Heroku, Digital Ocean, or Vercel Postgres) see: [Cloud-hosted shadow databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually).\n*   If you are developing against a cloud-based database (for example, on Heroku, Digital Ocean, or Vercel Postgres) and are currently **prototyping** such that you don't care about generated migration files and only need to apply your Prisma schema to the database schema, you can run [`prisma db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db) instead of the `prisma migrate dev` command.\n\n> **Important**: The shadow database is _only_ required in a development environment (specifically for the `prisma migrate dev` command) - you **do not** need to make any changes to your production environment.",
    "title": "About the shadow database | Prisma Documentation",
    "description": "About the shadow database",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4",
    "markdown": "# Upgrade to Prisma ORM 4\n\nPrisma ORM 4 introduces a number of **breaking changes** when you upgrade from an earlier Prisma ORM version. This guide explains how this upgrade might affect your application and gives instructions on how to handle any changes.\n\n## Breaking changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#breaking-changes \"Direct link to Breaking changes\")\n\nThis section gives an overview of breaking changes in Prisma ORM 4, grouped under [general changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#general-changes) that affect both the Prisma Schema and Prisma Client, [Schema changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#schema-changes) and [Client changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes).\n\nWe recommend that you first address any Prisma schema validation errors, then pull your database to reflect new Prisma schema capabilities, and finally fix any type errors in Prisma Client and validate by running your test suite.\n\n### Upgrade your Prisma Schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-your-prisma-schema \"Direct link to Upgrade your Prisma Schema\")\n\n1.  Carefully skim the list of changes and check if you are impacted by a breaking change.\n2.  Review the Prisma schema validation errors (via `npx prisma validate`, or via the Prisma VS Code extension).\n    1.  If you don't have validation errors, continue with step 3.\n    2.  If you have validation errors:\n        1.  Try to map the validation error to a change from the list below to understand which change caused the invalid Prisma schema, and read the linked instructions for how to upgrade. It can only come from:\n            *   [Explicit unique constraints for 1:1 relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#explicit-unique-constraints-on-one-to-one-relations)\n            *   [Removed support for usage of `references` on implicit many-to-many relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#disallow-references-syntax-for-implicit-many-to-many-relations)\n            *   [Enforced uniqueness of referenced fields in the `references` argument in one-to-one and one-to-many relations for MySQL and MongoDB](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb)\n            *   Removal of undocumented support for the `type` alias\n            *   Removal of the `sqlite` protocol for SQLite URLs\n            *   [Better grammar for string literals](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#better-grammar-for-string-literals)\n3.  Repeat until your Prisma schema is valid.\n4.  Run `npx prisma db pull` to upgrade the Prisma schema to all new capabilities (e.g. `extendedIndexes`).\n5.  Review changes of the Prisma schema and verify validity.\n6.  Continue with Prisma Client steps.\n\n### Upgrade your use of Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-your-use-of-prisma-client \"Direct link to Upgrade your use of Prisma Client\")\n\n1.  Carefully skim the [list of changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes) to understand if you are impacted by a breaking change.\n    1.  If yes, read the detailed upgrade instructions.\n    2.  If no, proceed with 2.\n2.  Some API changes in Prisma Client are impacting runtime behavior, so please run your test suite.\n\nEnjoy Prisma ORM 4!\n\n### General changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#general-changes \"Direct link to General changes\")\n\nThis section includes changes that affect both the Prisma Schema and Prisma Client.\n\n#### Node.js minimum version change[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#nodejs-minimum-version-change \"Direct link to Node.js minimum version change\")\n\nFrom Prisma ORM version 4.0.0, the minimum version of Node.js that we support is 14.17.x. If you use an earlier version of Node.js, you will need to update it.\n\nSee our [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for all minimum version requirements.\n\n### Schema changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#schema-changes \"Direct link to Schema changes\")\n\nThis section includes changes that affect the Prisma Schema.\n\n#### Index configuration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#index-configuration \"Direct link to Index configuration\")\n\nIn Prisma ORM 4, the `extendedIndexes` Preview feature will now become generally available. This includes the following index configuration options:\n\n*   Length configuration of indexes, unique constraints and primary key constraints for MySQL (in Preview in versions 3.5.0 and later)\n*   Sort order configuration of indexes, unique constraints and primary key constraints (in Preview in versions 3.5.0 and later)\n*   New index types for PostgreSQL: Hash (in Preview in versions 3.6.0 and later) and GIN, GiST, SP-GiST and BRIN (in Preview in versions 3.14.0 and later)\n*   Index clustering for SQL Server (in Preview in versions 3.13.0 and later)\n\nSee our documentation on [Index configuration](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#index-configuration) for more details of these features.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path \"Direct link to Upgrade path\")\n\nThese can all be breaking changes if you were previously configuring these properties at the database level. In this case, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Run `npx prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `npx prisma db push` or `npx prisma migrate dev` command, or you may lose any configuration that was defined in the database but not previously represented in the Prisma schema.\n\nFor more details, see the [Upgrading from previous versions](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#upgrading-from-previous-versions) section of our index configuration documentation.\n\n#### Scalar list defaults[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#scalar-list-defaults \"Direct link to Scalar list defaults\")\n\nFor database connectors that support scalar lists (PostgreSQL, CockroachDB and MongoDB), Prisma ORM 4 introduces the ability to set a default value in your Prisma schema with the `@default` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id             Int      @id @default(autoincrement())  posts          Post[]  favoriteColors String[] @default([\"red\", \"yellow\", \"purple\"])}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-1 \"Direct link to Upgrade path\")\n\nThis is a breaking change if you previously had defaults defined for scalar lists at the database level. In this case, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Run `npx prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `npx prisma db push` or `npx prisma migrate dev` command, or you will lose any defaults that are defined in the database but not previously represented in the Prisma schema.\n\n#### Explicit `@unique` constraints on one-to-one relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#explicit-unique-constraints-on-one-to-one-relations \"Direct link to explicit-unique-constraints-on-one-to-one-relations\")\n\nWhen using one-to-one relations in Prisma ORM 4, you will need to explicitly add the `@unique` attribute to the relation scalar field. For example, for this one-to-one relation between a `User` and a `Profile` model, you will need to add the `@unique` attribute to the `profileId` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id])  profileId Int?     @unique // <-- include this explicitly}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-2 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any one-to-one relations without a `@unique` attribute on the relation scalar will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n    \n2.  Manually fix the validation errors in your Prisma schema by adding the explicit `@unique` or `@id` attribute to your data model.\n    \n3.  Push the changes to your database using `prisma db push` for MongoDB or `prisma migrate dev` for MySQL.\n    \n\n#### Enforced use of `@unique` or `@id` attribute for one-to-one and one-to-many relations (MySQL and MongoDB)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb \"Direct link to enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb\")\n\nWhen you use one-to-one and one-to-many relations in Prisma ORM 4, you will need to use a `@unique` attribute on the relation field to guarantee that the singular side(s) of the relation has only one record. This is now enforced for MySQL and MongoDB, bringing them into line with other connectors. Missing `@unique` attributes will now trigger a validation error.\n\nIn the following example of a _one-to-many relation_ between a `User` and `Post` model, the `@unique` attribute must be added to the `email` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique // <-- we enforce this attribute  posts Post[]}model Post {  id          Int    @id @default(autoincrement())  authorEmail String  author      User   @relation(fields: [authorEmail], references: [email])}\n```\n\nIn the following example of a _one-to-one relation_ between a `User` and `Profile` model, the `@unique` attribute must be added to the `email` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  email     String  @unique // <- we enforce this unique attribute  profile   Profile @relation(fields: [profileId], references: [id])  profileId Int}model Profile {  id        Int     @id @default(autoincrement())  userEmail String? @unique  user      User?}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-3 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any one-to-one or one-to-many relations without a `@unique` or `@id` attribute on the relation field will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `npx prisma db pull` will add the `@unique` attributes automatically.\n\n#### Disallow `references` syntax for implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#disallow-references-syntax-for-implicit-many-to-many-relations \"Direct link to disallow-references-syntax-for-implicit-many-to-many-relations\")\n\nWhen using [implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) in Prisma ORM 4, you will no longer be able to use the `references` argument, which was previously optional. For example, the following relation would now trigger a validation error:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"my-relation\", references: [id]) // <-- validation error}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"my-relation\", references: [id]) // <-- validation error}\n```\n\nInstead, you can write:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"my-relation\")}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"my-relation\")}\n```\n\nThis is because the only valid value for `references` was `id`, so removing this argument makes it clearer what can and cannot be changed.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-4 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any implicit many-to-many relations with a `references` argument will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `npx prisma db pull` will remove the `references` arguments automatically.\n\n#### Better grammar for string literals[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#better-grammar-for-string-literals \"Direct link to Better grammar for string literals\")\n\nString literals in your Prisma Schema now need to follow the same rules as strings in JSON. This mostly changes the escaping of some special characters. More details can be found in [the JSON specification](https://www.ietf.org/rfc/rfc4627.txt) or on the [JSON website](https://www.json.org/json-en.html).\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-5 \"Direct link to Upgrade path\")\n\nThis is a breaking change for some existing schemas. After you upgrade to Prisma ORM 4, incorrectly escaped characters will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema.\n\n### Client changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes \"Direct link to Client changes\")\n\nThis section includes changes that affect Prisma Client.\n\n#### Raw query type mapping: scalar values are now deserialized as their correct JavaScript types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-type-mapping-scalar-values-are-now-deserialized-as-their-correct-javascript-types \"Direct link to Raw query type mapping: scalar values are now deserialized as their correct JavaScript types\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nRaw queries now deserialize scalar values to their corresponding JavaScript types. Note that Prisma ORM infers types from the values themselves and not from the Prisma Schema types.\n\nExample query and response:\n\n```\nconst res =  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM \"Table\";`console.log(res) // [{ bigint: BigInt(\"123\"), bytes: Buffer.from([1, 2]), decimal: new Prisma.Decimal(\"12.34\"), date: Date(\"<some_date>\") }]\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-6 \"Direct link to Upgrade path\")\n\nFrom version 4.0.0, some data types returned by `queryRaw` or `queryRawUnsafe` are different, as follows:\n\n| Data type | Before version 4.0.0 | From version 4.0.0 |\n| --- | --- | --- |\n| `DateTime` | Returned as `String` | Returned as `Date` |\n| `Numeric` | Returned as `Float` | Returned as `Decimal` |\n| `Bytes` | Returned as `String` | Returned as `Buffer` |\n| `Int64` | Returned as `Integer` | Returned as `BigInt` |\n\nIf you use `queryRaw` or `queryRawUnsafe` to return any of the above data types, then you must change your code to handle the new types.\n\nFor example, if you return `DateTime` data, then you need to take into account the following:\n\n*   You no longer need to manually instantiate a `DateTime` object for the returned data.\n*   If your code currently uses the returned `String` data, then you now need to convert the `DateTime` object to a `String`.\n\nYou must make equivalent code changes for the other data types in the table above.\n\n#### Raw query mapping: PostgreSQL type-casts[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-mapping-postgresql-type-casts \"Direct link to Raw query mapping: PostgreSQL type-casts\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nBefore version 4.0.0, many PostgreSQL type-casts did not work. We have tightened the type coercion rules so that all type-casts now work. As a result, some implicit casts now fail.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-7 \"Direct link to Upgrade path\")\n\nWe recommend that you re-test your use of `$queryRaw` to ensure that the types you pass into your raw queries match the types that PostgreSQL expects.\n\nFor example, in version 4.0.0, the following query fails:\n\n```\nawait prisma.$queryRaw`select length(${42});`// ERROR: function length(integer) does not exist// HINT: No function matches the given name and argument types. You might need to add explicit type casts.\n```\n\nThis is because PostgreSQL’s `length` function expects `text` as input. Prisma ORM used to silently coerce `42` to `text`, but does not do this in version 4.0.0. To fix this, explicitly cast `42` to `text` as follows:\n\n```\nawait prisma.$queryRaw`select length(${42}::text);`\n```\n\n#### Raw query mapping: PostgreSQL and JavaScript integers[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-mapping-postgresql-and-javascript-integers \"Direct link to Raw query mapping: PostgreSQL and JavaScript integers\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nPrisma ORM sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-8 \"Direct link to Upgrade path\")\n\nIf you use `$queryRaw` or parametrized `$queryRawUnsafe`queries with a PostgreSQL database, do one of the following:\n\n*   Update the input types of any integers in your user-defined functions to `INT8`, or\n*   Cast any integers in your query parameters to `INT4`.\n\n#### `DbNull`, `JsonNull` and `AnyNull` are now objects[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#dbnull-jsonnull-and-anynull-are-now-objects \"Direct link to dbnull-jsonnull-and-anynull-are-now-objects\")\n\nJavaScript `null` is ambiguous for JSON columns, so Prisma ORM uses `DbNull`, `JsonNull`, and `AnyNull` to distinguish between the database `NULL` value and the JSON `null` value. Before version 4.0.0, `DbNull`, `JsonNull`, and `AnyNull` were string constants. From version 4.0.0, they are objects.\n\nSee [Filtering by null values](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-by-null-values) for more information.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-9 \"Direct link to Upgrade path\")\n\n1.  If you use literal strings to address these values, then you must replace them with the following named constants:\n    \n    *   `DbNull`: replace with `Prisma.DbNull`\n    *   `JsonNull`: replace with `Prisma.JsonNull`\n    *   `AnyNull`: replace with `Prisma.AnyNull`\n    \n    If you already use these named constants, then you do not need to take any action.\n    \n2.  If you now get a type error when you pass `Prisma.DbNull` as the value of a JSON field, then this probably indicates a bug in your code that our types did not catch before version 4.0.0. The field where you tried to store `DbNull` is probably not nullable in your schema. As a result, a literal `DbNull` string was stored in the database instead of `NULL`.\n    \n3.  You might now encounter a type error or runtime validation error when you use `Prisma.DbNull`, `Prisma.JsonNull`, or `Prisma.AnyNull` with MongoDB. This was never valid, but was silently accepted prior to Prisma ORM 4. You need to review your data and change these fields to `null`.\n    \n4.  If you pass in dynamic JSON to a JSON column in Prisma Client (for example `prisma.findMany({where: { jsonColumn: someJson } })`), then you must check that `someJson`cannot be the string \"DBNull\", \"JsonNull\", or \"AnyNull\". If it is any of these values, then the query will return different results in version 4.0.0.\n    \n\n#### Default fields on composite types in MongoDB[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#default-fields-on-composite-types-in-mongodb \"Direct link to Default fields on composite types in MongoDB\")\n\nFrom version 4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.\n\nConditions:\n\n*   A field on the composite type is required, and\n*   this field has a default value, and\n*   this field is not present in the returned document or documents.\n\nThis behavior is now consistent with the behavior for model fields.\n\nTo learn more, see [Default values for required fields on composite types](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#default-values-for-required-fields-on-composite-types).\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-10 \"Direct link to Upgrade path\")\n\nIf you currently rely on a return value of `null`, then you need to refactor your code to handle the default value that is now returned in Prisma ORM 4.\n\n#### Rounding errors on big numbers in SQLite[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#rounding-errors-on-big-numbers-in-sqlite \"Direct link to Rounding errors on big numbers in SQLite\")\n\nSQLite is a loosely-typed database. If your schema has a field with type `Int`, then Prisma ORM prevents you from inserting a value larger than an integer. However, nothing prevents the database from directly accepting a bigger number. These manually-inserted big numbers cause rounding errors when queried.\n\nTo avoid this problem, Prisma ORM version 4.0.0 and later checks numbers on the way out of the database to verify that they fit within the boundaries of an integer. If a number does not fit, then Prisma ORM throws a P2023 error, such as:\n\n```\nInconsistent column data: Conversion failed:Value 9223372036854775807 does not fit in an INT column,try migrating the 'int' column type to BIGINT\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-11 \"Direct link to Upgrade path\")\n\nIf you use Prisma ORM in conjunction with SQLite, then you need to find any code that queries `Int` fields and ensure that it handles any P2023 errors that might be returned.\n\n#### Prisma ORM no longer exports `Prisma.dmmf.schema` into the generated Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#prisma-orm-no-longer-exports-prismadmmfschema-into-the-generated-prisma-client \"Direct link to prisma-orm-no-longer-exports-prismadmmfschema-into-the-generated-prisma-client\")\n\nFrom version 4.0.0, Prisma ORM no longer exports `Prisma.dmmf.schema` into the generated Prisma Client. This makes the generated Prisma Client much more efficient, and also avoids some memory leaks with Jest.\n\nNote:\n\n*   This change does not affect the DMMF that Prisma ORM passes to the generators.\n*   You can use `getDmmf()`from `@prisma/internals` to access the schema property.\n*   We still export `Prisma.dmmf.datamodel` into the generated Prisma Client.\n\n## Upgrade the `prisma` and `@prisma/client` packages to version 4[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4 \"Direct link to upgrade-the-prisma-and-prismaclient-packages-to-version-4\")\n\nTo upgrade to Prisma ORM 4 from an earlier version, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number. This allows upgrades to new minor versions, but not major versions, to safeguard against breaking changes.\n\nTo ignore the caret `^` and upgrade across major versions, you can use the `@4` tag when you upgrade with `npm`, or `yarn`:\n\ndanger\n\nBefore you upgrade, check each **breaking change** to see how the upgrade might affect your application.\n\n*   npm\n*   yarn\n\n```\nnpm install prisma@4 @prisma/client@4\n```\n\n## Video guide[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#video-guide \"Direct link to Video guide\")\n\nFor a video walkthrough of the upgrade process and examples of upgrade scenarios, see our recorded livestream on upgrading to Prisma ORM 4:",
    "title": "Upgrade to Prisma ORM 4 | Prisma Documentation",
    "description": "Guides on how to upgrade to Prisma ORM 4",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays",
    "markdown": "# Working with scalar lists/arrays (Concepts)\n\n[Scalar lists](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier) are represented by the `[]` modifier and are only available if the underlying database supports scalar lists. The following example has one scalar `String` list named `pets`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   Int      @id @default(autoincrement())  name String  pets String[]}\n```\n\nExample field value:\n\n```\n['Fido', 'Snoopy', 'Brian']\n```\n\n## Setting the value of a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#setting-the-value-of-a-scalar-list \"Direct link to Setting the value of a scalar list\")\n\nThe following example demonstrates how to [`set`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-1) the value of a scalar list (`coinflips`) when you create a model:\n\n```\nconst createdUser = await prisma.user.create({  data: {    email: 'eloise@prisma.io',    coinflips: [true, true, true, false, true],  },})\n```\n\n## Unsetting the value of a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#unsetting-the-value-of-a-scalar-list \"Direct link to Unsetting the value of a scalar list\")\n\nwarning\n\nThis method is available on MongoDB only in versions [3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.\n\nThe following example demonstrates how to [`unset`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unset) the value of a scalar list (`coinflips`):\n\n```\nconst createdUser = await prisma.user.create({  data: {    email: 'eloise@prisma.io',    coinflips: {      unset: true,    },  },})\n```\n\nUnlike `set: null`, `unset` removes the list entirely.\n\n## Adding items to a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#adding-items-to-a-scalar-list \"Direct link to Adding items to a scalar list\")\n\nwarning\n\nAvailable for:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n*   MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later\n\nUse the [`push`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#push) method to add a single value to a scalar list:\n\n```\nconst userUpdate = await prisma.user.update({  where: {    id: 9,  },  data: {    coinflips: {      push: true,    },  },})\n```\n\nIn earlier versions, you have to overwrite the entire value. The following example retrieves user, uses `push()` to add three new coin flips, and overwrites the `coinflips` field in an `update`:\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'eloise@prisma.io',  },})if (user) {  console.log(user.coinflips)  user.coinflips.push(true, true, false)  const updatedUser = await prisma.user.update({    where: {      email: 'eloise@prisma.io',    },    data: {      coinflips: user.coinflips,    },  })  console.log(updatedUser.coinflips)}\n```\n\n## Filtering scalar lists[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#filtering-scalar-lists \"Direct link to Filtering scalar lists\")\n\nwarning\n\nAvailable for:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n*   MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later\n\nUse [scalar list filters](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-filters) to filter for records with scalar lists that match a specific condition. The following example returns all posts where the tags list includes `databases` _and_ `typescript`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      hasEvery: ['databases', 'typescript'],    },  },})\n```\n\n### `NULL` values in arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#null-values-in-arrays \"Direct link to null-values-in-arrays\")\n\nwarning\n\nThis section applies to:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n\nWhen using scalar list filters with a relational database connector, array fields with a `NULL` value are not considered by the following conditions:\n\n*   `NOT` (array does not contain X)\n*   `isEmpty` (array is empty)\n\nThis means that records you might expect to see are not returned. Consider the following examples:\n\n*   The following query returns all posts where the `tags` **do not** include `databases`:\n    \n    ```\n    const posts = await prisma.post.findMany({  where: {    NOT: {      tags: {        has: 'databases',      },    },  },})\n    ```\n    \n    *   ✔ Arrays that do not contain `\"databases\"`, such as `{\"typescript\", \"graphql\"}`\n    *   ✔ Empty arrays, such as `[]`\n    \n    The query does not return:\n    \n    *   ✘ `NULL` arrays, even though they do not contain `\"databases\"`\n\nThe following query returns all posts where `tags` is empty:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      isEmpty: true,    },  },})\n```\n\nThe query returns:\n\n*   ✔ Empty arrays, such as `[]`\n\nThe query does not return:\n\n*   ✘ `NULL` arrays, even though they could be considered empty\n\nTo work around this issue, you can set the default value of array fields to `[]`.",
    "title": "Working with scalar lists/arrays (Concepts) | Prisma Documentation",
    "description": "How to read, write, and filter by scalar lists / arrays.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names",
    "markdown": "# Custom model and field names\n\nThe Prisma Client API is generated based on the models in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema). Models are _typically_ 1:1 mappings of your database tables.\n\nIn some cases, especially when using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), it might be useful to _decouple_ the naming of database tables and columns from the names that are used in your Prisma Client API. This can be done via the [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections) attributes in your Prisma schema.\n\nYou can use `@map` and `@@map` to rename MongoDB fields and collections respectively. This page uses a relational database example.\n\n## Example: Relational database[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#example-relational-database \"Direct link to Example: Relational database\")\n\nAssume you have a PostgreSQL relational database schema looking similar to this:\n\n```\nCREATE TABLE users (\tuser_id SERIAL PRIMARY KEY NOT NULL,\tname VARCHAR(256),\temail VARCHAR(256) UNIQUE NOT NULL);CREATE TABLE posts (\tpost_id SERIAL PRIMARY KEY NOT NULL,\tcreated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\ttitle VARCHAR(256) NOT NULL,\tcontent TEXT,\tauthor_id INTEGER REFERENCES users(user_id));CREATE TABLE profiles (\tprofile_id SERIAL PRIMARY KEY NOT NULL,\tbio TEXT,\tuser_id INTEGER NOT NULL UNIQUE REFERENCES users(user_id));CREATE TABLE categories (\tcategory_id SERIAL PRIMARY KEY NOT NULL,\tname VARCHAR(256));CREATE TABLE post_in_categories (\tpost_id INTEGER NOT NULL REFERENCES posts(post_id),\tcategory_id INTEGER NOT NULL REFERENCES categories(category_id));CREATE UNIQUE INDEX post_id_category_id_unique ON post_in_categories(post_id int4_ops,category_id int4_ops);\n```\n\nWhen introspecting a database with that schema, you'll get a Prisma schema looking similar to this:\n\n```\nmodel categories {  category_id        Int                  @id @default(autoincrement())  name               String?              @db.VarChar(256)  post_in_categories post_in_categories[]}model post_in_categories {  post_id     Int  category_id Int  categories  categories @relation(fields: [category_id], references: [category_id], onDelete: NoAction, onUpdate: NoAction)  posts       posts      @relation(fields: [post_id], references: [post_id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")}model posts {  post_id            Int                  @id @default(autoincrement())  created_at         DateTime?            @default(now()) @db.Timestamptz(6)  title              String               @db.VarChar(256)  content            String?  author_id          Int?  users              users?               @relation(fields: [author_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories post_in_categories[]}model profiles {  profile_id Int     @id @default(autoincrement())  bio        String?  user_id    Int     @unique  users      users   @relation(fields: [user_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)}model users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\nThere are a few \"issues\" with this Prisma schema when the Prisma Client API is generated:\n\n**Adhering to Prisma ORM's naming conventions**\n\nPrisma ORM has a [naming convention](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) of **camelCasing** and using the **singular form** for Prisma models. If these naming conventions are not met, the Prisma schema can become harder to interpret and the generated Prisma Client API will feel less natural. Consider the following, generated model:\n\n```\nmodel users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\nAlthough `profiles` refers to a 1:1 relation, its type is currently called `profiles` in plural, suggesting that there might be many `profiles` in this relation. With Prisma ORM conventions, the models and fields were _ideally_ named as follows:\n\n```\nmodel User {  user_id Int      @id @default(autoincrement())  name    String?  @db.VarChar(256)  email   String   @unique @db.VarChar(256)  posts   Post[]  profile Profile?}\n```\n\nBecause these fields are \"Prisma ORM-level\" [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) that do not manifest you can manually rename them in your Prisma schema.\n\n**Naming of annotated relation fields**\n\nForeign keys are represented as a combination of a [annotated relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) and its corresponding relation scalar field in the Prisma schema. Here's how all the relations from the SQL schema are currently represented:\n\n```\nmodel categories {  category_id        Int                  @id @default(autoincrement())  name               String?              @db.VarChar(256)  post_in_categories post_in_categories[] // virtual relation field}model post_in_categories {  post_id     Int // relation scalar field  category_id Int // relation scalar field  categories  categories @relation(fields: [category_id], references: [category_id], onDelete: NoAction, onUpdate: NoAction) // virtual relation field  posts       posts      @relation(fields: [post_id], references: [post_id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")}model posts {  post_id            Int                  @id @default(autoincrement())  created_at         DateTime?            @default(now()) @db.Timestamptz(6)  title              String               @db.VarChar(256)  content            String?  author_id          Int?  users              users?               @relation(fields: [author_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories post_in_categories[]}model profiles {  profile_id Int     @id @default(autoincrement())  bio        String?  user_id    Int     @unique  users      users   @relation(fields: [user_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)}model users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\n## Using `@map` and `@@map` to rename fields and models in the Prisma Client API[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api \"Direct link to using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api\")\n\nYou can \"rename\" fields and models that are used in Prisma Client by mapping them to the \"original\" names in the database using the `@map` and `@@map` attributes. For the example above, you could e.g. annotate your models as follows.\n\n_After_ you introspected your database with `prisma db pull`, you can manually adjust the resulting Prisma schema as follows:\n\n```\nmodel Category {  id                 Int                @id @default(autoincrement()) @map(\"category_id\")  name               String?            @db.VarChar(256)  post_in_categories PostInCategories[]  @@map(\"categories\")}model PostInCategories {  post_id     Int  category_id Int  categories  Category @relation(fields: [category_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  posts       Post     @relation(fields: [post_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")  @@map(\"post_in_categories\")}model Post {  id                 Int                @id @default(autoincrement()) @map(\"post_id\")  created_at         DateTime?          @default(now()) @db.Timestamptz(6)  title              String             @db.VarChar(256)  content            String?  author_id          Int?  users              User?              @relation(fields: [author_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories PostInCategories[]  @@map(\"posts\")}model Profile {  id      Int     @id @default(autoincrement()) @map(\"profile_id\")  bio     String?  user_id Int     @unique  users   User    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  @@map(\"profiles\")}model User {  id       Int      @id @default(autoincrement()) @map(\"user_id\")  name     String?  @db.VarChar(256)  email    String   @unique @db.VarChar(256)  posts    Post[]  profiles Profile?  @@map(\"users\")}\n```\n\nWith these changes, you're now adhering to Prisma ORM's naming conventions and the generated Prisma Client API feels more \"natural\":\n\n```\n// Nested writesconst profile = await prisma.profile.create({  data: {    bio: 'Hello World',    users: {      create: {        name: 'Alice',        email: 'alice@prisma.io',      },    },  },})// Fluent APIconst userByProfile = await prisma.profile  .findUnique({    where: { id: 1 },  })  .users()\n```\n\n## Renaming relation fields[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#renaming-relation-fields \"Direct link to Renaming relation fields\")\n\nPrisma ORM-level [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) (sometimes referred to as \"virtual relation fields\") only exist in the Prisma schema, but do not actually manifest in the underlying database. You can therefore name these fields whatever you want.\n\nConsider the following example of an ambiguous relation in a SQL database:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"author\" integer NOT NULL,    \"favoritedBy\" INTEGER,    FOREIGN KEY (\"author\") REFERENCES \"User\"(id),    FOREIGN KEY (\"favoritedBy\") REFERENCES \"User\"(id));\n```\n\nPrisma ORM's introspection will output the following Prisma schema:\n\n```\nmodel Post {  id                          Int   @id @default(autoincrement())  author                      Int  favoritedBy                 Int?  User_Post_authorToUser      User  @relation(\"Post_authorToUser\", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)  User_Post_favoritedByToUser User? @relation(\"Post_favoritedByToUser\", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id                          Int    @id @default(autoincrement())  Post_Post_authorToUser      Post[] @relation(\"Post_authorToUser\")  Post_Post_favoritedByToUser Post[] @relation(\"Post_favoritedByToUser\")}\n```\n\nBecause the names of the virtual relation fields `Post_Post_authorToUser` and `Post_Post_favoritedByToUser` are based on the generated relation names, they don't look very friendly in the Prisma Client API. In that case, you can rename the relation fields. For example:\n\n```\nmodel Post {  id                          Int   @id @default(autoincrement())  author                      Int  favoritedBy                 Int?  User_Post_authorToUser      User  @relation(\"Post_authorToUser\", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)  User_Post_favoritedByToUser User? @relation(\"Post_favoritedByToUser\", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id             Int    @id @default(autoincrement())  writtenPosts   Post[] @relation(\"Post_authorToUser\")  favoritedPosts Post[] @relation(\"Post_favoritedByToUser\")}\n```\n\ninfo\n\n`prisma db pull` preserves custom relation fields defined in your Prisma schema on re-introspecting your database.",
    "title": "Custom model and field names | Prisma Documentation",
    "description": "Learn how you can decouple the naming of Prisma models from database tables to improve the ergonomics of the generated Prisma Client API.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping",
    "markdown": "# Database mapping | Prisma Documentation\n\nThe [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) includes mechanisms that allow you to define names of certain database objects. You can:\n\n*   [Map model and field names to different collection/table and field/column names](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#mapping-collectiontable-and-fieldcolumn-names)\n*   [Define constraint and index names](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names)\n\n## Mapping collection/table and field/column names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#mapping-collectiontable-and-fieldcolumn-names \"Direct link to Mapping collection/table and field/column names\")\n\nSometimes the names used to describe entities in your database might not match the names you would prefer in your generated API. Mapping names in the Prisma schema allows you to influence the naming in your Client API without having to change the underlying database names.\n\nA common approach for naming tables/collections in databases for example is to use plural form and [snake\\_case](https://en.wikipedia.org/wiki/Snake_case) notation. However, we recommended a different [naming convention (singular form, PascalCase)](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\n`@map` and `@@map` allow you to [tune the shape of your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) by decoupling model and field names from table and column names in the underlying database.\n\n### Map collection / table names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-collection--table-names \"Direct link to Map collection / table names\")\n\nAs an example, when you [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) a database with a table named `comments`, the resulting Prisma model will look like this:\n\n```\nmodel comments {  // Fields}\n```\n\nHowever, you can still choose `Comment` as the name of the model (e.g. to follow the naming convention) without renaming the underlying `comments` table in the database by using the [`@@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1) attribute:\n\n```\nmodel Comment {  // Fields  @@map(\"comments\")}\n```\n\nWith this modified model definition, Prisma Client automatically maps the `Comment` model to the `comments` table in the underlying database.\n\n### Map field / column names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-field--column-names \"Direct link to Map field / column names\")\n\nYou can also [`@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map) a column/field name:\n\n```\nmodel Comment {  content String @map(\"comment_text\")  email   String @map(\"commenter_email\")  type    Enum   @map(\"comment_type\")  @@map(\"comments\")}\n```\n\nThis way the `comment_text` column is not available under `prisma.comment.comment_text` in the Prisma Client API, but can be accessed via `prisma.comment.content`.\n\n### Map enum names and values[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-enum-names-and-values \"Direct link to Map enum names and values\")\n\nYou can also `@map` an enum value, or `@@map` an enum:\n\n```\nenum Type {  Blog,  Twitter @map(\"comment_twitter\")  @@map(\"comment_source_enum\")}\n```\n\n## Constraint and index names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names \"Direct link to Constraint and index names\")\n\nYou can optionally use the `map` argument to explicitly define the **underlying constraint and index names** in the Prisma schema for the attributes [`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id), [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1), [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique), [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1), [`@@index`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index) and [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation). (This is available in Prisma ORM version [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) and later.)\n\nWhen introspecting a database, the `map` argument will _only_ be rendered in the schema if the name _differs_ from Prisma ORM's [default constraint naming convention for indexes and constraints](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints).\n\ndanger\n\nIf you use Prisma Migrate in a version earlier than 2.29.0 and want to maintain your existing constraint and index names after upgrading to a newer version, **do not** immediately run `prisma migrate` or `prisma db push`. This will **change any underlying constraint name that does not follow Prisma ORM's convention**. Follow the [upgrade path that allows you to maintain existing constraint and index names](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-1-i-want-to-maintain-my-existing-constraint-and-index-names).\n\n### Use cases for named constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#use-cases-for-named-constraints \"Direct link to Use cases for named constraints\")\n\nSome use cases for explicitly named constraints include:\n\n*   Company policy\n*   Conventions of other tools\n\n### Prisma ORM's default naming conventions for indexes and constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints \"Direct link to Prisma ORM's default naming conventions for indexes and constraints\")\n\nPrisma ORM naming convention was chosen to align with PostgreSQL since it is deterministic. It also helps to maximize the amount of times where names do not need to be rendered because many databases out there they already align with the convention.\n\nPrisma ORM always uses the database names of entities when generating the default index and constraint names. If a model is remapped to a different name in the data model via `@@map` or `@map`, the default name generation will still take the name of the _table_ in the database as input. The same is true for fields and _columns_.\n\n| Entity | Convention | Example |\n| --- | --- | --- |\n| Primary Key | {tablename}\\_pkey | `User_pkey` |\n| Unique Constraint | {tablename}\\_{column\\_names}\\_key | `User_firstName_last_Name_key` |\n| Non-Unique Index | {tablename}\\_{column\\_names}\\_idx | `User_age_idx` |\n| Foreign Key | {tablename}\\_{column\\_names}\\_fkey | `User_childName_fkey` |\n\nSince most databases have a length limit for entity names, the names will be trimmed if necessary to not violate the database limits. We will shorten the part before the `_suffix` as necessary so that the full name is at most the maximum length permitted.\n\n### Using default constraint names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#using-default-constraint-names \"Direct link to Using default constraint names\")\n\nWhen no explicit names are provided via `map` arguments Prisma ORM will generate index and constraint names following the [default naming convention](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints).\n\nIf you introspect a database the names for indexes and constraints will be added to your schema unless they follow Prisma ORM's naming convention. If they do, the names are not rendered to keep the schema more readable. When you migrate such a schema Prisma will infer the default names and persist them in the database.\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#example \"Direct link to Example\")\n\nThe following schema defines three constraints (`@id`, `@unique`, and `@relation`) and one index (`@@index`):\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name])  @@index([title, authorName])}\n```\n\nSince no explicit names are provided via `map` arguments Prisma will assume they follow our default naming convention.\n\nThe following table lists the name of each constraint and index in the underlying database:\n\n| Constraint or index | Follows convention | Underlying constraint or index names |\n| --- | --- | --- |\n| `@id` (on `User` > `id` field) | Yes | `User_pk` |\n| `@@index` (on `Post`) | Yes | `Post_title_authorName_idx` |\n| `@id` (on `Post` > `id` field) | Yes | `Post_pk` |\n| `@relation` (on `Post` > `author`) | Yes | `Post_authorName_fkey` |\n\n### Using custom constraint / index names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#using-custom-constraint--index-names \"Direct link to Using custom constraint / index names\")\n\nYou can use the `map` argument to define **custom constraint and index names** in the underlying database.\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#example-1 \"Direct link to Example\")\n\nThe following example adds custom names to one `@id` and the `@@index`:\n\n```\nmodel User {  id    Int    @id(map: \"Custom_Primary_Key_Constraint_Name\") @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name])  @@index([title, authorName], map: \"My_Custom_Index_Name\")}\n```\n\nThe following table lists the name of each constraint and index in the underlying database:\n\n| Constraint or index | Follows convention | Underlying constraint or index names |\n| --- | --- | --- |\n| `@id` (on `User` > `id` field) | No  | `Custom_Primary_Key_Constraint_Name` |\n| `@@index` (on `Post`) | No  | `My_Custom_Index_Name` |\n| `@id` (on `Post` > `id` field) | Yes | `Post_pk` |\n| `@relation` (on `Post` > `author`) | Yes | `Post_authorName_fkey` |\n\n### Related: Naming indexes and primary keys for Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#related-naming-indexes-and-primary-keys-for-prisma-client \"Direct link to Related: Naming indexes and primary keys for Prisma Client\")\n\nAdditionally to `map`, the `@@id` and `@@unique` attributes take an optional `name` argument that allows you to customize your Prisma Client API.\n\nOn a model like:\n\n```\nmodel User {  firstName String  lastName  String  @@id([firstName, lastName])}\n```\n\nthe default API for selecting on that primary key uses a generated combination of the fields:\n\n```\nconst user = await prisma.user.findUnique({  where: {    firstName_lastName: {      firstName: 'Paul',      lastName: 'Panther',    },  },})\n```\n\nSpecifying `@@id([firstName, lastName], name: \"fullName\")` will change the Prisma Client API to this instead:\n\n```\nconst user = await prisma.user.findUnique({  where: {    fullName: {      firstName: 'Paul',      lastName: 'Panther',    },  },})\n```",
    "title": "Database mapping | Prisma Documentation",
    "description": "Database mapping in Prisma schema",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing",
    "markdown": "# Patching & hotfixing | Prisma Documentation\n\nPatching or hotfixing a database involves making an often time critical change directly in production. For example, you might add an index directly to a production database to resolve an issue with a slow-running query.\n\nPatching the production database directly results in **schema drift**: your database schema has 'drifted away' from the source of truth, and is out of sync with your migration history. You can use the `prisma migrate resolve` command to reconcile your migration history _without_ having to remove and re-apply the hotfix with `prisma migrate deploy`.\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate dev`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n## Reconciling your migration history with a patch or hotfix[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#reconciling-your-migration-history-with-a-patch-or-hotfix \"Direct link to Reconciling your migration history with a patch or hotfix\")\n\nThe following scenario assumes that you made a manual change in production and want to propagate that change to your migration history and other databases.\n\nTo reconcile your migration history and database schema in production:\n\n1.  Replicate the change you made in production in the schema - for example, add an `@@index` to a particular model.\n    \n2.  Generate a new migration and take note of the full migration name, including a timestamp, which is written to the CLI:(`20210316150542_retroactively_add_index`):\n    \n    ```\n    npx prisma migrate dev --name retroactively-add-index\n    ```\n    \n3.  Push the migration to production **without running `migrate deploy`**. Instead, mark the migration created in the previous step as 'already applied' so that Prisma Migrate does not attempt to apply your hotfix a second time:\n    \n    ```\n    prisma migrate resolve --applied \"20201127134938-retroactively-add-index\"\n    ```\n    \n    This command adds the migration to the migration history table without running the actual SQL.\n    \n4.  Repeat the previous step for other databases that were patched - for example, if you applied the patch to a staging database.\n    \n5.  Propagate the migration to other databases that were not patched - for example, by committing the migration to source control and allowing your CI/CD pipeline to apply it to all databases.\n    \n\n> **Note**: The migration will not be applied to databases where it has been marked as already applied by the `prisma migrate resolve` command.\n\n## Failed migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#failed-migration \"Direct link to Failed migration\")\n\nA migration might fail if:\n\n*   You [modify a migration before running it](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations) and introduce a syntax error\n*   You add a mandatory (`NOT NULL`) column to a table that already has data\n*   The migration process stopped unexpectedly\n*   The database shut down in the middle of the migration process\n\nEach migration in the `_prisma_migrations` table has a `logs` column that stores the error.\n\nThere are two ways to deal with failed migrations in a production environment:\n\n*   Roll back, optionally fix issues, and re-deploy\n*   Manually complete the migration steps and resolve the migration\n\n### Option 1: Mark the migration as rolled back and re-deploy[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#option-1-mark-the-migration-as-rolled-back-and-re-deploy \"Direct link to Option 1: Mark the migration as rolled back and re-deploy\")\n\nThe following example demonstrates how to roll back a migration, optionally make changes to fix the issue, and re-deploy:\n\n1.  Mark the migration as rolled back - this updates the migration record in the `_prisma_migrations` table to register it as rolled back, allowing it to be applied again:\n    \n    ```\n    prisma migrate resolve --rolled-back \"20201127134938_added_bio_index\"\n    ```\n    \n2.  If the migration was partially run, you can either:\n    \n    *   Modify the migration to check if a step was already completed (for example: `CREATE TABLE ... IF NOT EXISTS`) _OR_\n        \n    *   Manually revert the steps that were completed (for example, delete created tables)\n        \n    \n    > If you modify the migration, make sure you copy it back to source control to ensure that state of your production database is reflected exactly in development.\n    \n3.  Fix the root cause of the failed migration, if relevant - for example, if the migration failed due to an issue with the SQL script itself. Make sure that you copy any changed migrations back to source control.\n    \n4.  Re-deploy the migration:\n    \n\n### Option 2: Manually complete migration and resolve as applied[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#option-2-manually-complete-migration-and-resolve-as-applied \"Direct link to Option 2: Manually complete migration and resolve as applied\")\n\nThe following example demonstrates how to manually complete the steps of a migration and mark that migration as applied.\n\n1.  Manually complete the migration steps on the production database. Make sure that any manual steps exactly match the steps in the migration file, and copy any changes back to source control.\n    \n2.  Resolve the migration as applied - this tells Prisma Migrate to consider the migration successfully applied:\n    \n    ```\n    prisma migrate resolve --applied \"20201127134938_my_migration\"\n    ```\n    \n\n## Fixing failed migrations with `migrate diff` and `db execute`[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute \"Direct link to fixing-failed-migrations-with-migrate-diff-and-db-execute\")\n\nTo help with fixing a failed migration, Prisma ORM provides the following commands for creating and executing a migration file:\n\n*   [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) which diffs two database schema sources to create a migration taking one to the state of the second. You can output either a summary of the difference or a sql script. The script can be output into a file via `> file_name.sql` or be piped to the `db execute --stdin` command.\n*   [`prisma db execute`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute) which applies a SQL script to the database without interacting with the Prisma migrations table.\n\nThese commands are available in Preview in versions `3.9.0` and later (with the `--preview-feature` CLI flag), and generally available in versions `3.13.0` and later.\n\nThis section gives an example scenario of a failed migration, and explains how to use `migrate diff` and `db execute` to fix it.\n\n### Example of a failed migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#example-of-a-failed-migration \"Direct link to Example of a failed migration\")\n\nImagine that you have the following `User` model in your schema, in both your local development environment and your production environment:\n\nschema.prisma\n\n```\nmodel User {  id   Int    @id  name String}\n```\n\nAt this point, your schemas are in sync, but the data in the two environments is different.\n\nYou then decide to make changes to your data model, adding another `Post` model and making the `name` field on `User` unique:\n\nschema.prisma\n\n```\nmodel User {  id    Int     @id  name  String  @unique  email String?}model Post {  id    Int    @id  title String}\n```\n\nYou create a migration called 'Unique' with the command `prisma migrate dev -n Unique` which is saved in your local migrations history. Applying the migration succeeds in your dev environment and now it is time to release to production.\n\nUnfortunately this migration can only be partially executed. Creating the `Post` model and adding the `email` column succeeds, but making the `name` field unique fails with the following error:\n\n```\nERROR 1062 (23000): Duplicate entry 'paul' for key 'User_name_key'\n```\n\nThis is because there is non-unique data in your production database (e.g. two users with the same name).\n\nYou now need to recover manually from the partially executed migration. Until you recover from the failed state, further migrations using `prisma migrate deploy` are impossible.\n\nAt this point there are two options, depending on what you decide to do with the non-unique data:\n\n*   You realize that non-unique data is valid and you cannot move forward with your current development work. You want to roll back the complete migration. To do this, see [Moving backwards and reverting all changes](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-backwards-and-reverting-all-changes)\n*   The existence of non-unique data in your database is unintentional and you want to fix that. After fixing, you want to go ahead with the rest of the migration. To do this, see [Moving forwards and applying missing changes](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-forwards-and-applying-missing-changes)\n\n#### Moving backwards and reverting all changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-backwards-and-reverting-all-changes \"Direct link to Moving backwards and reverting all changes\")\n\nIn this case, you need to create a migration that takes your production database to the state of your data model before the last migration.\n\n*   First you need your migration history at the time before the failed migration. You can either get this from your git history, or locally delete the folder of the last failed migration in your migration history.\n    \n*   You now want to take your production environment from its current failed state back to the state specified in your local migrations history:\n    \n    *   Run the following `prisma migrate diff` command:\n        \n        ```\n         npx prisma migrate diff \\  --from-url \"$DATABASE_URL_PROD\" \\  --to-migrations ./prisma/migrations \\  --shadow-database-url $SHADOW_DATABASE_URL \\  --script > backward.sql\n        ```\n        \n        This will create a SQL script file containing all changes necessary to take your production environment from its current failed state to the target state defined by your migrations history. Note that because we're using `--to-migrations`, the command requires a [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database).\n        \n    *   Run the following `prisma db execute` command:\n        \n        ```\n         npx prisma db execute --url \"$DATABASE_URL_PROD\" --file backward.sql\n        ```\n        \n        This applies the changes in the SQL script against the target database without interacting with the migrations table.\n        \n    *   Run the following `prisma migrate resolve` command:\n        \n        ```\n         npx prisma migrate resolve --rolled-back Unique\n        ```\n        \n        This will mark the failed migration called 'Unique' in the migrations table on your production environment as rolled back.\n        \n\nYour local migration history now yields the same result as the state your production database is in. You can now modify the datamodel again to create a migration that suits your new understanding of the feature you're working on (with non-unique names).\n\n#### Moving forwards and applying missing changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-forwards-and-applying-missing-changes \"Direct link to Moving forwards and applying missing changes\")\n\nIn this case, you need to fix the non-unique data and then go ahead with the rest of the migration as planned:\n\n*   The error message from trying to deploy the migration to production already told you there was duplicate data in the column `name`. You need to either alter or delete the offending rows.\n    \n*   Continue applying the rest of the failed migration to get to the data model defined in your `schema.prisma` file:\n    \n    *   Run the following `prisma migrate diff` command:\n        \n        ```\n        npx prisma migrate diff --from-url \"$DATABASE_URL_PROD\" --to-schema-datamodel schema.prisma --script > forward.sql\n        ```\n        \n        This will create a SQL script file containing all changes necessary to take your production environment from its current failed state to the target state defined in your `schema.prisma` file.\n        \n    *   Run the following `prisma db execute` command:\n        \n        ```\n        npx prisma db execute --url \"$DATABASE_URL_PROD\" --file forward.sql\n        ```\n        \n        This applies the changes in the SQL script against the target database without interacting with the migrations table.\n        \n    *   Run the following `prisma migrate resolve` command:\n        \n        ```\n        npx prisma migrate resolve --applied Unique\n        ```\n        \n        This will mark the failed migration called 'Unique' in the migrations table on your production environment as applied.\n        \n\nYour local migration history now yields the same result as the state your production environment is in. You can now continue using the already known `migrate dev` /`migrate deploy` workflow.\n\n## Migration history conflicts[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#migration-history-conflicts \"Direct link to Migration history conflicts\")\n\ninfo\n\nThis does not apply from version [3.12.0](https://github.com/prisma/prisma/releases/tag/3.12.0) upwards.\n\n`prisma migrate deploy` issues a warning if an already applied migration has been edited - however, it does not stop the migration process. To remove the warnings, restore the original migration from source control.\n\n## Prisma Migrate and PgBouncer[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#prisma-migrate-and-pgbouncer \"Direct link to Prisma Migrate and PgBouncer\")\n\nYou might see the following error if you attempt to run Prisma Migrate commands in an environment that uses PgBouncer for connection pooling:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nSee [Prisma Migrate and PgBouncer workaround](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer) for further information and a workaround. Follow [GitHub issue #6485](https://github.com/prisma/prisma/issues/6485) for updates.",
    "title": "Patching & hotfixing | Prisma Documentation",
    "description": "How to reconcile the migration history after applying a hotfix or patch to a production environment.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema",
    "markdown": "# How to use Prisma ORM with multiple database schemas\n\nwarning\n\nMultiple database schema support is currently available with the PostgreSQL, CockroachDB, and SQL Server connectors.\n\nMany database providers allow you to organize database tables into named groups. You can use this to make the logical structure of the data model easier to understand, or to avoid naming collisions between tables.\n\nIn PostgreSQL, CockroachDB, and SQL Server, these groups are known as schemas. We will refer to them as _database schemas_ to distinguish them from Prisma ORM's own schema.\n\nThis guide explains how to:\n\n*   include multiple database schemas in your Prisma schema\n*   apply your schema changes to your database with Prisma Migrate and `db push`\n*   introspect an existing database with multiple database schemas\n*   query across multiple database schemas with Prisma Client\n\n## How to enable the `multiSchema` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-enable-the-multischema-preview-feature \"Direct link to how-to-enable-the-multischema-preview-feature\")\n\nMulti-schema support is currently in preview. To enable the `multiSchema` preview feature, add the `multiSchema` feature flag to the `previewFeatures` field of the `generator` block in your Prisma Schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"multiSchema\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\n## How to include multiple database schemas in your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-include-multiple-database-schemas-in-your-prisma-schema \"Direct link to How to include multiple database schemas in your Prisma schema\")\n\nTo use multiple database schemas in your Prisma schema file, add the names of your database schemas to an array in the `schemas` field, in the `datasource` block. The following example adds a `\"base\"` and a `\"transactional\"` schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"multiSchema\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")  schemas  = [\"base\", \"transactional\"]}\n```\n\nYou do not need to change your connection string. The `schema` value of your connection string is the default database schema that Prisma Client connects to and uses for raw queries. All other Prisma Client queries use the schema of the model or enum that you are querying.\n\nTo designate that a model or enum belongs to a specific database schema, add the `@@schema` attribute with the name of the database schema as a parameter. In the following example, the `User` model is part of the `\"base\"` schema, and the `Order` model and `Size` enum are part of the `\"transactional\"` schema:\n\nschema.prisma\n\n```\nmodel User {  id     Int     @id  orders Order[]  @@schema(\"base\")}model Order {  id      Int  @id  user    User @relation(fields: [id], references: [id])  user_id Int  @@schema(\"transactional\")}enum Size {  Small  Medium  Large  @@schema(\"transactional\")}\n```\n\n### Tables with the same name in different database schemas[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#tables-with-the-same-name-in-different-database-schemas \"Direct link to Tables with the same name in different database schemas\")\n\nIf you have tables with the same name in different database schemas, you will need to map the table names to unique model names in your Prisma schema. This avoids name conflicts when you query models in Prisma Client.\n\nFor example, consider a situation where the `config` table in the `base` database schema has the same name as the `config` table in the `users` database schema. To avoid name conflicts, give the models in your Prisma schema unique names (`BaseConfig` and `UserConfig`) and use the `@@map` attribute to map each model to the corresponding table name:\n\nschema.prisma\n\n```\nmodel BaseConfig {  id Int @id  @@map(\"config\")  @@schema(\"base\")}model UserConfig {  id Int @id  @@map(\"config\")  @@schema(\"users\")}\n```\n\n## How to apply your schema changes with Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-apply-your-schema-changes-with-prisma-migrate-and-db-push \"Direct link to how-to-apply-your-schema-changes-with-prisma-migrate-and-db-push\")\n\nYou can use Prisma Migrate or `db push` to apply changes to a Prisma schema with multiple database schemas.\n\nAs an example, add a `Profile` model to the `base` schema of the blog post model above:\n\nschema.prisma\n\n```\nmodel User {  id      Int      @id  orders  Order[]  profile Profile?  @@schema(\"base\")}model Profile {  id     Int    @id @default(autoincrement())  bio    String  user   User   @relation(fields: [userId], references: [id])  userId Int    @unique  @@schema(\"base\")}model Order {  id      Int  @id  user    User @relation(fields: [id], references: [id])  user_id Int  @@schema(\"transactional\")}enum Size {  Small  Medium  Large  @@schema(\"transactional\")}\n```\n\nYou can then apply this schema change to your database. For example, you can use `migrate dev` to create and apply your schema changes as a migration:\n\n```\nnpx prisma migrate dev --name add_profile\n```\n\nNote that if you move a model or enum from one schema to another, Prisma ORM deletes the model or enum from the source schema and creates a new one in the target schema.\n\n## How to introspect an existing database with multiple database schemas[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-introspect-an-existing-database-with-multiple-database-schemas \"Direct link to How to introspect an existing database with multiple database schemas\")\n\nYou can introspect an existing database that has multiple database schemas in the same way that you introspect a database that has a single database schema, using `db pull`:\n\nThis updates your Prisma schema to match the current state of the database.\n\nIf you have tables with the same name in different database schemas, Prisma ORM shows a validation error pointing out the conflict. To fix this, [rename the introspected models with the `@map` attribute](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#tables-with-the-same-name-in-different-database-schemas).\n\n## How to query across multiple database schemas with Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-query-across-multiple-database-schemas-with-prisma-client \"Direct link to How to query across multiple database schemas with Prisma Client\")\n\nYou can query models in multiple database schemas without any change to your Prisma Client query syntax. For example, the following query finds all orders for a given user, using the Prisma schema above:\n\n```\nconst orders = await prisma.order.findMany({  where: {    user: {      id: 1,    },  },})\n```\n\n## Learn more about the `multiSchema` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#learn-more-about-the-multischema-preview-feature \"Direct link to learn-more-about-the-multischema-preview-feature\")\n\nTo learn more about future plans for the `multiSchema` preview feature, or to give feedback, refer to [our Github issue](https://github.com/prisma/prisma/issues/1122).",
    "title": "How to use Prisma ORM with multiple database schemas | Prisma Documentation",
    "description": "How to use Prisma ORM with multiple database schemas",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging",
    "markdown": "# Logging | Prisma Documentation\n\n```\nconst prisma = new PrismaClient({  log: [    {      emit: 'event',      level: 'query',    },    {      emit: 'stdout',      level: 'error',    },    {      emit: 'stdout',      level: 'info',    },    {      emit: 'stdout',      level: 'warn',    },  ],})prisma.$on('query', (e) => {  console.log('Query: ' + e.query)  console.log('Params: ' + e.params)  console.log('Duration: ' + e.duration + 'ms')})\n```",
    "title": "Logging | Prisma Documentation",
    "description": "Learn how to configure Prisma Client to log the raw SQL queries it sends to the database and other information.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator",
    "markdown": "# Prisma validator | Prisma Documentation\n\nThe [`Prisma.validator`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismavalidator) is a utility function that takes a generated type and returns a type-safe object which adheres to the generated types model fields.\n\nThis page introduces the `Prisma.validator` and offers some motivations behind why you might choose to use it.\n\n> **Note**: If you have a use case for `Prisma.validator`, be sure to check out this [blog post](https://www.prisma.io/blog/satisfies-operator-ur8ys8ccq7zb) about improving your Prisma Client workflows with the new TypeScript `satisfies` keyword. It's likely that you can solve your use case natively using `satisfies` instead of using `Prisma.validator`.\n\n## Creating a typed query statement[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#creating-a-typed-query-statement \"Direct link to Creating a typed query statement\")\n\nLet's imagine that you created a new `userEmail` object that you wanted to re-use in different queries throughout your application. It's typed and can be safely used in queries.\n\nThe below example asks `Prisma` to return the `email` of the user whose `id` is 3, if no user exists it will return `null`.\n\n```\nimport { Prisma } from '@prisma/client'const userEmail: Prisma.UserSelect = {  email: true,}// Run inside async functionconst user = await prisma.user.findUnique({  where: {    id: 3,  },  select: userEmail,})\n```\n\nThis works well but there is a caveat to extracting query statements this way.\n\nYou'll notice that if you hover your mouse over `userEmail` TypeScript won't infer the object's key or value (that is, `email: true`).\n\nThe same applies if you use dot notation on `userEmail` within the `prisma.user.findUnique(...)` query, you will be able to access all of the properties available to a `select` object.\n\nIf you are using this in one file that may be fine, but if you are going to export this object and use it in other queries, or if you are compiling an external library where you want to control how the user uses this object within their queries then this won't be type-safe.\n\nThe object `userEmail` has been created to select only the user's `email`, and yet it still gives access to all the other properties available. **It is typed, but not type-safe**.\n\n`Prisma` has a way to validate generated types to make sure they are type-safe, a utility function available on the namespace called `validator`.\n\n## Using the `Prisma.validator`[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#using-the-prismavalidator \"Direct link to using-the-prismavalidator\")\n\nThe following example passes the `UserSelect` generated type into the `Prisma.validator` utility function and defines the expected return type in much the same way as the previous example.\n\n```\nimport { Prisma } from '@prisma/client'const userEmail: Prisma.UserSelect = {  email: true,}const userEmail = Prisma.validator<Prisma.UserSelect>()({  email: true,})// Run inside async functionconst user = await prisma.user.findUnique({  where: {    id: 3,  },  select: userEmail,})\n```\n\nAlternatively, you can use the following syntax that uses a \"selector\" pattern using an existing instance of Prisma Client:\n\n```\nimport { Prisma } from '@prisma/client'import prisma from './lib/prisma'const userEmail = Prisma.validator(  prisma,  'user',  'findUnique',  'select')({  email: true,})\n```\n\nThe big difference is that the `userEmail` object is now type-safe. If you hover your mouse over it TypeScript will tell you the object's key/value pair. If you use dot notation to access the object's properties you will only be able to access the `email` property of the object.\n\nThis functionality is handy when combined with user defined input, like form data.\n\n## Combining `Prisma.validator` with form input[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#combining-prismavalidator-with-form-input \"Direct link to combining-prismavalidator-with-form-input\")\n\nThe following example creates a type-safe function from the `Prisma.validator` which can be used when interacting with user created data, such as form inputs.\n\n> **Note**: Form input is determined at runtime so can't be verified by only using TypeScript. Be sure to validate your form input through other means too (such as an external validation library) before passing that data through to your database.\n\n```\nimport { Prisma, PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// Create a new function and pass the parameters onto the validatorconst createUserAndPost = (  name: string,  email: string,  postTitle: string,  profileBio: string) => {  return Prisma.validator<Prisma.UserCreateInput>()({    name,    email,    posts: {      create: {        title: postTitle,      },    },    profile: {      create: {        bio: profileBio,      },    },  })}const findSpecificUser = (email: string) => {  return Prisma.validator<Prisma.UserWhereInput>()({    email,  })}// Create the user in the database based on form input// Run inside async functionawait prisma.user.create({  data: createUserAndPost(    'Rich',    'rich@boop.com',    'Life of Pie',    'Learning each day'  ),})// Find the specific user based on form input// Run inside async functionconst oneUser = await prisma.user.findUnique({  where: findSpecificUser('rich@boop.com'),})\n```\n\nThe `createUserAndPost` custom function is created using the `Prisma.validator` and passed a generated type, `UserCreateInput`. The `Prisma.validator` validates the functions input because the types assigned to the parameters must match those the generated type expects.",
    "title": "Prisma validator | Prisma Documentation",
    "description": "The Prisma validator is a utility function that takes a generated type and returns a type-safe object which adheres to the generated types model fields.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries",
    "markdown": "# Compare columns of the same table with raw queries\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#problem \"Direct link to Problem\")\n\nComparing different columns from the same table is a common scenario that developers encounter. Some examples include comparing two numeric values in the same table or comparing two dates in a same table. There's an existing [GitHub Issue](https://github.com/prisma/prisma/issues/5048) regarding the same.\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\n## Workaround[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#workaround \"Direct link to Workaround\")\n\nComparing values from two columns in the same table can be achieved by using [raw queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries).\n\n### Comparing numeric values[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#comparing-numeric-values \"Direct link to Comparing numeric values\")\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\nOne use case for comparing values from different columns would be retrieving posts that have more comments than likes; in this case, you need to compare the values of `commentsCount` and `likesCount`.\n\n```\nmodel Post {  id            Int      @id @default(autoincrement())  createdAt     DateTime @default(now())  updatedAt     DateTime @updatedAt  title         String  content       String?  published     Boolean  @default(false)  author        User     @relation(fields: [authorId], references: [id])  authorId      Int  likesCount    Int  commentsCount Int}\n```\n\nQueries (depending upon which database) could look something like:\n\n_PostgreSQL / CockroachDB_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"public\".\"Post\" WHERE \"likesCount\" < \"commentsCount\";`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\n_MySQL_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \\`public\\`.\\`Post\\` WHERE \\`likesCount\\` < \\`commentsCount\\`;`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\n_Sqlite_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"Post\" WHERE \"likesCount\" < \"commentsCount\";`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\nRunning the above queries (depending upon the database) would filter posts that has fewer likes compared to comments.\n\n_Query Response_\n\n```\n;[  {    id: 1,    createdAt: '2022-03-03T12:08:11.421+00:00',    updatedAt: '2022-03-03T12:08:11.422+00:00',    title: 'Hello World',    content: 'This is my first post',    published: false,    authorId: 1,    likesCount: 50,    commentsCount: 100,  },]\n```\n\n### Comparing date values[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#comparing-date-values \"Direct link to Comparing date values\")\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\nSimilarly, if you need to compare dates, you could also achieve the same thing using raw queries.\n\nFor example, a use case could be to get all projects completed after the due date.\n\n```\nmodel Project {  id            Int      @id @default(autoincrement())  title         String  author        User     @relation(fields: [authorId], references: [id])  authorId      Int  dueDate       DateTime  completedDate DateTime  createdAt     DateTime @default(now())}\n```\n\nQueries (depending upon the database) could look something like:\n\n_PostgreSQL / CockroachDB_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"public\".\"Project\" WHERE \"completedDate\" > \"dueDate\";`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\n_MySQL_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \\`public\\`.\\`Project\\` WHERE \\`completedDate\\` > \\`dueDate\\`;`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\n_Sqlite_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"Project\" WHERE \"completedDate\" > \"dueDate\";`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\nRunning the above query would fetch projects where `completedDate` is after the `dueDate`.\n\n_Query Response_\n\n```\n;[  {    id: 1,    title: 'Project 1',    authorId: 1,    dueDate: '2022-03-10T00:00:00+00:00',    completedDate: '2022-03-12T00:00:00+00:00',    createdAt: '2022-03-03T12:08:11.421+00:00',  },]\n```",
    "title": "Compare columns of the same table with raw queries | Prisma Documentation",
    "description": "Compare columns with inbuilt raw query methods in Prisma",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types",
    "markdown": "# Composite types | Prisma Documentation\n\nwarning\n\nComposite types are only available with MongoDB.\n\n[Composite types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types), known as [embedded documents](https://docs.mongodb.com/manual/core/data-model-design/#std-label-data-modeling-embedding) in MongoDB, allow you to embed records within other records.\n\nWe made composite types [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) in v3.12.0. They were previously available in [Preview](https://www.prisma.io/docs/orm/reference/preview-features) from v3.10.0.\n\nThis page explains how to:\n\n*   [find](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) records that contain composite types using `findFirst` and `findMany`\n*   [create](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#creating-records-with-composite-types-using-create-and-createmany) new records with composite types using `create` and `createMany`\n*   [update](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-composite-types-within-update-and-updatemany) composite types within existing records using `update` and `updateMany`\n*   [delete](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#deleting-records-that-contain-composite-types-with-delete-and-deletemany) records with composite types using `delete` and `deleteMany`\n\n## Example schema[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#example-schema \"Direct link to Example schema\")\n\nWe’ll use this schema for the examples that follow:\n\nschema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}model Product {  id     String  @id @default(auto()) @map(\"_id\") @db.ObjectId  name   String  @unique  price  Float  colors Color[]  sizes  Size[]  photos Photo[]  orders Order[]}model Order {  id              String   @id @default(auto()) @map(\"_id\") @db.ObjectId  product         Product  @relation(fields: [productId], references: [id])  color           Color  size            Size  shippingAddress Address  billingAddress  Address?  productId       String   @db.ObjectId}enum Color {  Red  Green  Blue}enum Size {  Small  Medium  Large  XLarge}type Photo {  height Int    @default(200)  width  Int    @default(100)  url    String}type Address {  street String  city   String  zip    String}\n```\n\nIn this schema, the `Product` model has a `Photo[]` composite type, and the `Order` model has two composite `Address` types. The `shippingAddress` is required, but the `billingAddress` is optional.\n\n## Considerations when using composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#considerations-when-using-composite-types \"Direct link to Considerations when using composite types\")\n\nThere are currently some limitations when using composite types in Prisma Client:\n\n*   [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique) can't filter on composite types\n*   [`aggregate`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate), [`groupBy()`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#group-by), [`count`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count) don’t support composite operations\n\n## Default values for required fields on composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#default-values-for-required-fields-on-composite-types \"Direct link to Default values for required fields on composite types\")\n\nFrom version 4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.\n\nConditions:\n\n*   A field on the composite type is [required](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#optional-and-mandatory-fields), and\n*   this field has a [default value](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value), and\n*   this field is not present in the returned document or documents.\n\nNote:\n\n*   This is the same behavior as with [model fields](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types).\n*   On read operations, Prisma Client inserts the default value into the result, but does not insert the default value into the database.\n\nIn our example schema, suppose that you add a required field to `photo`. This field, `bitDepth`, has a default value:\n\nschema.prisma\n\n```\n...type Photo {  ...  bitDepth Int @default(8)}...\n```\n\nSuppose that you then run `npx prisma migrate deploy` to [deploy your database changes](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate) and regenerate your Prisma Client with `npx prisma generate`. Then, you run the following application code:\n\n```\nconsole.dir(await prisma.product.findMany({}), { depth: Infinity })\n```\n\nThe `bitDepth` field has no content because you have only just added this field, so the query returns the default value of `8`.\n\n\\*\\* Earlier versions \\*\\*\n\nBefore version 4.0.0, Prisma ORM threw a P2032 error as follows:\n\n```\nError converting field \"bitDepth\" of expected non-nullabletype \"int\", found incompatible value of \"null\".\n```\n\n## Finding records that contain composite types with `find` and `findMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany \"Direct link to finding-records-that-contain-composite-types-with-find-and-findmany\")\n\nRecords can be filtered by a composite type within the `where` operation.\n\nThe following section describes the operations available for filtering by a single type or multiple types, and gives examples of each.\n\n### Filtering for one composite type[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#filtering-for-one-composite-type \"Direct link to Filtering for one composite type\")\n\nUse the `is`, `equals`, `isNot` and `isSet` operations to change a single composite type:\n\n*   `is`: Filter results by matching composite types. Requires one or more fields to be present _(e.g. Filter orders by the street name on the shipping address)_\n*   `equals`: Filter results by matching composite types. Requires all fields to be present. _(e.g. Filter orders by the full shipping address)_\n*   `isNot`: Filter results by non-matching composite types\n*   `isSet` : Filter optional fields to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude `undefined` results that are not set at all.\n\nFor example, use `is` to filter for orders with a street name of `'555 Candy Cane Lane'`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      is: {        street: '555 Candy Cane Lane',      },    },  },})\n```\n\nUse `equals` to filter for orders which match on all fields in the shipping address:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      equals: {        street: '555 Candy Cane Lane',        city: 'Wonderland',        zip: '52337',      },    },  },})\n```\n\nYou can also use a shorthand notation for this query, where you leave out the `equals`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      street: '555 Candy Cane Lane',      city: 'Wonderland',      zip: '52337',    },  },})\n```\n\nUse `isNot` to filter for orders that do not have a `zip` code of `'52337'`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      isNot: {        zip: '52337',      },    },  },})\n```\n\nUse `isSet` to filter for orders where the optional `billingAddress` has been set (either to a value or to `null`):\n\n```\nconst orders = await prisma.order.findMany({  where: {    billingAddress: {      isSet: true,    },  },})\n```\n\n### Filtering for many composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#filtering-for-many-composite-types \"Direct link to Filtering for many composite types\")\n\nUse the `equals`, `isEmpty`, `every`, `some` and `none` operations to filter for multiple composite types:\n\n*   `equals`: Checks exact equality of the list\n*   `isEmpty`: Checks if the list is empty\n*   `every`: Every item in the list must match the condition\n*   `some`: One or more of the items in the list must match the condition\n*   `none`: None of the items in the list can match the condition\n*   `isSet` : Filter optional fields to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude `undefined` results that are not set at all.\n\nFor example, you can use `equals` to find products with a specific list of photos (all `url`, `height` and `width` fields must match):\n\n```\nconst product = prisma.product.findMany({  where: {    photos: {      equals: [        {          url: '1.jpg',          height: 200,          width: 100,        },        {          url: '2.jpg',          height: 200,          width: 100,        },      ],    },  },})\n```\n\nYou can also use a shorthand notation for this query, where you leave out the `equals` and specify just the fields that you want to filter for:\n\n```\nconst product = prisma.product.findMany({  where: {    photos: [      {        url: '1.jpg',        height: 200,        width: 100,      },      {        url: '2.jpg',        height: 200,        width: 100,      },    ],  },})\n```\n\nUse `isEmpty` to filter for products with no photos:\n\n```\nconst product = prisma.product.findMany({  where: {    photos: {      isEmpty: true,    },  },})\n```\n\nUse `some` to filter for products where one or more photos has a `url` of `\"2.jpg\"`:\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      some: {        url: '2.jpg',      },    },  },})\n```\n\nUse `none` to filter for products where no photos have a `url` of `\"2.jpg\"`:\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      none: {        url: '2.jpg',      },    },  },})\n```\n\n## Creating records with composite types using `create` and `createMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#creating-records-with-composite-types-using-create-and-createmany \"Direct link to creating-records-with-composite-types-using-create-and-createmany\")\n\ninfo\n\nWhen you create a record with a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nComposite types can be created within a `create` or `createMany` method using the `set` operation. For example, you can use `set` within `create` to create an `Address` composite type inside an `Order`:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      set: {        street: '1084 Candycane Lane',        city: 'Silverlake',        zip: '84323',      },    },  },})\n```\n\nYou can also use a shorthand notation where you leave out the `set` and specify just the fields that you want to create:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      street: '1084 Candycane Lane',      city: 'Silverlake',      zip: '84323',    },  },})\n```\n\nFor an optional type, like the `billingAddress`, you can also set the value to `null`:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      street: '1084 Candycane Lane',      city: 'Silverlake',      zip: '84323',    },    // Embedded optional type, set to null    billingAddress: {      set: null,    },  },})\n```\n\nTo model the case where an `product` contains a list of multiple `photos`, you can `set` multiple composite types at once:\n\n```\nconst product = await prisma.product.create({  data: {    name: 'Forest Runners',    price: 59.99,    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    // New composite type    photos: {      set: [        { height: 100, width: 200, url: '1.jpg' },        { height: 100, width: 200, url: '2.jpg' },      ],    },  },})\n```\n\nYou can also use a shorthand notation where you leave out the `set` and specify just the fields that you want to create:\n\n```\nconst product = await prisma.product.create({  data: {    name: 'Forest Runners',    price: 59.99,    // Scalar lists that we already support    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    // New composite type    photos: [      { height: 100, width: 200, url: '1.jpg' },      { height: 100, width: 200, url: '2.jpg' },    ],  },})\n```\n\nThese operations also work within the `createMany` method. For example, you can create multiple `product`s which each contain a list of `photos`:\n\n```\nconst product = await prisma.product.createMany({  data: [    {      name: 'Forest Runners',      price: 59.99,      colors: ['Red', 'Green'],      sizes: ['Small', 'Medium', 'Large'],      photos: [        { height: 100, width: 200, url: '1.jpg' },        { height: 100, width: 200, url: '2.jpg' },      ],    },    {      name: 'Alpine Blazers',      price: 85.99,      colors: ['Blue', 'Red'],      sizes: ['Large', 'XLarge'],      photos: [        { height: 100, width: 200, url: '1.jpg' },        { height: 150, width: 200, url: '4.jpg' },        { height: 200, width: 200, url: '5.jpg' },      ],    },  ],})\n```\n\n## Changing composite types within `update` and `updateMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-composite-types-within-update-and-updatemany \"Direct link to changing-composite-types-within-update-and-updatemany\")\n\ninfo\n\nWhen you update a record with a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nComposite types can be set, updated or removed within an `update` or `updateMany` method. The following section describes the operations available for updating a single type or multiple types at once, and gives examples of each.\n\n### Changing a single composite type[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-a-single-composite-type \"Direct link to Changing a single composite type\")\n\nUse the `set`, `unset` `update` and `upsert` operations to change a single composite type:\n\n*   Use `set` to set a composite type, overriding any existing value\n*   Use `unset` to unset a composite type. Unlike `set: null`, `unset` removes the field entirely\n*   Use `update` to update a composite type\n*   Use `upsert` to `update` an existing composite type if it exists, and otherwise `set` the composite type\n\nFor example, use `update` to update a required `shippingAddress` with an `Address` composite type inside an `Order`:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    shippingAddress: {      // Update just the zip field      update: {        zip: '41232',      },    },  },})\n```\n\nFor an optional embedded type, like the `billingAddress`, use `upsert` to create a new record if it does not exist, and update the record if it does:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Create the address if it doesn't exist,      // otherwise update it      upsert: {        set: {          street: '1084 Candycane Lane',          city: 'Silverlake',          zip: '84323',        },        update: {          zip: '84323',        },      },    },  },})\n```\n\nYou can also use the `unset` operation to remove an optional embedded type. The following example uses `unset` to remove the `billingAddress` from an `Order`:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Unset the billing address      // Removes \"billingAddress\" field from order      unset: true,    },  },})\n```\n\nYou can use [filters](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) within `updateMany` to update all records that match a composite type. The following example uses the `is` filter to match the street name from a shipping address on a list of orders:\n\n```\nconst orders = await prisma.order.updateMany({  where: {    shippingAddress: {      is: {        street: '555 Candy Cane Lane',      },    },  },  data: {    shippingAddress: {      update: {        street: '111 Candy Cane Drive',      },    },  },})\n```\n\n### Changing multiple composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-multiple-composite-types \"Direct link to Changing multiple composite types\")\n\nUse the `set`, `push`, `updateMany` and `deleteMany` operations to change a list of composite types:\n\n*   `set`: Set an embedded list of composite types, overriding any existing list\n*   `push`: Push values to the end of an embedded list of composite types\n*   `updateMany`: Update many composite types at once\n*   `deleteMany`: Delete many composite types at once\n\nFor example, use `push` to add a new photo to the `photos` list:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      // Push a photo to the end of the photos list      push: [{ height: 100, width: 200, url: '1.jpg' }],    },  },})\n```\n\nUse `updateMany` to update photos with a `url` of `1.jpg` or `2.png`:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      updateMany: {        where: {          url: '1.jpg',        },        data: {          url: '2.png',        },      },    },  },})\n```\n\nThe following example uses `deleteMany` to delete all photos with a `height` of 100:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      deleteMany: {        where: {          height: 100,        },      },    },  },})\n```\n\n## Upserting composite types with `upsert`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#upserting-composite-types-with-upsert \"Direct link to upserting-composite-types-with-upsert\")\n\ninfo\n\nWhen you create or update the values in a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nTo create or update a composite type, use the `upsert` method. You can use the same composite operations as the `create` and `update` methods above.\n\nFor example, use `upsert` to either create a new product or add a photo to an existing product:\n\n```\nconst product = await prisma.product.upsert({  where: {    name: 'Forest Runners',  },  create: {    name: 'Forest Runners',    price: 59.99,    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    photos: [      { height: 100, width: 200, url: '1.jpg' },      { height: 100, width: 200, url: '2.jpg' },    ],  },  update: {    photos: {      push: { height: 300, width: 400, url: '3.jpg' },    },  },})\n```\n\n## Deleting records that contain composite types with `delete` and `deleteMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#deleting-records-that-contain-composite-types-with-delete-and-deletemany \"Direct link to deleting-records-that-contain-composite-types-with-delete-and-deletemany\")\n\nTo remove records which embed a composite type, use the `delete` or `deleteMany` methods. This will also remove the embedded composite type.\n\nFor example, use `deleteMany` to delete all products with a `size` of `\"Small\"`. This will also delete any embedded `photos`.\n\n```\nconst deleteProduct = await prisma.product.deleteMany({  where: {    sizes: {      equals: 'Small',    },  },})\n```\n\nYou can also use [filters](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) to delete records that match a composite type. The example below uses the `some` filter to delete products that contain a certain photo:\n\n```\nconst product = await prisma.product.deleteMany({  where: {    photos: {      some: {        url: '2.jpg',      },    },  },})\n```\n\n## Ordering composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#ordering-composite-types \"Direct link to Ordering composite types\")\n\nYou can use the `orderBy` operation to sort results in ascending or descending order.\n\nFor example, the following command finds all orders and orders them by the city name in the shipping address, in ascending order:\n\n```\nconst orders = await prisma.order.findMany({  orderBy: {    shippingAddress: {      city: 'asc',    },  },})\n```\n\n## Duplicate values in unique fields of composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types \"Direct link to Duplicate values in unique fields of composite types\")\n\nBe careful when you carry out any of the following operations on a record with a composite type that has a unique constraint. In this situation, MongoDB does not enforce unique values inside a record.\n\n*   When you create the record\n*   When you add data to the record\n*   When you update data in the record\n\nIf your schema has a composite type with a `@@unique` constraint, MongoDB prevents you from storing the same value for the constrained value in two or more of the records that contain this composite type. However, MongoDB does does not prevent you from storing multiple copies of the same field value in a single record.\n\nNote that you can [use Prisma ORM relations to work around this issue](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#use-prisma-orm-relations-to-enforce-unique-values-in-a-record).\n\nFor example, in the following schema, `MailBox` has a composite type, `addresses`, which has a `@@unique` constraint on the `email` field.\n\n```\ntype Address {  email String}model MailBox {  name      String  addresses Address[]  @@unique([addresses.email])}\n```\n\nThe following code creates a record with two identical values in `address`. MongoDB does not throw an error in this situation, and it stores `alice@prisma.io` in `addresses` twice.\n\n```\nawait prisma.MailBox.createMany({  data: [    {      name: 'Alice',      addresses: {        set: [          {            address: 'alice@prisma.io', // Not unique          },          {            address: 'alice@prisma.io', // Not unique          },        ],      },    },  ],})\n```\n\nNote: MongoDB throws an error if you try to store the same value in two separate records. In our example above, if you try to store the email address `alice@prisma.io` for the user Alice and for the user Bob, MongoDB does not store the data and throws an error.\n\n### Use Prisma ORM relations to enforce unique values in a record[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#use-prisma-orm-relations-to-enforce-unique-values-in-a-record \"Direct link to Use Prisma ORM relations to enforce unique values in a record\")\n\nIn the example above, MongoDB did not enforce the unique constraint on a nested address name. However, you can model your data differently to enforce unique values in a record. To do so, use Prisma ORM [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) to turn the composite type into a collection. Set a relationship to this collection and place a unique constraint on the field that you want to be unique.\n\nIn the following example, MongoDB enforces unique values in a record. There is a relation between `Mailbox` and the `Address` model. Also, the `name` field in the `Address` model has a unique constraint.\n\n```\nmodel Address {  id        String   @id @default(auto()) @map(\"_id\") @db.ObjectId  name      String  mailbox   Mailbox? @relation(fields: [mailboxId], references: [id])  mailboxId String?  @db.ObjectId  @@unique([name])}model Mailbox {  id        String    @id @default(auto()) @map(\"_id\") @db.ObjectId  name      String  addresses Address[] @relation}\n```\n\n```\nawait prisma.MailBox.create({  data: {    name: 'Alice',    addresses: {      create: [        { name: 'alice@prisma.io' }, // Not unique        { name: 'alice@prisma.io' }, // Not unique      ],    },  },})\n```\n\nIf you run the above code, MongoDB enforces the unique constraint. It does not allow your application to add two addresses with the name `alice@prisma.io`.",
    "title": "Composite types | Prisma Documentation",
    "description": "Composite types",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management",
    "markdown": "# Connection management | Prisma Documentation\n\n`PrismaClient` connects and disconnects from your data source using the following two methods:\n\n*   [`$connect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect-1)\n*   [`$disconnect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect-1)\n\nIn most cases, you **do not need to explicitly call these methods**. `PrismaClient` automatically connects when you run your first query, creates a [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool), and disconnects when the Node.js process ends.\n\nSee the [connection management guide](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections) for information about managing connections for different deployment paradigms (long-running processes and serverless functions).\n\n## `$connect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#connect \"Direct link to connect\")\n\nIt is not necessary to call [`$connect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect-1) thanks to the _lazy connect_ behavior: The `PrismaClient` instance connects lazily when the first request is made to the API (`$connect()` is called for you under the hood).\n\n### Calling `$connect()` explicitly[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-connect-explicitly \"Direct link to calling-connect-explicitly\")\n\nIf you need the first request to respond instantly and cannot wait for a lazy connection to be established, you can explicitly call `prisma.$connect()` to establish a connection to the data source:\n\n```\nconst prisma = new PrismaClient()// run inside `async` functionawait prisma.$connect()\n```\n\n## `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#disconnect \"Direct link to disconnect\")\n\nWhen you call [`$disconnect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect-1) , Prisma Client:\n\n1.  Runs the [`beforeExit` hook](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#exit-hooks)\n2.  Ends the Query Engine child process and closes all connections\n\nIn a long-running application such as a GraphQL API, which constantly serves requests, it does not make sense to `$disconnect()` after each request - it takes time to establish a connection, and doing so as part of each request will slow down your application.\n\n### Calling `$disconnect()` explicitly[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly \"Direct link to calling-disconnect-explicitly\")\n\nOne scenario where you should call `$disconnect()` explicitly is where a script:\n\n1.  Runs **infrequently** (for example, a scheduled job to send emails each night), which means it does not benefit from a long-running connection to the database _and_\n2.  Exists in the context of a **long-running application**, such as a background service. If the application never shuts down, Prisma Client never disconnects.\n\nThe following script creates a new instance of `PrismaClient`, performs a task, and then disconnects - which closes the connection pool:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()const emailService = new EmailService()async function main() {  const allUsers = await prisma.user.findMany()  const emails = allUsers.map((x) => x.email)  await emailService.send(emails, 'Hello!')}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nIf the above script runs multiple times in the context of a long-running application _without_ calling `$disconnect()`, a new connection pool is created with each new instance of `PrismaClient`.\n\n## Exit hooks[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#exit-hooks \"Direct link to Exit hooks\")\n\nThe `beforeExit` hook runs when Prisma ORM is triggered externally (e.g. via a `SIGINT` signal) to shut down, and allows you to run code _before_ Prisma Client disconnects - for example, to issue queries as part of a graceful shutdown of a service:\n\n```\nconst prisma = new PrismaClient()prisma.$on('beforeExit', async () => {  console.log('beforeExit hook')  // PrismaClient still available  await prisma.message.create({    data: {      message: 'Shutting down server',    },  })})\n```",
    "title": "Connection management | Prisma Documentation",
    "description": "This page explains how database connections are handled with Prisma Client and how to manually connect and disconnect your database.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields",
    "markdown": "# Working with Json fields (Concepts)\n\nUse the [`Json`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#json) Prisma ORM field type to read, write, and perform basic filtering on JSON types in the underlying database. In the following example, the `User` model has an optional `Json` field named `extendedPetsData`:\n\n```\nmodel User {  id               Int     @id @default(autoincrement())  email            String  @unique  name             String?  posts            Post[]  extendedPetsData Json?}\n```\n\nExample field value:\n\n```\n{  \"pet1\": {    \"petName\": \"Claudine\",    \"petType\": \"House cat\"  },  \"pet2\": {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\"  }}\n```\n\n> **Note**: The `Json` field is only supported if the [underlying database](https://www.prisma.io/docs/orm/overview) has a corresponding JSON data type.\n\nThe `Json` field supports a few additional types, such as `string` and `boolean`. These additional types exist to match the types supported by [`JSON.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse):\n\n```\nexport declare type JsonValue =  | string  | number  | boolean  | null  | JsonObject  | JsonArray\n```\n\n## Use cases for JSON fields[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#use-cases-for-json-fields \"Direct link to Use cases for JSON fields\")\n\nReasons to store data as JSON rather than representing data as related models include:\n\n*   You need to store data that does not have a consistent structure\n*   You are importing data from another system and do not want to map that data to Prisma models\n\n## Reading a `Json` field[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#reading-a-json-field \"Direct link to reading-a-json-field\")\n\nYou can use the `Prisma.JsonArray` and `Prisma.JsonObject` utility classes to work with the contents of a `Json` field:\n\n```\nconst { PrismaClient, Prisma } = require('@prisma/client')const user = await prisma.user.findFirst({  where: {    id: 9,  },})// Example extendedPetsData data:// [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }]if (  user?.extendedPetsData &&  typeof user?.extendedPetsData === 'object' &&  Array.isArray(user?.extendedPetsData)) {  const petsObject = user?.extendedPetsData as Prisma.JsonArray  const firstPet = petsObject[0]}\n```\n\nSee also: [Advanced example: Update a nested JSON key value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value)\n\n## Writing to a `Json` field[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#writing-to-a-json-field \"Direct link to writing-to-a-json-field\")\n\nThe following example writes a JSON object to the `extendedPetsData` field:\n\n```\nvar json = [  { name: 'Bob the dog' },  { name: 'Claudine the cat' },] as Prisma.JsonArrayconst createUser = await prisma.user.create({  data: {    email: 'birgitte@prisma.io',    extendedPetsData: json,  },})\n```\n\n> **Note**: JavaScript objects (for example, `{ extendedPetsData: \"none\"}`) are automatically converted to JSON.\n\nSee also: [Advanced example: Update a nested JSON key value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value)\n\n## Filter on a `Json` field (simple)[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-simple \"Direct link to filter-on-a-json-field-simple\")\n\nYou can filter rows of `Json` type.\n\n### Filter on exact field value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-exact-field-value \"Direct link to Filter on exact field value\")\n\nThe following query returns all users where the value of `extendedPetsData` matches the `json` variable exactly:\n\n```\nvar json = { [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }] }const getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      equals: json,    },  },})\n```\n\nThe following query returns all users where the value of `extendedPetsData` does **not** match the `json` variable exactly:\n\n```\nvar json = {  extendedPetsData: [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }],}const getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      not: json,    },  },})\n```\n\n## Filter on a `Json` field (advanced)[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-advanced \"Direct link to filter-on-a-json-field-advanced\")\n\nYou can also filter rows by the data inside a `Json` field. We call this **advanced `Json` filtering**. This functionality is supported by [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql) and [MySQL](https://www.prisma.io/docs/orm/overview/databases/mysql) only with [different syntaxes for the `path` option](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#path-syntax-depending-on-database).\n\ninfo\n\nThe availability of advanced `Json` filtering depends on your Prisma version:\n\n*   v4.0.0 or later: advanced `Json` filtering is [generally available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga).\n*   From v2.23.0, but before v4.0.0: advanced `Json` filtering is a [preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features). Add `previewFeatures = [\"filterJson\"]` to your schema. [Learn more](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature).\n*   Before v2.23.0: you can [filter on the exact `Json` field value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-exact-field-value), but you cannot use the other features described in this section.\n\n### `path` syntax depending on database[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#path-syntax-depending-on-database \"Direct link to path-syntax-depending-on-database\")\n\nThe filters below use a `path` option to select specific parts of the `Json` value to filter on. The implementation of that filtering differs between connectors:\n\n*   The [MySQL connector](https://www.prisma.io/docs/orm/overview/databases/mysql) uses [MySQL's implementation of JSON path](https://dev.mysql.com/doc/refman/8.0/en/json.html#json-path-syntax)\n*   The [PostgreSQL connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) uses the custom JSON functions and operators [supported in version 12 _and earlier_](https://www.postgresql.org/docs/11/functions-json.html)\n\nFor example, the following is a valid MySQL `path` value:\n\nThe following is a valid PostgreSQL `path` value:\n\n```\n[\"petFeatures\", \"petName\"]\n```\n\n### Filter on object property[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-object-property \"Direct link to Filter on object property\")\n\nYou can filter on a specific property inside a block of JSON. In the following examples, the value of `extendedPetsData` is a one-dimensional, unnested JSON object:\n\n```\n{  \"petName\": \"Claudine\",  \"petType\": \"House cat\"}\n```\n\nThe following query returns all users where the value of `petName` is `\"Claudine\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['petName'],      equals: 'Claudine',    },  },})\n```\n\nThe following query returns all users where the value of `petType` _contains_ `\"cat\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['petType'],      string_contains: 'cat',    },  },})\n```\n\nThe following string filters are available:\n\n*   [`string_contains`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_contains)\n*   [`string_starts_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_starts_with)\n*   [`string_ends_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_ends_with) .\n\n### Filter on nested object property[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-nested-object-property \"Direct link to Filter on nested object property\")\n\nYou can filter on nested JSON properties. In the following examples, the value of `extendedPetsData` is a JSON object with several levels of nesting.\n\n```\n{  \"pet1\": {    \"petName\": \"Claudine\",    \"petType\": \"House cat\"  },  \"pet2\": {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\",    \"features\": {      \"eyeColor\": \"Brown\",      \"furColor\": \"White and black\"    }  }}\n```\n\nThe following query returns all users where `\"pet2\"` → `\"petName\"` is `\"Sunny\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['pet2', 'petName'],      equals: 'Sunny',    },  },})\n```\n\nThe following query returns all users where:\n\n*   `\"pet2\"` → `\"petName\"` is `\"Sunny\"`\n*   `\"pet2\"` → `\"features\"` → `\"furColor\"` contains `\"black\"`\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    AND: [      {        extendedPetsData: {          path: ['pet2', 'petName'],          equals: 'Sunny',        },      },      {        extendedPetsData: {          path: ['pet2', 'features', 'furColor'],          string_contains: 'black',        },      },    ],  },})\n```\n\n### Filtering on an array value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-an-array-value \"Direct link to Filtering on an array value\")\n\nYou can filter on the presence of a specific value in a scalar array (strings, integers). In the following example, the value of `extendedPetsData` is an array of strings:\n\nThe following query returns all users with a pet named `\"Claudine\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      array_contains: ['Claudine'],    },  },})\n```\n\ninfo\n\n**Note**: In PostgreSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.\n\nThe following array filters are available:\n\n*   [`array_contains`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_contains)\n*   [`array_starts_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_starts_with)\n*   [`array_ends_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_ends_with)\n\n### Filtering on nested array value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-nested-array-value \"Direct link to Filtering on nested array value\")\n\nYou can filter on the presence of a specific value in a scalar array (strings, integers). In the following examples, the value of `extendedPetsData` includes nested scalar arrays of names:\n\n```\n{  \"cats\": { \"owned\": [\"Bob\", \"Sunny\"], \"fostering\": [\"Fido\"] },  \"dogs\": { \"owned\": [\"Ella\"], \"fostering\": [\"Prince\", \"Empress\"] }}\n```\n\n#### Scalar value arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#scalar-value-arrays \"Direct link to Scalar value arrays\")\n\nThe following query returns all users that foster a cat named `\"Fido\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['cats', 'fostering'],      array_contains: ['Fido'],    },  },})\n```\n\ninfo\n\n**Note**: In PostgreSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.\n\nThe following query returns all users that foster cats named `\"Fido\"` _and_ `\"Bob\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['cats', 'fostering'],      array_contains: ['Fido', 'Bob'],    },  },})\n```\n\n#### JSON object arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#json-object-arrays \"Direct link to JSON object arrays\")\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst json = [{ status: 'expired', insuranceID: 92 }]const checkJson = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['insurances'],      array_contains: json,    },  },})\n```\n\n*   If you are using PostgreSQL, you must pass in an array of objects to match, even if that array only contains one object:\n    \n    ```\n    [{ status: 'expired', insuranceID: 92 }]// PostgreSQL\n    ```\n    \n    If you are using MySQL, you must pass in a single object to match:\n    \n    ```\n    { status: 'expired', insuranceID: 92 }// MySQL\n    ```\n    \n*   If your filter array contains multiple objects, PostgreSQL will only return results if _all_ objects are present - not if at least one object is present.\n    \n*   You must set `array_contains` to a JSON object, not a string. If you use a string, Prisma Client escapes the quotation marks and the query will not return results. For example:\n    \n    ```\n    array_contains: '[{\"status\": \"expired\", \"insuranceID\": 92}]'\n    ```\n    \n    is sent to the database as:\n    \n    ```\n    [{\\\"status\\\": \\\"expired\\\", \\\"insuranceID\\\": 92}]\n    ```\n    \n\n### Targeting an array element by index[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#targeting-an-array-element-by-index \"Direct link to Targeting an array element by index\")\n\nYou can filter on the value of an element in a specific position.\n\n```\n{ \"owned\": [\"Bob\", \"Sunny\"], \"fostering\": [\"Fido\"] }\n```\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    comments: {      path: ['owned', '1'],      string_contains: 'Bob',    },  },})\n```\n\n### Filtering on object key value inside array[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-object-key-value-inside-array \"Direct link to Filtering on object key value inside array\")\n\nDepending on your provider, you can filter on the key value of an object inside an array.\n\nIn the following example, the value of `extendedPetsData` is an array of objects with a nested `insurances` array, which contains two objects:\n\n```\n[  {    \"petName\": \"Claudine\",    \"petType\": \"House cat\",    \"insurances\": [      { \"insuranceID\": 92, \"status\": \"expired\" },      { \"insuranceID\": 12, \"status\": \"active\" }    ]  },  {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\"  },  {    \"petName\": \"Gerald\",    \"petType\": \"Corn snake\"  },  {    \"petName\": \"Nanna\",    \"petType\": \"Moose\"  }]\n```\n\nThe following query returns all users where at least one pet is a moose:\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: '$[*].petType',      array_contains: 'Moose',    },  },})\n```\n\n*   `$[*]` is the root array of pet objects\n*   `petType` matches the `petType` key in any pet object\n\nThe following query returns all users where at least one pet has an expired insurance:\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: '$[*].insurances[*].status',      array_contains: 'expired',    },  },})\n```\n\n*   `$[*]` is the root array of pet objects\n*   `insurances[*]` matches any `insurances` array inside any pet object\n*   `status` matches any `status` key in any insurance object\n\n## Advanced example: Update a nested JSON key value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value \"Direct link to Advanced example: Update a nested JSON key value\")\n\nThe following example assumes that the value of `extendedPetsData` is some variation of the following:\n\n```\n{  \"petName\": \"Claudine\",  \"petType\": \"House cat\",  \"insurances\": [    { \"insuranceID\": 92, \"status\": \"expired\" },    { \"insuranceID\": 12, \"status\": \"active\" }  ]}\n```\n\nThe following example:\n\n1.  Gets all users\n2.  Change the `\"status\"` of each insurance object to `\"expired\"`\n3.  Get all users that have an expired insurance where the ID is `92`\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst userQueries: string | any[] = []getUsers.forEach((user) => {  if (    user.extendedPetsData &&    typeof user.extendedPetsData === 'object' &&    !Array.isArray(user.extendedPetsData)  ) {    const petsObject = user.extendedPetsData as Prisma.JsonObject    const i = petsObject['insurances']    if (i && typeof i === 'object' && Array.isArray(i)) {      const insurancesArray = i as Prisma.JsonArray      insurancesArray.forEach((i) => {        if (i && typeof i === 'object' && !Array.isArray(i)) {          const insuranceObject = i as Prisma.JsonObject          insuranceObject['status'] = 'expired'        }      })      const whereClause = Prisma.validator<Prisma.UserWhereInput>()({        id: user.id,      })      const dataClause = Prisma.validator<Prisma.UserUpdateInput>()({        extendedPetsData: petsObject,      })      userQueries.push(        prisma.user.update({          where: whereClause,          data: dataClause,        })      )    }  }})if (userQueries.length > 0) {  console.log(userQueries.length + ' queries to run!')  await prisma.$transaction(userQueries)}const json = [{ status: 'expired', insuranceID: 92 }]const checkJson = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['insurances'],      array_contains: json,    },  },})console.log(checkJson.length)\n```\n\n## Using `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#using-null-values \"Direct link to using-null-values\")\n\nThere are two types of `null` values possible for a `JSON` field in an SQL database.\n\n*   Database `NULL`: The value in the database is a `NULL`.\n*   JSON `null`: The value in the database contains a JSON value that is `null`.\n\nTo differentiate between these possibilities, we've introduced three _null enums_ you can use:\n\n*   `JsonNull`: Represents the `null` value in JSON.\n*   `DbNull`: Represents the `NULL` value in the database.\n*   `AnyNull`: Represents both `null` JSON values and `NULL` database values. (Only when filtering)\n\ninfo\n\nFrom v4.0.0, `JsonNull`, `DbNull`, and `AnyNull` are objects. Before v4.0.0, they were strings.\n\ninfo\n\n*   When filtering using any of the _null enums_ you can not use a shorthand and leave the `equals` operator off.\n*   These _null enums_ do not apply to MongoDB because there the difference between a JSON `null` and a database `NULL` does not exist.\n*   The _null enums_ do not apply to the `array_contains` operator in all databases because there can only be a JSON `null` within a JSON array. Since there cannot be a database `NULL` within a JSON array, `{ array_contains: null }` is not ambiguous.\n\nFor example:\n\n```\nmodel Log {  id   Int  @id  meta Json}\n```\n\nHere is an example of using `AnyNull`:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.findMany({  where: {    data: {      meta: {        equals: Prisma.AnyNull,      },    },  },})\n```\n\n### Inserting `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#inserting-null-values \"Direct link to inserting-null-values\")\n\nThis also applies to `create`, `update` and `upsert`. To insert a `null` value into a `Json` field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.JsonNull,  },})\n```\n\nAnd to insert a database `NULL` into a `Json` field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.DbNull,  },})\n```\n\n### Filtering by `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-by-null-values \"Direct link to filtering-by-null-values\")\n\nTo filter by `JsonNull` or `DbNull`, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.findMany({  where: {    meta: {      equals: Prisma.AnyNull,    },  },})\n```\n\ninfo\n\nThese _null enums_ do not apply to MongoDB because MongoDB does not differentiate between a JSON `null` and a database `NULL`. They also do not apply to the `array_contains` operator in all databases because there can only be a JSON `null` within a JSON array. Since there cannot be a database `NULL` within a JSON array, `{ array_contains: null }` is not ambiguous.\n\n## Typed `Json`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#typed-json \"Direct link to typed-json\")\n\nBy default, `Json` fields are not typed in Prisma models. To accomplish strong typing inside of these fields, you will need to use an external package like [prisma-json-types-generator](https://www.npmjs.com/package/prisma-json-types-generator) to accomplish this.\n\n### Using `prisma-json-types-generator`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#using-prisma-json-types-generator \"Direct link to using-prisma-json-types-generator\")\n\nFirst, install and configure `prisma-json-types-generator` [according to the package's instructions](https://www.npmjs.com/package/prisma-json-types-generator#using-it).\n\nThen, assuming you have a model like the following:\n\n```\nmodel Log {  id   Int  @id  meta Json}\n```\n\nYou can update it and type it by using [abstract syntax tree comments](https://www.prisma.io/docs/orm/prisma-schema/overview#comments)\n\nschema.prisma\n\n```\nmodel Log {  id Int @id  /// [LogMetaType]  meta Json}\n```\n\nThen, make sure you define the above type in a type declaration file included in your `tsconfig.json`\n\ntypes.ts\n\n```\ndeclare global {  namespace PrismaJson {    type LogMetaType = { timestamp: number; host: string }  }}\n```\n\nNow, when working with `Log.meta` it will be strongly typed!\n\n## `Json` FAQs[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#json-faqs \"Direct link to json-faqs\")\n\n### Can you select a subset of JSON key/values to return?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#can-you-select-a-subset-of-json-keyvalues-to-return \"Direct link to Can you select a subset of JSON key/values to return?\")\n\nNo - it is not yet possible to [select which JSON elements to return](https://github.com/prisma/prisma/issues/2431). Prisma Client returns the entire JSON object.\n\n### Can you filter on the presence of a specific key?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#can-you-filter-on-the-presence-of-a-specific-key \"Direct link to Can you filter on the presence of a specific key?\")\n\nNo - it is not yet possible to filter on the presence of a specific key.\n\n### Is case insensitive filtering supported?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#is-case-insensitive-filtering-supported \"Direct link to Is case insensitive filtering supported?\")\n\nNo - [case insensitive filtering](https://github.com/prisma/prisma/issues/7390) is not yet supported.\n\n### How to set a default value for JSON fields?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#how-to-set-a-default-value-for-json-fields \"Direct link to How to set a default value for JSON fields?\")\n\nWhen you want to set a `@default` value the `Json` type, you need to enclose it with double-quotes inside the `@default` attribute (and potentially escape any \"inner\" double-quotes using a backslash), for example:\n\n```\nmodel User {  id    Int  @id @default(autoincrement())  json1 Json @default(\"[]\")  json2 Json @default(\"{ \\\"hello\\\": \\\"world\\\" }\")}\n```",
    "title": "Working with Json fields (Concepts) | Prisma Documentation",
    "description": "How to read, write, and filter by Json fields.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/query",
    "markdown": "# Prisma Client extensions: query component\n\n## \\`query\\`: Create custom Prisma Client queries\n\ninfo\n\nPrisma Client extensions are Generally Available from versions 4.16.0 and later. They were introduced in Preview in version 4.7.0. Make sure you enable the `clientExtensions` Preview feature flag if you are running on a version earlier than 4.16.0.\n\nYou can use the `query` [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) component type to hook into the query life-cycle and modify an incoming query or its result.\n\nYou can use Prisma Client extensions `query` component to create independent clients. This provides an alternative to [middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware). You can bind one client to a specific filter or user, and another client to another filter or user. For example, you might do this to get [user isolation](https://www.prisma.io/docs/orm/prisma-client/client-extensions#extended-clients) in a row-level security (RLS) extension. In addition, unlike middlewares the `query` extension component gives you end-to-end type safety. [Learn more about `query` extensions versus middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#query-extensions-versus-middlewares).\n\n## Extend Prisma Client query operations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#extend-prisma-client-query-operations \"Direct link to Extend Prisma Client query operations\")\n\nUse the `$extends` [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) to create an [extended client](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions). An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions.\n\nUse the `query` extension component to modify queries. You can modify a custom query in the following:\n\n*   [A specific operation in a specific model](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-a-specific-model)\n*   [A specific operation in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-all-models-of-your-schema)\n*   [All Prisma Client operations](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations)\n*   [All operations in a specific model](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-a-specific-model)\n*   [All operations in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-all-models-of-your-schema)\n*   [A specific top-level raw query operation](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-top-level-raw-query-operation)\n\nTo create a custom query, use the following structure:\n\n```\nconst prisma = new PrismaClient().$extends({  name?: 'name',  query?: {    user: { ... } // in this case, we add a query to the `user` model  },});\n```\n\nThe properties are as follows:\n\n*   `name`: (optional) specifies a name for the extension that appears in error logs.\n*   `query`: defines a custom query.\n\n### Modify a specific operation in a specific model[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-a-specific-model \"Direct link to Modify a specific operation in a specific model\")\n\nThe `query` object can contain functions that map to the names of the [Prisma Client operations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-queries), such as `findUnique()`, `findFirst`, `findMany`, `count`, and `create`. The following example modifies `user.findMany` to a use a customized query that finds only users who are older than 18 years:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      async findMany({ model, operation, args, query }) {        // take incoming `where` and set `age`        args.where = { ...args.where, age: { gt: 18 } }        return query(args)      },    },  },})await prisma.user.findMany() // returns users whose age is greater than 18\n```\n\nIn the above example, a call to `prisma.user.findMany` triggers `query.user.findMany`. Each callback receives a type-safe `{ model, operation, args, query }` object that describes the query. This object has the following properties:\n\n*   `model`: the name of the containing model for the query that we want to extend.\n    \n    In the above example, the `model` is a string of type `\"User\"`.\n    \n*   `operation`: the name of the operation being extended and executed.\n    \n    In the above example, the `operation` is a string of type `\"findMany\"`.\n    \n*   `args`: the specific query input information to be extended.\n    \n    This is a type-safe object that you can mutate before the query happens. You can mutate any of the properties in `args`. Exception: you cannot mutate `include` or `select` because that would change the expected output type and break type safety.\n    \n*   `query`: a promise for the result of the query.\n    \n    *   You can use `await` and then mutate the result of this promise, because its value is type-safe. TypeScript catches any unsafe mutations on the object.\n\n### Modify a specific operation in all models of your schema[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-all-models-of-your-schema \"Direct link to Modify a specific operation in all models of your schema\")\n\nTo extend the queries in all the models of your schema, use `$allModels` instead of a specific model name. For example:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allModels: {      async findMany({ model, operation, args, query }) {        // set `take` and fill with the rest of `args`        args = { ...args, take: 100 }        return query(args)      },    },  },})\n```\n\n### Modify all operations in a specific model[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-a-specific-model \"Direct link to Modify all operations in a specific model\")\n\nUse `$allOperations` to extend all operations in a specific model.\n\nFor example, the following code applies a custom query to all operations on the `user` model:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      $allOperations({ model, operation, args, query }) {        /* your custom logic here */        return query(args)      },    },  },})\n```\n\n### Modify all Prisma Client operations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations \"Direct link to Modify all Prisma Client operations\")\n\nUse the `$allOperations` method to modify all query methods present in Prisma Client. The `$allOperations` can be used on both model operations and raw queries.\n\nYou can modify all methods as follows:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allOperations({ model, operation, args, query }) {      /* your custom logic for modifying all Prisma Client operations here */      return query(args)    },  },})\n```\n\nIn the event a [raw query](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) is invoked, the `model` argument passed to the callback will be `undefined`.\n\nFor example, you can use the `$allOperations` method to log queries as follows:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    async $allOperations({ operation, model, args, query }) {      const start = performance.now()      const result = await query(args)      const end = performance.now()      const time = end - start      console.log(        util.inspect(          { model, operation, args, time },          { showHidden: false, depth: null, colors: true }        )      )      return result    },  },})\n```\n\n### Modify all operations in all models of your schema[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-all-models-of-your-schema \"Direct link to Modify all operations in all models of your schema\")\n\nUse `$allModels` and `$allOperations` to extend all operations in all models of your schema.\n\nTo apply a custom query to all operations on all models of your schema:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allModels: {      $allOperations({ model, operation, args, query }) {        /* your custom logic for modifying all operations on all models here */        return query(args)      },    },  },})\n```\n\n### Modify a top-level raw query operation[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-top-level-raw-query-operation \"Direct link to Modify a top-level raw query operation\")\n\nTo apply custom behavior to a specific top-level raw query operation, use the name of a top-level raw query function instead of a model name:\n\n*   Relational databases\n*   MongoDB\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $queryRaw({ args, query, operation }) {      // handle $queryRaw operation      return query(args)    },    $executeRaw({ args, query, operation }) {      // handle $executeRaw operation      return query(args)    },    $queryRawUnsafe({ args, query, operation }) {      // handle $queryRawUnsafe operation      return query(args)    },    $executeRawUnsafe({ args, query, operation }) {      // handle $executeRawUnsafe operation      return query(args)    },  },})\n```\n\n### Mutate the result of a query[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#mutate-the-result-of-a-query \"Direct link to Mutate the result of a query\")\n\nYou can use `await` and then mutate the result of the `query` promise.\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      async findFirst({ model, operation, args, query }) {        const user = await query(args)        if (user.password !== undefined) {          user.password = '******'        }        return user      },    },  },})\n```\n\ninfo\n\nWe include the above example to show that this is possible. However, for performance reasons we recommend that you use the [`result` component type](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result) to override existing fields. The `result` component type usually gives better performance in this situation because it computes only on access. The `query` component type computes after query execution.\n\n## Wrap a query into a batch transaction[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#wrap-a-query-into-a-batch-transaction \"Direct link to Wrap a query into a batch transaction\")\n\nYou can wrap your extended queries into a [batch transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions). For example, you can use this to enact row-level security (RLS).\n\nThe following example extends `findFirst` so that it runs in a batch transaction.\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      // Get the input `args` and a callback to `query`      async findFirst({ args, query, operation }) {        const [result] = await prisma.$transaction([query(args)]) // wrap the query in a batch transaction, and destructure the result to return an array        return result // return the first result found in the array      },    },  },})\n```\n\n## Query extensions versus middlewares[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#query-extensions-versus-middlewares \"Direct link to Query extensions versus middlewares\")\n\nYou can use query extensions or [middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) to hook into the query life-cycle and modify an incoming query or its result. Client extensions and middlewares differ in the following ways:\n\n*   Middlewares always apply globally to the same client. Client extensions are isolated, unless you deliberately combine them. [Learn more about client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions).\n    *   For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.\n*   During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.\n*   Extensions benefit from end-to-end type safety and inference, but middlewares don't.\n\nYou can use Prisma Client extensions in all scenarios where middlewares can be used.\n\n### If you use the `query` extension component and middlewares[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#if-you-use-the-query-extension-component-and-middlewares \"Direct link to if-you-use-the-query-extension-component-and-middlewares\")\n\nIf you use the `query` extension component and middlewares in your project, then the following rules and priorities apply:\n\n*   In your application code, you must declare all your middlewares on the main Prisma Client instance. You cannot declare them on an extended client.\n*   In situations where middlewares and extensions with a `query` component execute, Prisma Client executes the middlewares before it executes the extensions with the `query` component. Prisma Client executes the individual middlewares and extensions in the order in which you instantiated them with `$use` or `$extends`.",
    "title": "Prisma Client extensions: query component | Prisma Documentation",
    "description": "Extend the functionality of Prisma Client, query component",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics",
    "markdown": "# Metrics (Preview) | Prisma Documentation\n\n```\n{  \"counters\": [    {      \"key\": \"prisma_client_queries_total\",      \"labels\": {},      \"value\": 2,      \"description\": \"Total number of Prisma Client queries executed\"    },    {      \"key\": \"prisma_datasource_queries_total\",      \"labels\": {},      \"value\": 5,      \"description\": \"Total number of Datasource Queries executed\"    },    {      \"key\": \"prisma_pool_connections_open\",      \"labels\": {},      \"value\": 1,      \"description\": \"Number of currently open Pool Connections\"    }  ],  \"gauges\": [    {      \"key\": \"prisma_client_queries_active\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of currently active Prisma Client queries\"    },    {      \"key\": \"prisma_client_queries_wait\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of Prisma Client queries currently waiting for a connection\"    },    {      \"key\": \"prisma_pool_connections_busy\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of currently busy Pool Connections (executing a datasource query)\"    },    {      \"key\": \"prisma_pool_connections_idle\",      \"labels\": {},      \"value\": 21,      \"description\": \"Number of currently unused Pool Connections (waiting for the next datasource query to run)\"    },    {      \"key\": \"prisma_pool_connections_open\",      \"labels\": {},      \"value\": 1,      \"description\": \"Number of currently open Pool Connections\"    }  ],  \"histograms\": [    {      \"key\": \"prisma_client_queries_duration_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 0],          [5, 0],          [10, 1],          [50, 1],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 47.430541000000005,        \"count\": 2      },      \"description\": \"Histogram of the duration of all executed Prisma Client queries in ms\"    },    {      \"key\": \"prisma_client_queries_wait_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 3],          [5, 0],          [10, 0],          [50, 0],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 0.0015830000000000002,        \"count\": 3      },      \"description\": \"Histogram of the wait time of all Prisma Client Queries in ms\"    },    {      \"key\": \"prisma_datasource_queries_duration_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 0],          [5, 2],          [10, 2],          [50, 1],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 47.134498,        \"count\": 5      },      \"description\": \"Histogram of the duration of all executed Datasource Queries in ms\"    }  ]}\n```",
    "title": "Metrics (Preview) | Prisma Documentation",
    "description": "Diagnose application performance with insights into Prisma Client database activity.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features",
    "markdown": "# Prisma Client & Prisma schema\n\nWhen we release a new Prisma Client or Prisma schema feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see [ORM releases and maturity levels](https://www.prisma.io/docs/orm/more/releases).\n\n## Currently active Preview features[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#currently-active-preview-features \"Direct link to Currently active Preview features\")\n\nThe following [Preview](https://www.prisma.io/docs/orm/more/releases#preview) feature flags are available for Prisma Client and Prisma schema:\n\n| Feature | Released into Preview | Feedback issue |\n| --- | --- | --- |\n| [`fullTextSearch`](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search) | [2.30.0](https://github.com/prisma/prisma/releases/tag/2.30.0) | [Submit feedback](https://github.com/prisma/prisma/issues/8877) |\n| [`fullTextIndex`](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#full-text-indexes-mysql-and-mongodb) | [3.6.0](https://github.com/prisma/prisma/releases/tag/3.6.0) | [Submit feedback](https://github.com/prisma/prisma/issues/10539) |\n| [`metrics`](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) | [3.15.0](https://github.com/prisma/prisma/releases/tag/3.15.0) | [Submit feedback](https://github.com/prisma/prisma/issues/13579) |\n| [`tracing`](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing) | [4.2.0](https://github.com/prisma/prisma/releases/tag/4.2.0) | [Submit feedback](https://github.com/prisma/prisma/issues/14640) |\n| [`multiSchema`](https://github.com/prisma/prisma/issues/1122#issuecomment-1231773471) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15077) |\n| [`postgresqlExtensions`](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15835) |\n| [`deno`](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15844) |\n| [`views`](https://www.prisma.io/docs/orm/prisma-schema/data-model/views) | [4.9.0](https://github.com/prisma/prisma/releases/tag/4.9.0) | [Submit feedback](https://github.com/prisma/prisma/issues/17335) |\n| `driverAdapters` | [5.4.0](https://github.com/prisma/prisma/releases/tag/5.4.0) | [Submit feedback](https://github.com/prisma/prisma/issues/3108) |\n| `relationJoins` | [5.7.0](https://github.com/prisma/prisma/releases/tag/5.7.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/22288) |\n| `nativeDistinct` | [5.7.0](https://github.com/prisma/prisma/releases/tag/5.7.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/22287) |\n| `omitApi` | [5.13.0](https://github.com/prisma/prisma/releases/tag/5.13.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/23924) |\n| `prismaSchemaFolder` | [5.15.0](https://github.com/prisma/prisma/releases/tag/5.15.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/24413) |\n\nTo enable a Preview feature, [add the feature flag to the `generator` block](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) in your `schema.prisma` file. [Share your feedback on all Preview features on GitHub](https://github.com/prisma/prisma/issues/3108).\n\n## Enabling a Prisma Client Preview feature[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature \"Direct link to Enabling a Prisma Client Preview feature\")\n\nTo enable a Prisma Client Preview feature:\n\n1.  Add the Preview feature flag to the `generator` block:\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n    ```\n    \n2.  Re-generate Prisma Client:\n    \n    ```\n    npx prisma generate\n    ```\n    \n3.  If you are using Visual Studio Code and the Preview feature is not available in your `.ts` file after generating Prisma Client, run the **TypeScript: Restart TS server** command.\n    \n\n## Preview features promoted to general availability[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#preview-features-promoted-to-general-availability \"Direct link to Preview features promoted to general availability\")\n\nIn the list below, you can find a history of Prisma Client and Prisma schema features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\n| Feature | Released into Preview | Released into General Availability |\n| --- | --- | --- |\n| `jsonProtocol` | [4.11.0](https://github.com/prisma/prisma/releases/tag/4.11.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`extendedWhereUnique`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`fieldReference`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`clientExtensions`](https://www.prisma.io/docs/orm/prisma-client/client-extensions) | [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`filteredRelationCount`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`orderByNulls`](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last) | [4.1.0](https://github.com/prisma/prisma/releases/tag/4.1.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`referentialIntegrity`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode) | [3.1.1](https://github.com/prisma/prisma/releases/tag/3.1.1) | [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0) |\n| [`interactiveTransactions`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions) | [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) | *   [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0)<br>*   with Prisma Accelerate [5.1.1](https://github.com/prisma/prisma/releases/tag/5.1.1) |\n| [`extendedIndexes`](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes) | [3.5.0](https://github.com/prisma/prisma/releases/tag/3.5.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`filterJson`](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-simple) | [2.23.0](https://github.com/prisma/prisma/releases/tag/2.23.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`improvedQueryRaw`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) | [3.14.0](https://github.com/prisma/prisma/releases/tag/3.14.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`cockroachdb`](https://www.prisma.io/docs/orm/overview/databases/cockroachdb) | *   [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0)<br>*   migrations in CockroachDB in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) | [3.14.0](https://github.com/prisma/prisma/releases/tag/3.14.0) |\n| [`mongodb`](https://www.prisma.io/docs/orm/overview/databases/mongodb) | *   [2.27.0](https://github.com/prisma/prisma/releases/tag/2.27.0)<br>*   introspection of MongoDB in [3.2.0](https://github.com/prisma/prisma/releases/tag/3.2.0)<br>*   introspection of embedded documents in [3.4.0](https://github.com/prisma/prisma/releases/tag/3.4.0)<br>*   MongoDB embedded documents in [3.10.0](https://github.com/prisma/prisma/releases/tag/3.10.0)<br>*   introspection of embedded documents in [3.10.0](https://github.com/prisma/prisma/releases/tag/3.10.0)<br>*   raw query support for MongoDB in [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0)<br>*   filters in embedded documents as an Experimental Feature in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0)<br>*   order by embedded documents in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) | [3.12.0](https://github.com/prisma/prisma/releases/tag/3.12.0) |\n| [`microsoftSqlServer`](https://www.prisma.io/docs/orm/overview/databases/sql-server) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`namedConstraints`](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names) | [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`referentialActions`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) | [2.26.0](https://github.com/prisma/prisma/releases/tag/2.26.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`orderByAggregateGroup`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-aggregate-group) | [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`orderByRelation`](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation) | *   [2.16.0](https://github.com/prisma/prisma/releases/tag/2.16.0)<br>*   order by aggregates of relations in [2.19.0](https://github.com/prisma/prisma/releases/tag/2.19.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`selectRelationCount`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| `napi` | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`groupBy`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby) | [2.14.0](https://github.com/prisma/prisma/releases/tag/2.14.0) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) |\n| [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany) | [2.16.0](https://github.com/prisma/prisma/releases/tag/2.16.0) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) |\n| [`nativeTypes`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) | [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) |\n| [`uncheckedScalarInputs`](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-a-single-record-and-multiple-related-records) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) | [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) |\n| [`transactionApi`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api) | [2.1.0](https://github.com/prisma/prisma/releases/tag/2.1.0) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) |\n| [`connectOrCreate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate) | [2.1.0](https://github.com/prisma/prisma/releases/tag/2.1.0) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) |\n| [`atomicNumberOperations`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations) | [2.6.0](https://github.com/prisma/prisma/releases/tag/2.6.0) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) |\n| [`insensitiveFilters` (PostgreSQL)](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) | [2.8.0](https://github.com/prisma/prisma/releases/tag/2.8.0) |\n| [`middlewares`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) | [2.3.0](https://github.com/prisma/prisma/releases/tag/2.3.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |\n| [`aggregateApi`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate) | [2.2.0](https://github.com/prisma/prisma/releases/tag/2.2.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |\n| [`distinct`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#distinct) | [2.3.0](https://github.com/prisma/prisma/releases/tag/2.3.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |",
    "title": "Prisma Client & Prisma schema | Prisma Documentation",
    "description": "Prisma Client and Prisma schema features that are currently in Preview.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations",
    "markdown": "# One-to-one relations | Prisma Documentation\n\nThis page introduces one-to-one relations and explains how to use them in your Prisma schema.\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#overview \"Direct link to Overview\")\n\nOne-to-one (1-1) relations refer to relations where at most **one** record can be connected on both sides of the relation. In the example below, there is a one-to-one relation between `User` and `Profile`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile?}model Profile {  id     Int  @id @default(autoincrement())  user   User @relation(fields: [userId], references: [id])  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nThe `userId` relation scalar is a direct representation of the foreign key in the underlying database. This one-to-one relation expresses the following:\n\n*   \"a user can have zero profiles or one profile\" (because the `profile` field is [optional](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) on `User`)\n*   \"a profile must always be connected to one user\"\n\nIn the previous example, the `user` relation field of the `Profile` model references the `id` field of the `User` model. You can also reference a different field. In this case, you need to mark the field with the `@unique` attribute, to guarantee that there is only a single `User` connected to each `Profile`. In the following example, the `user` field references an `email` field in the `User` model, which is marked with the `@unique` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique // <-- add unique attribute  profile Profile?}model Profile {  id        Int    @id @default(autoincrement())  user      User   @relation(fields: [userEmail], references: [email])  userEmail String @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nwarning\n\nIn MySQL, you can create a foreign key with only an index on the referenced side, and not a unique constraint. In Prisma ORM versions 4.0.0 and later, if you introspect a relation of this type it will trigger a validation error. To fix this, you will need to add a `@unique` constraint to the referenced field.\n\n## Multi-field relations in relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#multi-field-relations-in-relational-databases \"Direct link to Multi-field relations in relational databases\")\n\nIn **relational databases only**, you can also use [multi-field IDs](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) to define a 1-1 relation:\n\n```\nmodel User {  firstName String  lastName  String  profile   Profile?  @@id([firstName, lastName])}model Profile {  id            Int    @id @default(autoincrement())  user          User   @relation(fields: [userFirstName, userLastName], references: [firstName, lastName])  userFirstName String // relation scalar field (used in the `@relation` attribute above)  userLastName  String // relation scalar field (used in the `@relation` attribute above)  @@unique([userFirstName, userLastName])}\n```\n\n## 1-1 relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#1-1-relations-in-the-database \"Direct link to 1-1 relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#relational-databases \"Direct link to Relational databases\")\n\nThe following example demonstrates how to create a 1-1 relation in SQL:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Profile\" (    id SERIAL PRIMARY KEY,    \"userId\" INTEGER NOT NULL UNIQUE,    FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```\n\nNotice that there is a `UNIQUE` constraint on the foreign key `userId`. If this `UNIQUE` constraint was missing, the relation would be considered a [1-n relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations).\n\nThe following example demonstrates how to create a 1-1 relation in SQL using a composite key (`firstName` and `lastName`):\n\n```\nCREATE TABLE \"User\" (    firstName TEXT,    lastName TEXT,    PRIMARY KEY (\"firstName\",\"lastName\"));CREATE TABLE \"Profile\" (    id SERIAL PRIMARY KEY,    \"userFirstName\" TEXT NOT NULL,    \"userLastName\" TEXT NOT NULL,    UNIQUE (\"userFirstName\", \"userLastName\")    FOREIGN KEY (\"userFirstName\", \"userLastName\") REFERENCES \"User\"(\"firstName\", \"lastName\"));\n```\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mongodb \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB document represents a `User`:\n\n```\n{ \"_id\": { \"$oid\": \"60d58e130011041800d209e1\" }, \"name\": \"Bob\" }\n```\n\nThe following MongoDB document represents a `Profile` - notice the `userId` field, which references the `User` document's `$oid`:\n\n```\n{  \"_id\": { \"$oid\": \"60d58e140011041800d209e2\" },  \"bio\": \"I'm Bob, and I like drawing.\",  \"userId\": { \"$oid\": \"60d58e130011041800d209e1\" }}\n```\n\n## Required and optional 1-1 relation fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#required-and-optional-1-1-relation-fields \"Direct link to Required and optional 1-1 relation fields\")\n\nIn a one-to-one relation, the side of the relation _without_ a relation scalar (the field representing the foreign key in the database) _must_ be optional:\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile? // No relation scalar - must be optional}\n```\n\nThis restriction was introduced in 2.12.0.\n\nHowever, you can choose if the side of the relation _with_ a relation scalar should be optional or mandatory.\n\n### Mandatory 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mandatory-1-1-relation \"Direct link to Mandatory 1-1 relation\")\n\nIn the following example, `profile` and `profileId` are mandatory. This means that you cannot create a `User` without connecting or creating a `Profile`:\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  profile   Profile @relation(fields: [profileId], references: [id]) // references `id` of `Profile`  profileId Int     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n### Optional 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#optional-1-1-relation \"Direct link to Optional 1-1 relation\")\n\nIn the following example, `profile` and `profileId` are optional. This means that you can create a user without connecting or creating a `Profile`:\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id]) // references `id` of `Profile`  profileId Int?     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n## Choosing which side should store the foreign key in a 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#choosing-which-side-should-store-the-foreign-key-in-a-1-1-relation \"Direct link to Choosing which side should store the foreign key in a 1-1 relation\")\n\nIn **1-1 relations**, you can decide yourself which side of the relation you want to annotate with the `@relation` attribute (and therefore holds the foreign key).\n\nIn the following example, the relation field on the `Profile` model is annotated with the `@relation` attribute. `userId` is a direct representation of the foreign key in the underlying database:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile?}model Profile {  id     Int  @id @default(autoincrement())  user   User @relation(fields: [userId], references: [id])  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nYou can also annotate the other side of the relation with the `@relation` attribute. The following example annotates the relation field on the `User` model. `profileId` is a direct representation of the foreign key in the underlying database:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id])  profileId Int?     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```",
    "title": "One-to-one relations | Prisma Documentation",
    "description": "How to define and work with one-to-one relations in Prisma.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features",
    "markdown": "# Prisma CLI Preview features | Prisma Documentation\n\nWhen we release a new Prisma CLI feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see [ORM releases and maturity levels](https://www.prisma.io/docs/orm/more/releases).\n\n## Currently active Preview features[​](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features#currently-active-preview-features \"Direct link to Currently active Preview features\")\n\nThere are currently no [Preview](https://www.prisma.io/docs/orm/more/releases#preview) features for Prisma CLI.\n\nIn the list below, you can find a history of Prisma CLI features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\n| Features | Released in Preview | Released in general availability |\n| --- | --- | --- |\n| [`prisma migrate diff`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute) | [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) | [3.13.0](https://github.com/prisma/prisma/releases/tag/3.13.0) |\n| [`prisma db execute`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute) | [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) | [3.13.0](https://github.com/prisma/prisma/releases/tag/3.13.0) |\n| [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) | [2.22.0](https://github.com/prisma/prisma/releases/tag/2.22.0) |\n| [`prisma migrate`](https://www.prisma.io/docs/orm/prisma-migrate) | [2.13.0](https://github.com/prisma/prisma/releases/tag/2.13.0) | [2.19.0](https://github.com/prisma/prisma/releases/tag/2.19.0) |",
    "title": "Prisma CLI Preview features | Prisma Documentation",
    "description": "Prisma CLI features that are currently in Preview.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions",
    "markdown": "# Upgrading versions (Guides) | Prisma Documentation\n\nThe `dev` [Npm distribution tag](https://docs.npmjs.com/adding-dist-tags-to-packages) points to the most recent development version of the package, which is published for each commit to the main branch of `prisma/prisma`. You can use the `dev` distribution tag to verify a fix or test a feature before it is officially released.\n\n```\nnpm install @prisma/client@dev prisma@dev\n```\n\ndanger\n\nDo not use the `dev` distribution tag in production - wait until the official release that contains the features and fixes you are interested in is released. For example, fixes present `@prisma/client@2.23.0-dev.25` will eventually be released as part of `@prisma/client@2.23.0`.",
    "title": "Upgrading versions (Guides) | Prisma Documentation",
    "description": "Upgrading your project to the latest version of Prisma ORM.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features",
    "markdown": "# Upgrading to use Preview features (Guides)\n\nPreview features are new features that can only be used by opting in using a corresponding feature flag.\n\n## Enabling preview features[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features#enabling-preview-features \"Direct link to Enabling preview features\")\n\nSome releases include Preview features that are not considered production-ready, and must be enabled before you can use them. For more information about enabling Preview features, refer to the following documentation:\n\n*   [Enable Prisma Client and schema preview features](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features)\n*   [Enable Prisma CLI preview features](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features)\n\nwarning\n\nWe do not recommend using Preview features in production.",
    "title": "Upgrading to use Preview features (Guides) | Prisma Documentation",
    "description": "Upgrading your project to use a Preview feature.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1",
    "markdown": "# Upgrade from Prisma 1 to Prisma ORM 2\n\n## In this section[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1#in-this-section \"Direct link to In this section\")\n\n[\n\n## How to upgrade\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade)\n\n[\n\n## Schema incompatibilities\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql)\n\n[\n\n## Schema incompatibilities\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql)\n\n[\n\n## Upgrading the Prisma ORM layer\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql)\n\n[\n\n## Upgrading the Prisma ORM layer\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql)\n\n[\n\n## Old to new Nexus\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus)\n\n[\n\n## prisma-binding to Nexus\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus)\n\n[\n\n## prisma-binding to SDL-first\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first)\n\n[\n\n## REST API\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api)\n\n[\n\n## Upgrade from MongoDB Beta\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta)",
    "title": "Upgrade from Prisma 1 to Prisma ORM 2 | Prisma Documentation",
    "description": "Upgrading your project from Prisma 1 to Prisma ORM 2",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles",
    "markdown": "# Help articles | Prisma Documentation\n\nThis section provides a number of common problems that developers might encounter when using Prisma ORM and provides short, practical solutions to resolve them.\n\n## Help articles[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles#help-articles \"Direct link to Help articles\")\n\n[\n\n## Autocompletion in GraphQL resolvers with JavaScript\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/autocompletion-in-graphql-resolvers-with-js)\n\n[\n\n## Modeling and querying many-to-many relations\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations)\n\n[\n\n## Best practice for instantiating Prisma Client with Next.js\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices)\n\n[\n\n## Using Prisma Client in a Next.js project in a monorepo setup\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo)\n\n[\n\n## Best practices for using Prisma Client with Next.js and Next.js Data Cache\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dynamic)\n\n[\n\n## Solve package error with vercel/pkg\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/pkg-issue)\n\n[\n\n## Compare columns of the same table with raw queries\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries)\n\n[\n\n## Vercel build dependency caching workaround\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue)\n\n[\n\n## Netlify build dependency caching workaround\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue)\n\n[\n\n## Data validation with CHECK constraints (PostgreSQL)\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints)\n\n[\n\n## Using the Nuxt Prisma Module\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module)",
    "title": "Help articles | Prisma Documentation",
    "description": "Common problems and how to solve them.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports",
    "markdown": "# Creating bug reports for Prisma ORM\n\n## Overview[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#overview \"Direct link to Overview\")\n\nYou can help us improve Prisma ORM by creating **bug reports**. When creating a bug report, it's important that you include as much information as possible about your issue. That way, it's easier to reproduce.\n\nNote that you can also create **feature requests** or ask a **question** via the issue templates on GitHub.\n\n## Where to open the bug report on GitHub?[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#where-to-open-the-bug-report-on-github \"Direct link to Where to open the bug report on GitHub?\")\n\nPrisma ORM's tools are spread across different repositories in the [`prisma`](https://github.com/prisma/) organization on GitHub. You can open a new issue in the repo of the respective tool.\n\nIf you're unsure where to open the GitHub issue, you can use the main [`prisma/prisma`](https://github.com/prisma/prisma) repo as a default. Our engineering team is regularly triaging new issues and will move the issue to another repo if necessary.\n\nIn an ideal scenario, you're able to reproduce the bug in an isolated environment and put it into a GitHub repository that you can share in your report. That way, we already have a reproduction and the problem can be tackled without further triaging.\n\nThis [StackOverflow guide](https://stackoverflow.com/help/minimal-reproducible-example) has a lot of helpful information for creating minimal, reproducible examples.\n\n## Best practices for writing a bug report[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#best-practices-for-writing-a-bug-report \"Direct link to Best practices for writing a bug report\")\n\nIf you don't have the time to create a full reproduction of the issue, please include as much information as possible about the problem. The [bug report template](https://pris.ly/prisma-prisma-bug-report) helps you with that.\n\n### Include logging and debugging output[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-logging-and-debugging-output \"Direct link to Include logging and debugging output\")\n\nPlease make sure to include _any_ [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) and [debugging](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) output in the issue that may help to identify the problem.\n\n**Setting the `DEBUG` env var**\n\nTo get additional output from Prisma ORM, you can set `DEBUG` to `*`:\n\n**Print logs of Prisma Client**\n\nYou can enable additional logs in Prisma Client by instantiating it with the `log` option:\n\n```\nconst prisma = new PrismaClient({ log: ['query', 'info', 'warn'] })\n```\n\n### Include a bug description, reproduction and expected behavior[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-a-bug-description-reproduction-and-expected-behavior \"Direct link to Include a bug description, reproduction and expected behavior\")\n\nWhen describing the bug, it's helpful to include the following information:\n\n*   A clear and concise description of what the bug is\n*   Steps to reproduce the bug\n*   A clear and concise description of what you expected to happen\n*   Screenshots (if applicable)\n\nExpand for an example for a hypothetical bug report\n\n**Example**\n\n**Describe the bug**\n\n`@unique` attribute on `email` field doesn't work on my model. I can create duplicate records with the same `email`.\n\n**To reproduce**:\n\nI have this Prisma schema (removed all unnecessary models and fields):\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique}\n```\n\nI then run `prisma generate` to generate Prisma Client.\n\nI then have a Node.js script that creates two `User` records with the same `email`:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// A `main` function so that we can use async/awaitasync function main() {  const user1 = await prisma.create({    data: { email: 'alice@prisma.io' },  })  const user2 = await prisma.create({    data: { email: 'alice@prisma.io' },  })  console.log(user1, user2)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n**Expected behavior**\n\nI expected an exception when trying to create `user2` with the same `email` as `user1` because this violates the `@unique` constraint defined in the Prisma schema.\n\n### Include environment and setup information[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-environment-and-setup-information \"Direct link to Include environment and setup information\")\n\nPlease include any information about your environment and setup. Specifically it's important to include:\n\n*   Which **operating system** you use (e.g. macOS, Windows, Debian, CentOS, ...)\n*   Which **database** you use with Prisma ORM (PostgreSQL, MySQL, MariaDB, SQLite or Microsoft SQL Server)\n*   Which **version of Prisma ORM** you use (run `prisma -v` to see your Prisma ORM version)\n*   Which **version of Node.js** you use (run `node -v` to see your Node.js version)\n\nHere's an example of what this could look like in your bug report:\n\n*   OS: macOS Catalina 10.15.7\n*   Database: PostgreSQL v11\n*   Node.js version: `v14.16.1`\n*   Prisma ORM version:\n\n```\nprisma               : 2.22.0@prisma/client       : Not foundCurrent platform     : darwinQuery Engine         : query-engine 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/query-engine-darwin)Migration Engine     : migration-engine-cli 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/migration-engine-darwin)Format Binary        : prisma-fmt 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/prisma-fmt-darwin)Default Engines Hash : 60cc71d884972ab4e897f0277c4b84383dddaf6cStudio               : 0.379.0\n```\n\nAdditionally, you can use the [`prisma debug`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#debug) command to retrieve debugging information. The `prisma debug` command provides debugging information that compliments the output of the `prisma -v` command. The information includes [environment variables](https://www.prisma.io/docs/orm/reference/environment-variables-reference) used for Prisma Client, Prisma Migrate, Prisma CLI, and Prisma Studio.\n\ninfo\n\nThe `prisma debug` command is available from version 5.6.0 and newer. If you're using an older version of Prisma ORM, you can use this command by running:\n\n### Include relevant Prisma ORM info (e.g. the Prisma schema, Prisma Client queries, ...)[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-relevant-prisma-orm-info-eg-the-prisma-schema-prisma-client-queries- \"Direct link to Include relevant Prisma ORM info (e.g. the Prisma schema, Prisma Client queries, ...)\")\n\nTo help us reproduce your problem, it is helpful to include your Prisma schema in the bug report. **Please remove any database credentials before sharing your Prisma schema in a bug report**. If you're sure about which parts of the schema is causing the issue, please strip out the irrelevant parts of it and only show the parts that are related to the problem. If you're not sure, please include your entire schema.\n\nIf you have an issue with Prisma Client, please also include which Prisma Client query is causing the issue.",
    "title": "Creating bug reports for Prisma ORM | Prisma Documentation",
    "description": "This page explains best practices for creating bug reports for Prisma ORM, including sharing additional debugging output and other recommendations.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm",
    "markdown": "# Prisma ORM vs TypeORM | Prisma Documentation\n\nThis page compares Prisma ORM and [TypeORM](https://typeorm.io/#/). If you want to learn how to migrate from TypeORM to Prisma ORM, check out this [guide](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm).\n\n## TypeORM vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-vs-prisma-orm \"Direct link to TypeORM vs Prisma ORM\")\n\nWhile Prisma ORM and TypeORM solve similar problems, they work in very different ways.\n\n**TypeORM** is a traditional ORM which maps _tables_ to _model classes_. These model classes can be used to generate SQL migrations. Instances of the model classes then provide an interface for CRUD queries to an application at runtime.\n\n**Prisma ORM** is a new kind of ORM that mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading.\n\nIt uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows to generate SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## API design & Level of abstraction[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-design--level-of-abstraction \"Direct link to API design & Level of abstraction\")\n\nTypeORM and Prisma ORM operate on different levels of abstraction. TypeORM is closer to mirroring SQL in its API while Prisma Client provides a higher-level abstraction that was carefully designed with the common tasks of application developers in mind. Prisma ORM's API design heavily leans on the idea of [making the right thing easy](https://jason.energy/right-thing-easy-thing/).\n\nWhile Prisma Client operates on a higher-level of abstraction, it strives to expose the full power of the underlying database and lets you drop down to [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) at any time if your use case requires it.\n\nThe following sections examine a few examples for how Prisma ORM's and TypeORM's APIs differ in certain scenarios and what the rationale of Prisma ORM's API design is in these cases.\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering \"Direct link to Filtering\")\n\nTypeORM primarily leans on SQL operators for filtering lists or records, e.g. with the `find` method. Prisma ORM on the other hand, provides a more [generic set of operators](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators) that are intuitive to use. It should also be noted that, as explained in the type-safety section [below](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-1), TypeORM loses type-safety in filter queries in many scenarios.\n\nA good example of how the filtering APIs of both TypeORM and Prisma ORM differ is by looking at `string` filters. While TypeORM primarily provides the filter based on the `ILike` operator which comes directly from SQL, Prisma ORM provides more specific operators that developers can use, e.g.: `contains`, `startsWith` and `endsWith`.\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('Hello World'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { contains: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('%Hello World%'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { startsWith: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('Hello World%'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { endsWith: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('%Hello World'),  },})\n```\n\nTypeORM only offers limit-offset pagination while Prisma ORM conveniently provides dedicated APIs for both limit-offset but also cursor-based. You can learn more about both approaches in the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) section of the docs or in the API comparison [below](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#pagination-1).\n\n### Relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#relations \"Direct link to Relations\")\n\nWorking with records that are connected via foreign keys can become very complex in SQL. Prisma ORM's concept of [virtual relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) enables an intuitive and convenient way for application developers to work with related data. Some benefits of Prisma ORM's approach are:\n\n*   traversing relationships via the fluent API ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api))\n*   nested writes that enable updating/creating connected records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes))\n*   applying filters on related records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters))\n*   easy and type-safe querying of nested data without worrying about JOINs ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads))\n*   creating nested TypeScript typings based on models and their relations ([docs](https://www.prisma.io/docs/orm/prisma-client/type-safety))\n*   intuitive modeling of relations in the data model via relation fields ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations))\n*   implicit handling of relation tables (also sometimes called JOIN, link, pivot or junction tables) ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations))\n\n### Data modeling and migrations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#data-modeling-and-migrations \"Direct link to Data modeling and migrations\")\n\nPrisma models are defined in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) while TypeORM uses classes and experimental TypeScript decorators for model definitions. With the Active Record ORM pattern, TypeORM's approach often leads to complex model instances that are becoming hard to maintain as an application grows.\n\nPrisma ORM on the other hand generates a lightweight database client that exposes a tailored and fully type-safe API to read and write data for the models that are defined in the Prisma schema, following the DataMapper ORM pattern rather than Active Record.\n\nPrisma ORM's DSL for data modeling is lean, simple and intuitive to use. When modeling data in VS Code, you can further take advantage of Prisma ORM's powerful VS Code extension with features like autocompletion, quick fixes, jump to definition and other benefits that increase developer productivity.\n\n**Prisma ORM**\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  authorId  Int?  author    User?   @relation(fields: [authorId], references: [id])}\n```\n\n**TypeORM**\n\n```\nimport {  Entity,  PrimaryGeneratedColumn,  Column,  OneToMany,  ManyToOne,} from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ nullable: true })  name: string  @Column({ unique: true })  email: string  @OneToMany((type) => Post, (post) => post.author)  posts: Post[]}@Entity()export class Post {  @PrimaryGeneratedColumn()  id: number  @Column()  title: string  @Column({ nullable: true })  content: string  @Column({ default: false })  published: boolean  @ManyToOne((type) => User, (user) => user.posts)  author: User}\n```\n\nMigrations work in similar fashions in TypeORM and Prisma ORM. Both tools follow the approach of generating SQL files based on the provided model definitions and provide a CLI to execute them against the database. The SQL files can be modified before the migrations are executed so that any custom database operation can be performed with either migration system.\n\n## Type safety[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safety \"Direct link to Type safety\")\n\nTypeORM has been one of the first ORMs in the Node.js ecosystem to fully embrace TypeScript and has done a great job in enabling developers to get a certain level of type safety for their database queries.\n\nHowever, there are numerous situations where the type safety guarantees of TypeORM fall short. The following sections describe the scenarios where Prisma ORM can provide stronger guarantees for the types of query results.\n\n### Selecting fields[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#selecting-fields \"Direct link to Selecting fields\")\n\nThis section explains the differences in type safety when selecting a subset of a model's fields in a query.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm \"Direct link to TypeORM\")\n\nTypeORM provides a `select` option for its [`find`](https://typeorm.io/#/find-options) methods (e.g. `find`, `findByIds`, `findOne`, ...), for example:\n\n*   \\`find\\` with \\`select\\`\n*   Model\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: { published: true },  select: ['id', 'title'],})\n```\n\nWhile each object in the returned `publishedPosts` array only carries the selected `id` and `title` properties at runtime, the TypeScript compiler doesn't have any knowledge of this. It will allow you to access any other properties defined on the `Post` entity after the query, for example:\n\n```\nconst post = publishedPosts[0]// The TypeScript compiler has no issue with thisif (post.content.length > 0) {  console.log(`This post has some content.`)}\n```\n\nThis code will result in an error at runtime:\n\n```\nTypeError: Cannot read property 'length' of undefined\n```\n\nThe TypeScript compiler only sees the `Post` type of the returned objects, but it doesn't know about the fields that these objects _actually_ carry at runtime. It therefore can't protect you from accessing fields that have not been retrieved in the database query, resulting in a runtime error.\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm \"Direct link to Prisma ORM\")\n\nPrisma Client can guarantee full type safety in the same situation and protects you from accessing fields that were not retrieved from the database.\n\nConsider the same example with a Prisma Client query:\n\n*   \\`findMany\\` with \\`select\\`\n*   Model\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: { published: true },  select: {    id: true,    title: true,  },})const post = publishedPosts[0]// The TypeScript compiler will not allow thisif (post.content.length > 0) {  console.log(`This post has some content.`)}\n```\n\nIn this case, the TypeScript compiler will throw the following error already at compile-time:\n\n```\n[ERROR] 14:03:39 ⨯ Unable to compile TypeScript:src/index.ts:36:12 - error TS2339: Property 'content' does not exist on type '{ id: number; title: string; }'.42   if (post.content.length > 0) {\n```\n\nThis is because Prisma Client generates the return type for its queries _on the fly_. In this case, `publishedPosts` is typed as follows:\n\n```\nconst publishedPosts: {  id: number  title: string}[]\n```\n\nIt therefore is impossible for you to accidentally access a property on a model that has not been retrieved in a query.\n\n### Loading relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#loading-relations \"Direct link to Loading relations\")\n\nThis section explains the differences in type safety when loading relations of a model in a query. In traditional ORMs, this is sometimes called _eager loading_.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-1 \"Direct link to TypeORM\")\n\nTypeORM allows to eagerly load relations from the database via the `relations` option that can be passed to its [`find`](https://typeorm.io/#/find-options) methods.\n\nConsider this example:\n\n*   \\`find\\` with \\`relations\\`\n*   Models\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: { published: true },  relations: ['author'],})\n```\n\nUnlike with `select`, TypeORM does _not_ provide autocompletion, nor any type-safety for the strings that are passed to the `relations` option. This means, the TypeScript compiler is not able to catch any typos that are made when querying these relations. For example, it would allow for the following query:\n\n```\nconst publishedPosts: Post[] = await postRepository.find({  where: { published: true },  // this query would lead to a runtime error because of a typo  relations: ['authors'],})\n```\n\nThis subtle typo would now lead to the following runtime error:\n\n```\nUnhandledPromiseRejectionWarning: Error: Relation \"authors\" was not found; please check if it is correct and really exists in your entity.\n```\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-1 \"Direct link to Prisma ORM\")\n\nPrisma ORM protects you from mistakes like this and thus eliminates a whole class of errors that can occur in your application at runtime. When using `include` to load a relation in a Prisma Client query, you can not only take advantage of autocompletion to specify the query, but the result of the query will also be properly typed:\n\n*   \\`find\\` with \\`relations\\`\n*   Models\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: { published: true },  include: { author: true },})\n```\n\nAgain, the type of `publishedPosts` is generated on the fly and looks as follows:\n\n```\nconst publishedPosts: (Post & {  author: User})[]\n```\n\nFor reference, this is what the `User` and `Post` types look like that Prisma Client generates for your Prisma models:\n\n*   \\`User\\`\n*   \\`Post\\`\n\n```\n// Generated by Prisma ORMexport type User = {  id: number  name: string | null  email: string}\n```\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-1 \"Direct link to Filtering\")\n\nThis section explains the differences in type safety when filtering a list of records using `where`.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-2 \"Direct link to TypeORM\")\n\nTypeORM allows to pass a `where` option to its [`find`](https://typeorm.io/#/find-options) methods to filter the list of returned records according to specific criteria. These criteria can be defined with respect to a model's properties.\n\n##### Loosing type-safety using operators[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#loosing-type-safety-using-operators \"Direct link to Loosing type-safety using operators\")\n\nConsider this example:\n\n*   \\`find\\` with \\`select\\`\n*   Model\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    views: MoreThan(0),  },})\n```\n\nThis code runs properly and produces a valid query at runtime. However, the `where` option is not really type-safe in various different scenarios. When using a `FindOperator` like `ILike` or `MoreThan` that only work for specific types (`ILike` works for strings, `MoreThan` for numbers), you're losing the guarantee of providing the correct type for the model's field.\n\nFor example, you can provide a string to the `MoreThan` operator. The TypeScript compiler will not complain and your application will only fail at runtime:\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    views: MoreThan('test'),  },})\n```\n\nThe code above results in a runtime error that the TypeScript compiler doesn't catch for you:\n\n```\nerror: error: invalid input syntax for type integer: \"test\"\n```\n\n##### Specifying non-existing properties[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#specifying-non-existing-properties \"Direct link to Specifying non-existing properties\")\n\nAlso note that the TypeScript compiler allows you to specify properties on the `where` option that don't exist on your models – again resulting in runtime errors:\n\n```\nconst publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    viewCount: 1,  },})\n```\n\nIn this case, your application again fails at runtime with the following error:\n\n```\nEntityColumnNotFound: No entity column \"viewCount\" was found.\n```\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-2 \"Direct link to Prisma ORM\")\n\nBoth filtering scenarios that are problematic with TypeORM in terms of type-safety are covered by Prisma ORM in a fully type-safe way.\n\n##### Type-safe usage of operators[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safe-usage-of-operators \"Direct link to Type-safe usage of operators\")\n\nWith Prisma ORM, the TypeScript compiler enforces the correct usage of an operator per field:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    views: { gt: 0 },  },})\n```\n\nIt would not be allowed to specify the same problematic query shown above with Prisma Client:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    views: { gt: 'test' }, // Caught by the TypeScript compiler  },})\n```\n\nThe TypeScript compiler would catch this and throw the following error to protect you from a runtime failure of the app:\n\n```\n[ERROR] 16:13:50 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2322: Type '{ gt: string; }' is not assignable to type 'number | IntNullableFilter'.  Type '{ gt: string; }' is not assignable to type 'IntNullableFilter'.    Types of property 'gt' are incompatible.      Type 'string' is not assignable to type 'number'.42     views: { gt: \"test\" }\n```\n\n##### Type-safe definition of filters as model properties[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safe-definition-of-filters-as-model-properties \"Direct link to Type-safe definition of filters as model properties\")\n\nWith TypeORM, you are able to specify a property on the `where` option that doesn't map to a model's field. In the above example, filtering for `viewCount` therefore led to a runtime error because the field actually is called `views`.\n\nWith Prisma ORM, the TypeScript compiler will not allow to reference any properties inside of `where` that don't exist on the model:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    viewCount: { gt: 0 }, // Caught by the TypeScript compiler  },})\n```\n\nAgain, the TypeScript compiler complains with the following message to protect you from your own mistakes:\n\n```\n[ERROR] 16:16:16 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2322: Type '{ published: boolean; title: { contains: string; }; viewCount: { gt: number; }; }' is not assignable to type 'PostWhereInput'.  Object literal may only specify known properties, and 'viewCount' does not exist in type 'PostWhereInput'.42     viewCount: { gt: 0 }\n```\n\n### Creating new records[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#creating-new-records \"Direct link to Creating new records\")\n\nThis section explains the differences in type safety when creating new records.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-3 \"Direct link to TypeORM\")\n\nWith TypeORM, there are two main ways to create new records in the database: `insert` and `save`. Both methods allow developers to submit data that can lead to runtime errors when _required_ fields are not provided.\n\nConsider this example:\n\n*   Create with \\`save\\`\n*   Create with \\`insert\\`\n*   Model\n\n```\nconst userRepository = getManager().getRepository(User)const newUser = new User()newUser.name = 'Alice'userRepository.save(newUser)\n```\n\nNo matter if you're using `save` or `insert` for record creation with TypeORM, you will get the following runtime error if you forget to provide the value for a required field:\n\n```\nQueryFailedError: null value in column \"email\" of relation \"user\" violates not-null constraint\n```\n\nThe `email` field is defined as required on the `User` entity (which is enforced by a `NOT NULL` constraint in the database).\n\n### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-3 \"Direct link to Prisma ORM\")\n\nPrisma ORM protects you from these kind of mistakes by enforcing that you submit values for _all_ required fields of a model.\n\nFor example, the following attempt to create a new `User` where the required `email` field is missing would be caught by the TypeScript compiler:\n\n*   Create with \\`create\\`\n*   Model\n\n```\nconst newUser = await prisma.user.create({  data: {    name: 'Alice',  },})\n```\n\nIt would lead to the following compile-time error:\n\n```\n[ERROR] 10:39:07 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2741: Property 'email' is missing in type '{ name: string; }' but required in type 'UserCreateInput'.\n```\n\n## API comparison[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-comparison \"Direct link to API comparison\")\n\n### Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id)\n```\n\n### Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id, {  select: ['id', 'email'],})\n```\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using include\n*   Fluent API\n\n```\nconst posts = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n> **Note**: `select` return a `user` object that includes a `post` array, whereas the fluent API only returns a `post` array.\n\n**TypeORM**\n\n*   Using \\`relations\\`\n*   Using \\`JOIN\\`\n*   Using earger relations\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id, {  relations: ['posts'],})\n```\n\n### Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello',    },  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const users = await userRepository.find({  where: {    name: 'Alice',  },})\n```\n\n### Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**TypeORM**\n\nTypeORM provides [built-in operators](https://typeorm.io/#/find-options/advanced-options) that can be used to create more complex comparisons\n\n### Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**TypeORM**\n\nTypeORM doesn't offer a dedicated API for relation filters. You can get similar functionality by using the `QueryBuilder` or writing the queries by hand.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = await prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = await prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**TypeORM**\n\n```\nconst postRepository = getRepository(Post)const posts = await postRepository.find({  skip: 5,  take: 10,})\n```\n\n### Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',  },})\n```\n\n**TypeORM**\n\n*   Using \\`save\\`\n*   Using \\`create\\`\n*   Using \\`insert\\`\n\n```\nconst user = new User()user.name = 'Alice'user.email = 'alice@prisma.io'await user.save()\n```\n\n### Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const updatedUser = await userRepository.update(id, {  name: 'James',  email: 'james@prisma.io',})\n```\n\n### Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst deletedUser = await prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**TypeORM**\n\n*   Using \\`delete\\`\n*   Using \\`remove\\`\n\n```\nconst userRepository = getRepository(User)await userRepository.delete(id)\n```\n\n### Batch updates[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#batch-updates \"Direct link to Batch updates\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.updateMany({  data: {    name: 'Published author!',  },  where: {    Post: {      some: {        published: true,      },    },  },})\n```\n\n**TypeORM**\n\nYou can use the [query builder to update entities in your database](https://typeorm.io/#/update-query-builder).\n\n### Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**TypeORM**\n\n*   Using \\`delete\\`\n*   Using \\`remove\\`\n\n```\nconst userRepository = getRepository(User)await userRepository.delete([id1, id2, id3])\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#transactions \"Direct link to Transactions\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'bob.rufus@prisma.io',    name: 'Bob Rufus',    Post: {      create: [        { title: 'Working at Prisma' },        { title: 'All about databases' },      ],    },  },})\n```\n\n**TypeORM**\n\n```\nawait getConnection().$transaction(async (transactionalEntityManager) => {  const user = getRepository(User).create({    name: 'Bob',    email: 'bob@prisma.io',  })  const post1 = getRepository(Post).create({    title: 'Join us for GraphQL Conf in 2019',  })  const post2 = getRepository(Post).create({    title: 'Subscribe to GraphQL Weekly for GraphQL news',  })  user.posts = [post1, post2]  await transactionalEntityManager.save(post1)  await transactionalEntityManager.save(post2)  await transactionalEntityManager.save(user)})\n```",
    "title": "Prisma ORM vs TypeORM | Prisma Documentation",
    "description": "Learn how Prisma compares to TypeORM.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize",
    "markdown": "# Prisma ORM vs Sequelize | Prisma Documentation\n\nThis page compares the Prisma ORM and [Sequelize](https://sequelize.org/master/) APIs.\n\n## Sequelize vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#sequelize-vs-prisma-orm \"Direct link to Sequelize vs Prisma ORM\")\n\nWhile Prisma ORM and Sequelize solve similar problems, they work in very different ways.\n\n**Sequelize** is a traditional ORM which maps _tables_ to _model classes_. Instances of the model classes then provide an interface for CRUD queries to an application at runtime.\n\n**Prisma ORM** is a new kind of ORM that mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading.\n\nIt uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows to generate SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## API comparison[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#api-comparison \"Direct link to API comparison\")\n\n### Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(id)\n```\n\n### Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(1, { attributes: ['name'], raw: true })\n```\n\ntip\n\nUse the `raw: true` query option to return plain JavaScript objects.\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using \\`include\\`\n*   Fluent API\n\n```\nconst posts = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n> **Note**: `select` returns a `user` object that includes a `post` array, whereas the fluent API only returns a `post` array.\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(id, {  include: [    {      model: Post,    },  ],})\n```\n\ntip\n\nUse `model: Post as \"Post\"` if you used an alias to define the relationship between `User` and `Post` - for example: `User.hasMany(Post, { as: \"Post\", foreignKey: \"authorId\" });`\n\n### Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello',    },  },})\n```\n\n**Sequelize**\n\n```\nconst post = await Post.findAll({  raw: true,  where: {    title: {      [Op.like]: '%Hello%',    },  },})\n```\n\n### Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**Sequelize**\n\nSequelize has an [extensive set of operators](https://sequelize.org/master/manual/querying.html#operators).\n\n### Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**Sequelize**\n\nSequelize [doesn't offer a dedicated API for relation filters](https://github.com/sequelize/sequelize/issues/10943). You can get similar functionality by sending a raw SQL query to the database.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = await prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = await prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**Sequelize**\n\nCursor pagination:\n\n```\nconst posts = await Post.findAll({  limit: 20,  where: {    id: {      [Op.gt]: 242,    },  },})\n```\n\n> **Note**: Sequelize use the [Sequelize operators](https://sequelize.org/docs/v6/core-concepts/model-querying-basics/#operators) to perform cursor pagination.\n\nOffset pagination:\n\n```\nconst posts = await Post.findAll({  offset: 5,  limit: 10,})\n```\n\n### Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',  },})\n```\n\n**Sequelize**\n\n*   Using \\`save\\`\n*   Using \\`create\\`\n\n```\nconst user = User.build({  name: 'Alice',  email: 'alice@prisma,io',})await user.save()\n```\n\n### Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**Sequelize**\n\n*   Using \\`save\\`\n*   Using \\`update\\`\n\n```\nuser.name = 'James'user.email = ' alice@prisma.com'await user.save()\n```\n\n### Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**Sequelize**\n\n### Batch updates[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#batch-updates \"Direct link to Batch updates\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.updateMany({  data: {    name: 'Published author!',  },  where: {    email: {      contains: 'prisma.io',    },  },})\n```\n\n**Sequelize**\n\n```\nconst updatedUsers = await User.update({  { role: \"Admin\" },  where: {    email: {      [Op.like]: \"%@prisma.io\"    }  },})\n```\n\n### Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**Sequelize**\n\n```\nawait User.destroy({  where: {    id: {      [Op.in]: [id1, id2, id3],    },  },})\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#transactions \"Direct link to Transactions\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'bob.rufus@prisma.io',    name: 'Bob Rufus',    Post: {      create: [        { title: 'Working at Prisma' },        { title: 'All about databases' },      ],    },  },})\n```\n\n**Sequelize**\n\n*   Manual\n*   Automatic\n\n```\nreturn sequelize.$transaction(async (t) => {  const user = await User.create(    {      name: 'Alice',      email: 'alice@prisma,io',    },    {      transaction: t,    }  )  const post1 = await Post.create(    {      title: 'Join us for GraphQL Conf in 2019',    },    {      transaction: t,    }  )  const post2 = await Post.create(    {      title: 'Subscribe to GraphQL Weekly for GraphQL news',    },    {      transaction: t,    }  )  await user.setPosts([post1, post2])})\n```",
    "title": "Prisma ORM vs Sequelize | Prisma Documentation",
    "description": "Learn how Prisma ORM compares to Sequelize.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/development-environment/editor-setup",
    "markdown": "# Editor and IDE setup | Prisma Documentation\n\nThis page describes how you can configure your editor for an optimal developer experience when using Prisma ORM.\n\nIf you don't see your editor here, please [open a feature request](https://github.com/prisma/prisma/issues/new?assignees=&labels=&template=feature_request.md&title=) and ask for dedicated support for your editor (e.g. for syntax highlighting and auto-formatting).\n\nYou can get IDE-style autocompletion for Prisma CLI using [`inshellisense`](https://github.com/microsoft/inshellisense/tree/main). It supports: bash, zsh, fish, pwsh, powershell (Windows Powershell).\n\n```\nnpm install -g @microsoft/inshellisense\n```\n\n`inshellisense` is built on top of [Fig](https://fig.io/) which you can also use directly. It works in bash, zsh, and fish.",
    "title": "Editor and IDE setup | Prisma Documentation",
    "description": "Learn how to configure your editor and IDEs for an optimal developer experience with Prisma ORM.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose",
    "markdown": "# Prisma ORM vs Mongoose | Prisma Documentation\n\nThis page compares the Prisma ORM and [Mongoose](https://mongoosejs.com/docs/guide.html) APIs. If you want to learn how to migrate from Mongoose to Prisma, check out this [guide](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose).\n\n## Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**Mongoose**\n\n```\nconst result = await User.findById(1)\n```\n\n## Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**Mongoose**\n\n```\nconst user = await User.findById(1).select(['name'])\n```\n\n## Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using \\`include\\`\n*   Fluent API\n\n```\nconst userWithPost = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n**Mongoose**\n\n```\nconst userWithPost = await User.findById(2).populate('post')\n```\n\n## Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello World',    },  },})\n```\n\n**Mongoose**\n\n```\nconst posts = await Post.find({  title: 'Hello World',})\n```\n\n## Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**Mongoose**\n\nMongoose exposes the [MongoDB query selectors](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors) as filter criteria.\n\n## Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**Mongoose**\n\nMongoose doesn't offer a dedicated API for relation filters. You can get similar functionality by adding an additional step to filter the results returned by the query.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**Mongoose**\n\n```\nconst posts = await Post.find({  skip: 200,  limit: 20,})\n```\n\n## Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    name: 'Alice',    email: 'alice@prisma.io',  },})\n```\n\n**Mongoose**\n\n*   Using \\`create\\`\n*   Using \\`save\\`\n\n```\nconst user = await User.create({  name: 'Alice',  email: 'alice@prisma.io',})\n```\n\n## Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**Mongoose**\n\n*   Using \\`findOneAndUpdate\\`\n*   Using \\`save\\`\n\n```\nconst updatedUser = await User.findOneAndUpdate(  { _id: 2 },  {    $set: {      name: 'Alicia',    },  })\n```\n\n## Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst user = prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**Mongoose**\n\n```\nawait User.deleteOne({ _id: 10 })\n```\n\n## Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**Mongoose**\n\n```\nawait User.deleteMany({ id: { $in: [1, 2, 6, 6, 22, 21, 25] } })\n```",
    "title": "Prisma ORM vs Mongoose | Prisma Documentation",
    "description": "Learn how Prisma ORM compares to Mongoose.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module",
    "markdown": "# Add Prisma ORM Easily to Your Nuxt Apps\n\n## Using the Nuxt Prisma Module\n\nThe Nuxt Prisma module simplifies the integration of Prisma ORM into your Nuxt applications.\n\n[Prisma ORM](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma) is a database library that lets you model your database schema, provides auto-generated migrations and lets you query the database in an intuitive and type-safe way.\n\nThis module provides several features to streamline the setup and usage of Prisma ORM in a Nuxt application, making it easier to interact with your database.\n\n## Features[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#features \"Direct link to Features\")\n\n*   **Project initialization**: Automatically sets up a Prisma ORM project with a SQLite database within your Nuxt project.\n*   **Composable**: Provides an auto-imported `usePrismaClient()` composable for use in your Vue files.\n*   **API route integration**: Automatically imports an instance of `PrismaClient` for use in API routes to query your DB.\n*   **Prisma Studio access**: Enables access to Prisma Studio through Nuxt Devtools for viewing and manually editing data.\n\n## Getting started[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started \"Direct link to Getting started\")\n\n1.  Create a [new Nuxt Project](https://nuxt.com/docs/getting-started/installation#new-project):\n    \n    ```\n    npx nuxi@latest init test-nuxt-app\n    ```\n    \n2.  Navigate to project directory and install `@prisma/nuxt` using the Nuxt CLI:\n    \n    ```\n    cd test-nuxt-appnpx nuxi@latest module add @prisma/nuxt\n    ```\n    \n3.  Start the development server:\n    \n    Starting the development server will:\n    \n    1.  Automatically install the [Prisma CLI](https://www.prisma.io/docs/orm/reference/prisma-cli-reference)\n    2.  Initialize a Prisma project with SQLite\n    3.  Create an `User` and `Post` example model in the Prisma Schema file:\n        \n        prisma/schema.prisma\n        \n        ```\n         // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client {   provider = \"prisma-client-js\" } datasource db {   provider = \"sqlite\"   url      = env(\"DATABASE_URL\") } model User {   id    Int     @id @default(autoincrement())   email String  @unique   name  String?   posts Post[] } model Post {   id        Int     @id @default(autoincrement())   title     String   content   String?   published Boolean @default(false)   author    User    @relation(fields: [authorId], references: [id])   authorId  Int }\n        ```\n        \n    4.  Prompt you to run a migration to create database tables with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/overview)\n        \n        note\n        \n        The database migrates automatically the first time you start the module if there isn't a `migrations` folder. After that, you need to run `npx prisma migrate dev` manually in the CLI to apply any schema changes. Running the `npx prisma migrate dev` command manually makes it easier and safer to manage migrations and also to [troubleshoot](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting) any migration-related errors.\n        \n    5.  Install and generate a [Prisma Client](https://www.prisma.io/docs/orm/reference/prisma-client-reference) which enables you to query your DB\n    6.  Prompt you to start the [Prisma Studio](https://www.prisma.io/docs/orm/tools/prisma-studio)\n4.  You can now use Prisma ORM in your project. If you accepted the prompt to add Prisma Studio, you can access Prisma Studio through the Nuxt Devtools. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n    \n\n## Using a different database provider[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-different-database-provider \"Direct link to Using a different database provider\")\n\nThe `@prisma/nuxt` module works with any [database provider that Prisma ORM supports](https://www.prisma.io/docs/orm/reference/supported-databases). You can configure the [getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a database of your choice. The steps would be different for a [database without existing data](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-without-existing-data) and a [database with pre-existing data](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-with-pre-existing-data).\n\n### Using a database without existing data[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-without-existing-data \"Direct link to Using a database without existing data\")\n\nTo configure [the getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a PostgreSQL database without any existing data:\n\n1.  Stop the Nuxt development server and Prisma Studio (if they are still running):\n    \n    ```\n    npx kill-port 3000  # Stops Nuxt dev server (default port)npx kill-port 5555  # Stops Prisma Studio (default port)\n    ```\n    \n2.  Navigate to the `schema.prisma` file and update the `datasource` block to specify the `postgresql` provider:\n    \n    prisma/schema.prisma\n    \n    ```\n    // This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemagenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int}\n    ```\n    \n3.  Update the `DATABASE_URL` environment variable in the `.env` file with your PostgreSQL database URL:\n    \n    .env\n    \n    ```\n    ## This is a sample database URL, please use a valid URLDATABASE_URL=\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"\n    ```\n    \n4.  Delete the SQLite database file and the migrations folder:\n    \n    ```\n    rm prisma/dev.db # Delete SQLite database filerm -r prisma/migrations # Delete the pre-existing migrations folder\n    ```\n    \n5.  Run the development server: Starting the development server will prompt you to migrate the schema changes to the database, to which you should agree. Then agree to the prompt to install and access Prisma Studio from the Nuxt Devtools.\n6.  The `@prisma/nuxt` module is ready to use with your PostgreSQL database. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n\n### Using a database with pre-existing data[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-with-pre-existing-data \"Direct link to Using a database with pre-existing data\")\n\nTo configure [the getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a PostgreSQL database that already has data in it:\n\n1.  Stop the dev server and Prisma Studio (if they are still running):\n    \n    ```\n    // stops Nuxt dev server from running incase it's still runningnpx kill-port 3000// stops Prisma Studio instance incase it's still runningnpx kill-port 5555\n    ```\n    \n2.  Delete the Prisma folder:\n3.  Update the `DATABASE_URL` environment variable in the `.env` file with your PostgreSQL database URL:\n    \n    .env\n    \n    ```\n    ## This is a sample database URL, please use a valid URLDATABASE_URL=\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"\n    ```\n    \n4.  To generate a Prisma Schema and migrations folder from the existing database, you have to [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) the database. Complete **step 1** to **step 4** from the [introspection guide](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#adding-prisma-migrate-to-an-existing-project) and continue.\n5.  Starting the development server will skip the prompt to migrate the schema changes to the database, as the migrations folder already exists. Agree to the prompt to install and access Prisma Studio from the Nuxt Devtools.\n6.  The `@prisma/nuxt` module is ready to be used with your PostgreSQL database. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n\n## Usage[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage \"Direct link to Usage\")\n\n### Option A: `usePrismaClient` composable[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#option-a-useprismaclient-composable \"Direct link to option-a-useprismaclient-composable\")\n\n#### Using the composable in your Nuxt server component[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-composable-in-your-nuxt-server-component \"Direct link to Using the composable in your Nuxt server component\")\n\nIf you're using [Nuxt server components](https://nuxt.com/docs/guide/directory-structure/components#server-components), you can use the global instance of the Prisma Client in your `.server.vue` files:\n\n```\n<script setup>  const prisma = usePrismaClient()  const user = await prisma.user.findFirst()</script><template>  <p>{{ user.name }}</p></template>\n```\n\n#### Using the auto-imported Prisma Client instance in your API route[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-auto-imported-prisma-client-instance-in-your-api-route \"Direct link to Using the auto-imported Prisma Client instance in your API route\")\n\nYou can use the auto-imported Prisma Client instance, prisma, in your Nuxt API route as follows:\n\n```\nexport default defineEventHandler(async (event) => {  return {    user: await prisma.user.findFirst(),  };});\n```\n\n### Option B: `lib/prisma.ts`[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#option-b-libprismats \"Direct link to option-b-libprismats\")\n\nAfter running through the initial setup prompts, this module creates the `lib/prisma.ts` file which contains a global instance of Prisma Client.\n\nlib/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prismaClientSingleton = () => {  return new PrismaClient()}declare const globalThis: {  prismaGlobal: ReturnType<typeof prismaClientSingleton>;} & typeof global;const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()export default prismaif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma\n```\n\nYou can customize Prisma Client's capabilities by using client extensions in your `lib/prisma.ts` file. Here is an example using the [Pulse client extension](https://www.npmjs.com/package/@prisma/extension-pulse):\n\nlib/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'import { withPulse } from '@prisma/extension-pulse'const prismaClientSingleton = () => {  return new PrismaClient().$extends(withPulse({    apiKey: process.env.PULSE_API_KEY  }))}declare const globalThis: {  prismaGlobal: ReturnType<typeof prismaClientSingleton>;} & typeof global;const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()export default prismaif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma\n```\n\n#### Using the global Prisma Client instance in your API route[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-global-prisma-client-instance-in-your-api-route \"Direct link to Using the global Prisma Client instance in your API route\")\n\nYou can use the global instance of the Prisma Client in your Nuxt API route as follows:\n\n```\nimport prisma from \"~/lib/prisma\";export default defineEventHandler(async (event) => {  return {    user: await prisma.user.findFirst(),  };});\n```\n\n#### Using the global Prisma Client instance in your Nuxt server component[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-global-prisma-client-instance-in-your-nuxt-server-component \"Direct link to Using the global Prisma Client instance in your Nuxt server component\")\n\nIf you're using [Nuxt server components](https://nuxt.com/docs/guide/directory-structure/components#server-components), you can use the global instance of the Prisma Client `.server.vue` files:\n\n```\n<script setup>  import prisma from '~/lib/prisma';  const user = await prisma.user.findFirst()</script><template>  <p>{{ user.name }}</p></template>\n```\n\n## Configuration[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#configuration \"Direct link to Configuration\")\n\nYou can configure the `@prisma/nuxt` module by using the `prisma` key in `nuxt.config.ts`:\n\nnuxt.config.ts\n\n```\nexport default defineNuxtConfig({  // ...  prisma: {    // Options  }})\n```\n\n  \n\nnote\n\nThe `prisma` key is available in `nuxt.config.ts` after successfully setting up the module by running `npm run dev`\n\n| Option | Type | Default | Description |\n| --- | --- | --- | --- |\n| **installCLI** | `boolean` | true | Whether to install the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli). |\n| **installClient** | `boolean` | true | Whether to install the [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) library in the project. |\n| **generateClient** | `boolean` | true | Whether to [generate](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client) the `PrismaClient` instance. Executes `npx prisma generate` on every run to update the client based on the schema changes. |\n| **formatSchema** | `boolean` | true | Whether to [format](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#format) the [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file. |\n| **installStudio** | `boolean` | true | Whether to install and start [Prisma Studio](https://www.prisma.io/studio) in the Nuxt Devtools. |\n| **autoSetupPrisma** | `boolean` | false | Whether to skip all prompts during setup. This option is useful for automating Prisma setup in scripts or CI/CD pipelines. |\n\n## Limitations[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#limitations \"Direct link to Limitations\")\n\n### `PrismaClient` constructor options are not configurable in the `usePrismaClient` composable[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#prismaclient-constructor-options-are-not-configurable-in-the-useprismaclient-composable \"Direct link to prismaclient-constructor-options-are-not-configurable-in-the-useprismaclient-composable\")\n\nThe `usePrismaClient` module does not currently allow for configuration of `PrismaClient` [constructor options](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismaclient).\n\n### The `usePrismaClient` composable is not supported in edge runtimes[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#the-useprismaclient-composable-is-not-supported-in-edge-runtimes \"Direct link to the-useprismaclient-composable-is-not-supported-in-edge-runtimes\")\n\nThe `usePrismaClient` composable currently relies on a `PrismaClient` instance that does not work in edge runtimes. If you require edge support for the composable, please let us know on [Discord](https://pris.ly/discord) or [GitHub](https://github.com/prisma/nuxt-prisma).",
    "title": "Add Prisma ORM Easily to Your Nuxt Apps | Prisma Documentation",
    "description": "Learn how to easily add Prisma ORM to your Nuxt apps, use its features, and understand its limitations.",
    "languageCode": "en"
  }
]